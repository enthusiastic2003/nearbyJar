// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: securemessage.proto
// Protobuf Java Version: 4.26.1

package com.google.security.cryptauth.lib.securemessage;

public final class SecureMessageProto {
  private SecureMessageProto() {}
  static {
    com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
      com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
      /* major= */ 4,
      /* minor= */ 26,
      /* patch= */ 1,
      /* suffix= */ "",
      SecureMessageProto.class.getName());
  }
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  /**
   * <pre>
   * Supported "signature" schemes (both symmetric key and public key based)
   * </pre>
   *
   * Protobuf enum {@code securemessage.SigScheme}
   */
  public enum SigScheme
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>HMAC_SHA256 = 1;</code>
     */
    HMAC_SHA256(1),
    /**
     * <code>ECDSA_P256_SHA256 = 2;</code>
     */
    ECDSA_P256_SHA256(2),
    /**
     * <pre>
     * Not recommended -- use ECDSA_P256_SHA256 instead
     * </pre>
     *
     * <code>RSA2048_SHA256 = 3;</code>
     */
    RSA2048_SHA256(3),
    ;

    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        SigScheme.class.getName());
    }
    /**
     * <code>HMAC_SHA256 = 1;</code>
     */
    public static final int HMAC_SHA256_VALUE = 1;
    /**
     * <code>ECDSA_P256_SHA256 = 2;</code>
     */
    public static final int ECDSA_P256_SHA256_VALUE = 2;
    /**
     * <pre>
     * Not recommended -- use ECDSA_P256_SHA256 instead
     * </pre>
     *
     * <code>RSA2048_SHA256 = 3;</code>
     */
    public static final int RSA2048_SHA256_VALUE = 3;


    public final int getNumber() {
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static SigScheme valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static SigScheme forNumber(int value) {
      switch (value) {
        case 1: return HMAC_SHA256;
        case 2: return ECDSA_P256_SHA256;
        case 3: return RSA2048_SHA256;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<SigScheme>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        SigScheme> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<SigScheme>() {
            public SigScheme findValueByNumber(int number) {
              return SigScheme.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.getDescriptor().getEnumTypes().get(0);
    }

    private static final SigScheme[] VALUES = values();

    public static SigScheme valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private SigScheme(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:securemessage.SigScheme)
  }

  /**
   * <pre>
   * Supported encryption schemes
   * </pre>
   *
   * Protobuf enum {@code securemessage.EncScheme}
   */
  public enum EncScheme
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * No encryption
     * </pre>
     *
     * <code>NONE = 1;</code>
     */
    NONE(1),
    /**
     * <code>AES_256_CBC = 2;</code>
     */
    AES_256_CBC(2),
    ;

    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        EncScheme.class.getName());
    }
    /**
     * <pre>
     * No encryption
     * </pre>
     *
     * <code>NONE = 1;</code>
     */
    public static final int NONE_VALUE = 1;
    /**
     * <code>AES_256_CBC = 2;</code>
     */
    public static final int AES_256_CBC_VALUE = 2;


    public final int getNumber() {
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static EncScheme valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static EncScheme forNumber(int value) {
      switch (value) {
        case 1: return NONE;
        case 2: return AES_256_CBC;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EncScheme>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        EncScheme> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EncScheme>() {
            public EncScheme findValueByNumber(int number) {
              return EncScheme.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.getDescriptor().getEnumTypes().get(1);
    }

    private static final EncScheme[] VALUES = values();

    public static EncScheme valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private EncScheme(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:securemessage.EncScheme)
  }

  /**
   * <pre>
   * A list of supported public key types
   * </pre>
   *
   * Protobuf enum {@code securemessage.PublicKeyType}
   */
  public enum PublicKeyType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>EC_P256 = 1;</code>
     */
    EC_P256(1),
    /**
     * <code>RSA2048 = 2;</code>
     */
    RSA2048(2),
    /**
     * <pre>
     * 2048-bit MODP group 14, from RFC 3526
     * </pre>
     *
     * <code>DH2048_MODP = 3;</code>
     */
    DH2048_MODP(3),
    ;

    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        PublicKeyType.class.getName());
    }
    /**
     * <code>EC_P256 = 1;</code>
     */
    public static final int EC_P256_VALUE = 1;
    /**
     * <code>RSA2048 = 2;</code>
     */
    public static final int RSA2048_VALUE = 2;
    /**
     * <pre>
     * 2048-bit MODP group 14, from RFC 3526
     * </pre>
     *
     * <code>DH2048_MODP = 3;</code>
     */
    public static final int DH2048_MODP_VALUE = 3;


    public final int getNumber() {
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static PublicKeyType valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static PublicKeyType forNumber(int value) {
      switch (value) {
        case 1: return EC_P256;
        case 2: return RSA2048;
        case 3: return DH2048_MODP;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<PublicKeyType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        PublicKeyType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<PublicKeyType>() {
            public PublicKeyType findValueByNumber(int number) {
              return PublicKeyType.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.getDescriptor().getEnumTypes().get(2);
    }

    private static final PublicKeyType[] VALUES = values();

    public static PublicKeyType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private PublicKeyType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:securemessage.PublicKeyType)
  }

  public interface SecureMessageOrBuilder extends
      // @@protoc_insertion_point(interface_extends:securemessage.SecureMessage)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Must contain a HeaderAndBody message
     * </pre>
     *
     * <code>required bytes header_and_body = 1;</code>
     * @return Whether the headerAndBody field is set.
     */
    boolean hasHeaderAndBody();
    /**
     * <pre>
     * Must contain a HeaderAndBody message
     * </pre>
     *
     * <code>required bytes header_and_body = 1;</code>
     * @return The headerAndBody.
     */
    com.google.protobuf.ByteString getHeaderAndBody();

    /**
     * <pre>
     * Signature of header_and_body
     * </pre>
     *
     * <code>required bytes signature = 2;</code>
     * @return Whether the signature field is set.
     */
    boolean hasSignature();
    /**
     * <pre>
     * Signature of header_and_body
     * </pre>
     *
     * <code>required bytes signature = 2;</code>
     * @return The signature.
     */
    com.google.protobuf.ByteString getSignature();
  }
  /**
   * Protobuf type {@code securemessage.SecureMessage}
   */
  public static final class SecureMessage extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:securemessage.SecureMessage)
      SecureMessageOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        SecureMessage.class.getName());
    }
    // Use SecureMessage.newBuilder() to construct.
    private SecureMessage(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private SecureMessage() {
      headerAndBody_ = com.google.protobuf.ByteString.EMPTY;
      signature_ = com.google.protobuf.ByteString.EMPTY;
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_SecureMessage_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_SecureMessage_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage.class, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage.Builder.class);
    }

    private int bitField0_;
    public static final int HEADER_AND_BODY_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString headerAndBody_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * Must contain a HeaderAndBody message
     * </pre>
     *
     * <code>required bytes header_and_body = 1;</code>
     * @return Whether the headerAndBody field is set.
     */
    @java.lang.Override
    public boolean hasHeaderAndBody() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Must contain a HeaderAndBody message
     * </pre>
     *
     * <code>required bytes header_and_body = 1;</code>
     * @return The headerAndBody.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getHeaderAndBody() {
      return headerAndBody_;
    }

    public static final int SIGNATURE_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString signature_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * Signature of header_and_body
     * </pre>
     *
     * <code>required bytes signature = 2;</code>
     * @return Whether the signature field is set.
     */
    @java.lang.Override
    public boolean hasSignature() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Signature of header_and_body
     * </pre>
     *
     * <code>required bytes signature = 2;</code>
     * @return The signature.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSignature() {
      return signature_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasHeaderAndBody()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (!hasSignature()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeBytes(1, headerAndBody_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeBytes(2, signature_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, headerAndBody_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, signature_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage)) {
        return super.equals(obj);
      }
      com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage other = (com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage) obj;

      if (hasHeaderAndBody() != other.hasHeaderAndBody()) return false;
      if (hasHeaderAndBody()) {
        if (!getHeaderAndBody()
            .equals(other.getHeaderAndBody())) return false;
      }
      if (hasSignature() != other.hasSignature()) return false;
      if (hasSignature()) {
        if (!getSignature()
            .equals(other.getSignature())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasHeaderAndBody()) {
        hash = (37 * hash) + HEADER_AND_BODY_FIELD_NUMBER;
        hash = (53 * hash) + getHeaderAndBody().hashCode();
      }
      if (hasSignature()) {
        hash = (37 * hash) + SIGNATURE_FIELD_NUMBER;
        hash = (53 * hash) + getSignature().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code securemessage.SecureMessage}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:securemessage.SecureMessage)
        com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessageOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_SecureMessage_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_SecureMessage_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage.class, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage.Builder.class);
      }

      // Construct using com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        headerAndBody_ = com.google.protobuf.ByteString.EMPTY;
        signature_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_SecureMessage_descriptor;
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage getDefaultInstanceForType() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage build() {
        com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage buildPartial() {
        com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage result = new com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.headerAndBody_ = headerAndBody_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.signature_ = signature_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage) {
          return mergeFrom((com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage other) {
        if (other == com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage.getDefaultInstance()) return this;
        if (other.hasHeaderAndBody()) {
          setHeaderAndBody(other.getHeaderAndBody());
        }
        if (other.hasSignature()) {
          setSignature(other.getSignature());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasHeaderAndBody()) {
          return false;
        }
        if (!hasSignature()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                headerAndBody_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                signature_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString headerAndBody_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Must contain a HeaderAndBody message
       * </pre>
       *
       * <code>required bytes header_and_body = 1;</code>
       * @return Whether the headerAndBody field is set.
       */
      @java.lang.Override
      public boolean hasHeaderAndBody() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Must contain a HeaderAndBody message
       * </pre>
       *
       * <code>required bytes header_and_body = 1;</code>
       * @return The headerAndBody.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getHeaderAndBody() {
        return headerAndBody_;
      }
      /**
       * <pre>
       * Must contain a HeaderAndBody message
       * </pre>
       *
       * <code>required bytes header_and_body = 1;</code>
       * @param value The headerAndBody to set.
       * @return This builder for chaining.
       */
      public Builder setHeaderAndBody(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        headerAndBody_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Must contain a HeaderAndBody message
       * </pre>
       *
       * <code>required bytes header_and_body = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearHeaderAndBody() {
        bitField0_ = (bitField0_ & ~0x00000001);
        headerAndBody_ = getDefaultInstance().getHeaderAndBody();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString signature_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Signature of header_and_body
       * </pre>
       *
       * <code>required bytes signature = 2;</code>
       * @return Whether the signature field is set.
       */
      @java.lang.Override
      public boolean hasSignature() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Signature of header_and_body
       * </pre>
       *
       * <code>required bytes signature = 2;</code>
       * @return The signature.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSignature() {
        return signature_;
      }
      /**
       * <pre>
       * Signature of header_and_body
       * </pre>
       *
       * <code>required bytes signature = 2;</code>
       * @param value The signature to set.
       * @return This builder for chaining.
       */
      public Builder setSignature(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        signature_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Signature of header_and_body
       * </pre>
       *
       * <code>required bytes signature = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignature() {
        bitField0_ = (bitField0_ & ~0x00000002);
        signature_ = getDefaultInstance().getSignature();
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:securemessage.SecureMessage)
    }

    // @@protoc_insertion_point(class_scope:securemessage.SecureMessage)
    private static final com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage();
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SecureMessage>
        PARSER = new com.google.protobuf.AbstractParser<SecureMessage>() {
      @java.lang.Override
      public SecureMessage parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<SecureMessage> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SecureMessage> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SecureMessage getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface HeaderOrBuilder extends
      // @@protoc_insertion_point(interface_extends:securemessage.Header)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>required .securemessage.SigScheme signature_scheme = 1;</code>
     * @return Whether the signatureScheme field is set.
     */
    boolean hasSignatureScheme();
    /**
     * <code>required .securemessage.SigScheme signature_scheme = 1;</code>
     * @return The signatureScheme.
     */
    com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SigScheme getSignatureScheme();

    /**
     * <code>required .securemessage.EncScheme encryption_scheme = 2;</code>
     * @return Whether the encryptionScheme field is set.
     */
    boolean hasEncryptionScheme();
    /**
     * <code>required .securemessage.EncScheme encryption_scheme = 2;</code>
     * @return The encryptionScheme.
     */
    com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EncScheme getEncryptionScheme();

    /**
     * <pre>
     * Identifies the verification key
     * </pre>
     *
     * <code>optional bytes verification_key_id = 3;</code>
     * @return Whether the verificationKeyId field is set.
     */
    boolean hasVerificationKeyId();
    /**
     * <pre>
     * Identifies the verification key
     * </pre>
     *
     * <code>optional bytes verification_key_id = 3;</code>
     * @return The verificationKeyId.
     */
    com.google.protobuf.ByteString getVerificationKeyId();

    /**
     * <pre>
     * Identifies the decryption key
     * </pre>
     *
     * <code>optional bytes decryption_key_id = 4;</code>
     * @return Whether the decryptionKeyId field is set.
     */
    boolean hasDecryptionKeyId();
    /**
     * <pre>
     * Identifies the decryption key
     * </pre>
     *
     * <code>optional bytes decryption_key_id = 4;</code>
     * @return The decryptionKeyId.
     */
    com.google.protobuf.ByteString getDecryptionKeyId();

    /**
     * <pre>
     * Encryption may use an IV
     * </pre>
     *
     * <code>optional bytes iv = 5;</code>
     * @return Whether the iv field is set.
     */
    boolean hasIv();
    /**
     * <pre>
     * Encryption may use an IV
     * </pre>
     *
     * <code>optional bytes iv = 5;</code>
     * @return The iv.
     */
    com.google.protobuf.ByteString getIv();

    /**
     * <pre>
     * Arbitrary per-protocol public data, to be sent with the plain-text header
     * </pre>
     *
     * <code>optional bytes public_metadata = 6;</code>
     * @return Whether the publicMetadata field is set.
     */
    boolean hasPublicMetadata();
    /**
     * <pre>
     * Arbitrary per-protocol public data, to be sent with the plain-text header
     * </pre>
     *
     * <code>optional bytes public_metadata = 6;</code>
     * @return The publicMetadata.
     */
    com.google.protobuf.ByteString getPublicMetadata();

    /**
     * <pre>
     * The length of some associated data this is not sent in this SecureMessage,
     * but which will be bound to the signature.
     * </pre>
     *
     * <code>optional uint32 associated_data_length = 7 [default = 0];</code>
     * @return Whether the associatedDataLength field is set.
     */
    boolean hasAssociatedDataLength();
    /**
     * <pre>
     * The length of some associated data this is not sent in this SecureMessage,
     * but which will be bound to the signature.
     * </pre>
     *
     * <code>optional uint32 associated_data_length = 7 [default = 0];</code>
     * @return The associatedDataLength.
     */
    int getAssociatedDataLength();
  }
  /**
   * Protobuf type {@code securemessage.Header}
   */
  public static final class Header extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:securemessage.Header)
      HeaderOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        Header.class.getName());
    }
    // Use Header.newBuilder() to construct.
    private Header(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private Header() {
      signatureScheme_ = 1;
      encryptionScheme_ = 1;
      verificationKeyId_ = com.google.protobuf.ByteString.EMPTY;
      decryptionKeyId_ = com.google.protobuf.ByteString.EMPTY;
      iv_ = com.google.protobuf.ByteString.EMPTY;
      publicMetadata_ = com.google.protobuf.ByteString.EMPTY;
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_Header_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_Header_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header.class, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header.Builder.class);
    }

    private int bitField0_;
    public static final int SIGNATURE_SCHEME_FIELD_NUMBER = 1;
    private int signatureScheme_ = 1;
    /**
     * <code>required .securemessage.SigScheme signature_scheme = 1;</code>
     * @return Whether the signatureScheme field is set.
     */
    @java.lang.Override public boolean hasSignatureScheme() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>required .securemessage.SigScheme signature_scheme = 1;</code>
     * @return The signatureScheme.
     */
    @java.lang.Override public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SigScheme getSignatureScheme() {
      com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SigScheme result = com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SigScheme.forNumber(signatureScheme_);
      return result == null ? com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SigScheme.HMAC_SHA256 : result;
    }

    public static final int ENCRYPTION_SCHEME_FIELD_NUMBER = 2;
    private int encryptionScheme_ = 1;
    /**
     * <code>required .securemessage.EncScheme encryption_scheme = 2;</code>
     * @return Whether the encryptionScheme field is set.
     */
    @java.lang.Override public boolean hasEncryptionScheme() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>required .securemessage.EncScheme encryption_scheme = 2;</code>
     * @return The encryptionScheme.
     */
    @java.lang.Override public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EncScheme getEncryptionScheme() {
      com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EncScheme result = com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EncScheme.forNumber(encryptionScheme_);
      return result == null ? com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EncScheme.NONE : result;
    }

    public static final int VERIFICATION_KEY_ID_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString verificationKeyId_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * Identifies the verification key
     * </pre>
     *
     * <code>optional bytes verification_key_id = 3;</code>
     * @return Whether the verificationKeyId field is set.
     */
    @java.lang.Override
    public boolean hasVerificationKeyId() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Identifies the verification key
     * </pre>
     *
     * <code>optional bytes verification_key_id = 3;</code>
     * @return The verificationKeyId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getVerificationKeyId() {
      return verificationKeyId_;
    }

    public static final int DECRYPTION_KEY_ID_FIELD_NUMBER = 4;
    private com.google.protobuf.ByteString decryptionKeyId_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * Identifies the decryption key
     * </pre>
     *
     * <code>optional bytes decryption_key_id = 4;</code>
     * @return Whether the decryptionKeyId field is set.
     */
    @java.lang.Override
    public boolean hasDecryptionKeyId() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Identifies the decryption key
     * </pre>
     *
     * <code>optional bytes decryption_key_id = 4;</code>
     * @return The decryptionKeyId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getDecryptionKeyId() {
      return decryptionKeyId_;
    }

    public static final int IV_FIELD_NUMBER = 5;
    private com.google.protobuf.ByteString iv_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * Encryption may use an IV
     * </pre>
     *
     * <code>optional bytes iv = 5;</code>
     * @return Whether the iv field is set.
     */
    @java.lang.Override
    public boolean hasIv() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Encryption may use an IV
     * </pre>
     *
     * <code>optional bytes iv = 5;</code>
     * @return The iv.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getIv() {
      return iv_;
    }

    public static final int PUBLIC_METADATA_FIELD_NUMBER = 6;
    private com.google.protobuf.ByteString publicMetadata_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * Arbitrary per-protocol public data, to be sent with the plain-text header
     * </pre>
     *
     * <code>optional bytes public_metadata = 6;</code>
     * @return Whether the publicMetadata field is set.
     */
    @java.lang.Override
    public boolean hasPublicMetadata() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Arbitrary per-protocol public data, to be sent with the plain-text header
     * </pre>
     *
     * <code>optional bytes public_metadata = 6;</code>
     * @return The publicMetadata.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPublicMetadata() {
      return publicMetadata_;
    }

    public static final int ASSOCIATED_DATA_LENGTH_FIELD_NUMBER = 7;
    private int associatedDataLength_ = 0;
    /**
     * <pre>
     * The length of some associated data this is not sent in this SecureMessage,
     * but which will be bound to the signature.
     * </pre>
     *
     * <code>optional uint32 associated_data_length = 7 [default = 0];</code>
     * @return Whether the associatedDataLength field is set.
     */
    @java.lang.Override
    public boolean hasAssociatedDataLength() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * The length of some associated data this is not sent in this SecureMessage,
     * but which will be bound to the signature.
     * </pre>
     *
     * <code>optional uint32 associated_data_length = 7 [default = 0];</code>
     * @return The associatedDataLength.
     */
    @java.lang.Override
    public int getAssociatedDataLength() {
      return associatedDataLength_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasSignatureScheme()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (!hasEncryptionScheme()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeEnum(1, signatureScheme_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeEnum(2, encryptionScheme_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeBytes(3, verificationKeyId_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeBytes(4, decryptionKeyId_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeBytes(5, iv_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeBytes(6, publicMetadata_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeUInt32(7, associatedDataLength_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, signatureScheme_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(2, encryptionScheme_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(3, verificationKeyId_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(4, decryptionKeyId_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(5, iv_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(6, publicMetadata_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(7, associatedDataLength_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header)) {
        return super.equals(obj);
      }
      com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header other = (com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header) obj;

      if (hasSignatureScheme() != other.hasSignatureScheme()) return false;
      if (hasSignatureScheme()) {
        if (signatureScheme_ != other.signatureScheme_) return false;
      }
      if (hasEncryptionScheme() != other.hasEncryptionScheme()) return false;
      if (hasEncryptionScheme()) {
        if (encryptionScheme_ != other.encryptionScheme_) return false;
      }
      if (hasVerificationKeyId() != other.hasVerificationKeyId()) return false;
      if (hasVerificationKeyId()) {
        if (!getVerificationKeyId()
            .equals(other.getVerificationKeyId())) return false;
      }
      if (hasDecryptionKeyId() != other.hasDecryptionKeyId()) return false;
      if (hasDecryptionKeyId()) {
        if (!getDecryptionKeyId()
            .equals(other.getDecryptionKeyId())) return false;
      }
      if (hasIv() != other.hasIv()) return false;
      if (hasIv()) {
        if (!getIv()
            .equals(other.getIv())) return false;
      }
      if (hasPublicMetadata() != other.hasPublicMetadata()) return false;
      if (hasPublicMetadata()) {
        if (!getPublicMetadata()
            .equals(other.getPublicMetadata())) return false;
      }
      if (hasAssociatedDataLength() != other.hasAssociatedDataLength()) return false;
      if (hasAssociatedDataLength()) {
        if (getAssociatedDataLength()
            != other.getAssociatedDataLength()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasSignatureScheme()) {
        hash = (37 * hash) + SIGNATURE_SCHEME_FIELD_NUMBER;
        hash = (53 * hash) + signatureScheme_;
      }
      if (hasEncryptionScheme()) {
        hash = (37 * hash) + ENCRYPTION_SCHEME_FIELD_NUMBER;
        hash = (53 * hash) + encryptionScheme_;
      }
      if (hasVerificationKeyId()) {
        hash = (37 * hash) + VERIFICATION_KEY_ID_FIELD_NUMBER;
        hash = (53 * hash) + getVerificationKeyId().hashCode();
      }
      if (hasDecryptionKeyId()) {
        hash = (37 * hash) + DECRYPTION_KEY_ID_FIELD_NUMBER;
        hash = (53 * hash) + getDecryptionKeyId().hashCode();
      }
      if (hasIv()) {
        hash = (37 * hash) + IV_FIELD_NUMBER;
        hash = (53 * hash) + getIv().hashCode();
      }
      if (hasPublicMetadata()) {
        hash = (37 * hash) + PUBLIC_METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getPublicMetadata().hashCode();
      }
      if (hasAssociatedDataLength()) {
        hash = (37 * hash) + ASSOCIATED_DATA_LENGTH_FIELD_NUMBER;
        hash = (53 * hash) + getAssociatedDataLength();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code securemessage.Header}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:securemessage.Header)
        com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_Header_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_Header_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header.class, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header.Builder.class);
      }

      // Construct using com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        signatureScheme_ = 1;
        encryptionScheme_ = 1;
        verificationKeyId_ = com.google.protobuf.ByteString.EMPTY;
        decryptionKeyId_ = com.google.protobuf.ByteString.EMPTY;
        iv_ = com.google.protobuf.ByteString.EMPTY;
        publicMetadata_ = com.google.protobuf.ByteString.EMPTY;
        associatedDataLength_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_Header_descriptor;
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header getDefaultInstanceForType() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header build() {
        com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header buildPartial() {
        com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header result = new com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.signatureScheme_ = signatureScheme_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.encryptionScheme_ = encryptionScheme_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.verificationKeyId_ = verificationKeyId_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.decryptionKeyId_ = decryptionKeyId_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.iv_ = iv_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.publicMetadata_ = publicMetadata_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.associatedDataLength_ = associatedDataLength_;
          to_bitField0_ |= 0x00000040;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header) {
          return mergeFrom((com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header other) {
        if (other == com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header.getDefaultInstance()) return this;
        if (other.hasSignatureScheme()) {
          setSignatureScheme(other.getSignatureScheme());
        }
        if (other.hasEncryptionScheme()) {
          setEncryptionScheme(other.getEncryptionScheme());
        }
        if (other.hasVerificationKeyId()) {
          setVerificationKeyId(other.getVerificationKeyId());
        }
        if (other.hasDecryptionKeyId()) {
          setDecryptionKeyId(other.getDecryptionKeyId());
        }
        if (other.hasIv()) {
          setIv(other.getIv());
        }
        if (other.hasPublicMetadata()) {
          setPublicMetadata(other.getPublicMetadata());
        }
        if (other.hasAssociatedDataLength()) {
          setAssociatedDataLength(other.getAssociatedDataLength());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasSignatureScheme()) {
          return false;
        }
        if (!hasEncryptionScheme()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                int tmpRaw = input.readEnum();
                com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SigScheme tmpValue =
                    com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SigScheme.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(1, tmpRaw);
                } else {
                  signatureScheme_ = tmpRaw;
                  bitField0_ |= 0x00000001;
                }
                break;
              } // case 8
              case 16: {
                int tmpRaw = input.readEnum();
                com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EncScheme tmpValue =
                    com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EncScheme.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(2, tmpRaw);
                } else {
                  encryptionScheme_ = tmpRaw;
                  bitField0_ |= 0x00000002;
                }
                break;
              } // case 16
              case 26: {
                verificationKeyId_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                decryptionKeyId_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 42: {
                iv_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 42
              case 50: {
                publicMetadata_ = input.readBytes();
                bitField0_ |= 0x00000020;
                break;
              } // case 50
              case 56: {
                associatedDataLength_ = input.readUInt32();
                bitField0_ |= 0x00000040;
                break;
              } // case 56
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int signatureScheme_ = 1;
      /**
       * <code>required .securemessage.SigScheme signature_scheme = 1;</code>
       * @return Whether the signatureScheme field is set.
       */
      @java.lang.Override public boolean hasSignatureScheme() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>required .securemessage.SigScheme signature_scheme = 1;</code>
       * @return The signatureScheme.
       */
      @java.lang.Override
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SigScheme getSignatureScheme() {
        com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SigScheme result = com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SigScheme.forNumber(signatureScheme_);
        return result == null ? com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SigScheme.HMAC_SHA256 : result;
      }
      /**
       * <code>required .securemessage.SigScheme signature_scheme = 1;</code>
       * @param value The signatureScheme to set.
       * @return This builder for chaining.
       */
      public Builder setSignatureScheme(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SigScheme value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        signatureScheme_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>required .securemessage.SigScheme signature_scheme = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignatureScheme() {
        bitField0_ = (bitField0_ & ~0x00000001);
        signatureScheme_ = 1;
        onChanged();
        return this;
      }

      private int encryptionScheme_ = 1;
      /**
       * <code>required .securemessage.EncScheme encryption_scheme = 2;</code>
       * @return Whether the encryptionScheme field is set.
       */
      @java.lang.Override public boolean hasEncryptionScheme() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>required .securemessage.EncScheme encryption_scheme = 2;</code>
       * @return The encryptionScheme.
       */
      @java.lang.Override
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EncScheme getEncryptionScheme() {
        com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EncScheme result = com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EncScheme.forNumber(encryptionScheme_);
        return result == null ? com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EncScheme.NONE : result;
      }
      /**
       * <code>required .securemessage.EncScheme encryption_scheme = 2;</code>
       * @param value The encryptionScheme to set.
       * @return This builder for chaining.
       */
      public Builder setEncryptionScheme(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EncScheme value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        encryptionScheme_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>required .securemessage.EncScheme encryption_scheme = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearEncryptionScheme() {
        bitField0_ = (bitField0_ & ~0x00000002);
        encryptionScheme_ = 1;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString verificationKeyId_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Identifies the verification key
       * </pre>
       *
       * <code>optional bytes verification_key_id = 3;</code>
       * @return Whether the verificationKeyId field is set.
       */
      @java.lang.Override
      public boolean hasVerificationKeyId() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Identifies the verification key
       * </pre>
       *
       * <code>optional bytes verification_key_id = 3;</code>
       * @return The verificationKeyId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getVerificationKeyId() {
        return verificationKeyId_;
      }
      /**
       * <pre>
       * Identifies the verification key
       * </pre>
       *
       * <code>optional bytes verification_key_id = 3;</code>
       * @param value The verificationKeyId to set.
       * @return This builder for chaining.
       */
      public Builder setVerificationKeyId(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        verificationKeyId_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies the verification key
       * </pre>
       *
       * <code>optional bytes verification_key_id = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearVerificationKeyId() {
        bitField0_ = (bitField0_ & ~0x00000004);
        verificationKeyId_ = getDefaultInstance().getVerificationKeyId();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString decryptionKeyId_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Identifies the decryption key
       * </pre>
       *
       * <code>optional bytes decryption_key_id = 4;</code>
       * @return Whether the decryptionKeyId field is set.
       */
      @java.lang.Override
      public boolean hasDecryptionKeyId() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Identifies the decryption key
       * </pre>
       *
       * <code>optional bytes decryption_key_id = 4;</code>
       * @return The decryptionKeyId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getDecryptionKeyId() {
        return decryptionKeyId_;
      }
      /**
       * <pre>
       * Identifies the decryption key
       * </pre>
       *
       * <code>optional bytes decryption_key_id = 4;</code>
       * @param value The decryptionKeyId to set.
       * @return This builder for chaining.
       */
      public Builder setDecryptionKeyId(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        decryptionKeyId_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies the decryption key
       * </pre>
       *
       * <code>optional bytes decryption_key_id = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearDecryptionKeyId() {
        bitField0_ = (bitField0_ & ~0x00000008);
        decryptionKeyId_ = getDefaultInstance().getDecryptionKeyId();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString iv_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Encryption may use an IV
       * </pre>
       *
       * <code>optional bytes iv = 5;</code>
       * @return Whether the iv field is set.
       */
      @java.lang.Override
      public boolean hasIv() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Encryption may use an IV
       * </pre>
       *
       * <code>optional bytes iv = 5;</code>
       * @return The iv.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getIv() {
        return iv_;
      }
      /**
       * <pre>
       * Encryption may use an IV
       * </pre>
       *
       * <code>optional bytes iv = 5;</code>
       * @param value The iv to set.
       * @return This builder for chaining.
       */
      public Builder setIv(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        iv_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Encryption may use an IV
       * </pre>
       *
       * <code>optional bytes iv = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearIv() {
        bitField0_ = (bitField0_ & ~0x00000010);
        iv_ = getDefaultInstance().getIv();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString publicMetadata_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Arbitrary per-protocol public data, to be sent with the plain-text header
       * </pre>
       *
       * <code>optional bytes public_metadata = 6;</code>
       * @return Whether the publicMetadata field is set.
       */
      @java.lang.Override
      public boolean hasPublicMetadata() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * Arbitrary per-protocol public data, to be sent with the plain-text header
       * </pre>
       *
       * <code>optional bytes public_metadata = 6;</code>
       * @return The publicMetadata.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPublicMetadata() {
        return publicMetadata_;
      }
      /**
       * <pre>
       * Arbitrary per-protocol public data, to be sent with the plain-text header
       * </pre>
       *
       * <code>optional bytes public_metadata = 6;</code>
       * @param value The publicMetadata to set.
       * @return This builder for chaining.
       */
      public Builder setPublicMetadata(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        publicMetadata_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Arbitrary per-protocol public data, to be sent with the plain-text header
       * </pre>
       *
       * <code>optional bytes public_metadata = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearPublicMetadata() {
        bitField0_ = (bitField0_ & ~0x00000020);
        publicMetadata_ = getDefaultInstance().getPublicMetadata();
        onChanged();
        return this;
      }

      private int associatedDataLength_ ;
      /**
       * <pre>
       * The length of some associated data this is not sent in this SecureMessage,
       * but which will be bound to the signature.
       * </pre>
       *
       * <code>optional uint32 associated_data_length = 7 [default = 0];</code>
       * @return Whether the associatedDataLength field is set.
       */
      @java.lang.Override
      public boolean hasAssociatedDataLength() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * The length of some associated data this is not sent in this SecureMessage,
       * but which will be bound to the signature.
       * </pre>
       *
       * <code>optional uint32 associated_data_length = 7 [default = 0];</code>
       * @return The associatedDataLength.
       */
      @java.lang.Override
      public int getAssociatedDataLength() {
        return associatedDataLength_;
      }
      /**
       * <pre>
       * The length of some associated data this is not sent in this SecureMessage,
       * but which will be bound to the signature.
       * </pre>
       *
       * <code>optional uint32 associated_data_length = 7 [default = 0];</code>
       * @param value The associatedDataLength to set.
       * @return This builder for chaining.
       */
      public Builder setAssociatedDataLength(int value) {

        associatedDataLength_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The length of some associated data this is not sent in this SecureMessage,
       * but which will be bound to the signature.
       * </pre>
       *
       * <code>optional uint32 associated_data_length = 7 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearAssociatedDataLength() {
        bitField0_ = (bitField0_ & ~0x00000040);
        associatedDataLength_ = 0;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:securemessage.Header)
    }

    // @@protoc_insertion_point(class_scope:securemessage.Header)
    private static final com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header();
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Header>
        PARSER = new com.google.protobuf.AbstractParser<Header>() {
      @java.lang.Override
      public Header parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Header> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Header> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface HeaderAndBodyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:securemessage.HeaderAndBody)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Public data about this message (to be bound in the signature)
     * </pre>
     *
     * <code>required .securemessage.Header header = 1;</code>
     * @return Whether the header field is set.
     */
    boolean hasHeader();
    /**
     * <pre>
     * Public data about this message (to be bound in the signature)
     * </pre>
     *
     * <code>required .securemessage.Header header = 1;</code>
     * @return The header.
     */
    com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header getHeader();
    /**
     * <pre>
     * Public data about this message (to be bound in the signature)
     * </pre>
     *
     * <code>required .securemessage.Header header = 1;</code>
     */
    com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderOrBuilder getHeaderOrBuilder();

    /**
     * <pre>
     * Payload data
     * </pre>
     *
     * <code>required bytes body = 2;</code>
     * @return Whether the body field is set.
     */
    boolean hasBody();
    /**
     * <pre>
     * Payload data
     * </pre>
     *
     * <code>required bytes body = 2;</code>
     * @return The body.
     */
    com.google.protobuf.ByteString getBody();
  }
  /**
   * Protobuf type {@code securemessage.HeaderAndBody}
   */
  public static final class HeaderAndBody extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:securemessage.HeaderAndBody)
      HeaderAndBodyOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        HeaderAndBody.class.getName());
    }
    // Use HeaderAndBody.newBuilder() to construct.
    private HeaderAndBody(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private HeaderAndBody() {
      body_ = com.google.protobuf.ByteString.EMPTY;
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_HeaderAndBody_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_HeaderAndBody_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody.class, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody.Builder.class);
    }

    private int bitField0_;
    public static final int HEADER_FIELD_NUMBER = 1;
    private com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header header_;
    /**
     * <pre>
     * Public data about this message (to be bound in the signature)
     * </pre>
     *
     * <code>required .securemessage.Header header = 1;</code>
     * @return Whether the header field is set.
     */
    @java.lang.Override
    public boolean hasHeader() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Public data about this message (to be bound in the signature)
     * </pre>
     *
     * <code>required .securemessage.Header header = 1;</code>
     * @return The header.
     */
    @java.lang.Override
    public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header getHeader() {
      return header_ == null ? com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header.getDefaultInstance() : header_;
    }
    /**
     * <pre>
     * Public data about this message (to be bound in the signature)
     * </pre>
     *
     * <code>required .securemessage.Header header = 1;</code>
     */
    @java.lang.Override
    public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderOrBuilder getHeaderOrBuilder() {
      return header_ == null ? com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header.getDefaultInstance() : header_;
    }

    public static final int BODY_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString body_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * Payload data
     * </pre>
     *
     * <code>required bytes body = 2;</code>
     * @return Whether the body field is set.
     */
    @java.lang.Override
    public boolean hasBody() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Payload data
     * </pre>
     *
     * <code>required bytes body = 2;</code>
     * @return The body.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getBody() {
      return body_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasHeader()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (!hasBody()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (!getHeader().isInitialized()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getHeader());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeBytes(2, body_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getHeader());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, body_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody)) {
        return super.equals(obj);
      }
      com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody other = (com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody) obj;

      if (hasHeader() != other.hasHeader()) return false;
      if (hasHeader()) {
        if (!getHeader()
            .equals(other.getHeader())) return false;
      }
      if (hasBody() != other.hasBody()) return false;
      if (hasBody()) {
        if (!getBody()
            .equals(other.getBody())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasHeader()) {
        hash = (37 * hash) + HEADER_FIELD_NUMBER;
        hash = (53 * hash) + getHeader().hashCode();
      }
      if (hasBody()) {
        hash = (37 * hash) + BODY_FIELD_NUMBER;
        hash = (53 * hash) + getBody().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code securemessage.HeaderAndBody}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:securemessage.HeaderAndBody)
        com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_HeaderAndBody_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_HeaderAndBody_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody.class, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody.Builder.class);
      }

      // Construct using com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getHeaderFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        header_ = null;
        if (headerBuilder_ != null) {
          headerBuilder_.dispose();
          headerBuilder_ = null;
        }
        body_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_HeaderAndBody_descriptor;
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody getDefaultInstanceForType() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody build() {
        com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody buildPartial() {
        com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody result = new com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.header_ = headerBuilder_ == null
              ? header_
              : headerBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.body_ = body_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody) {
          return mergeFrom((com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody other) {
        if (other == com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody.getDefaultInstance()) return this;
        if (other.hasHeader()) {
          mergeHeader(other.getHeader());
        }
        if (other.hasBody()) {
          setBody(other.getBody());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasHeader()) {
          return false;
        }
        if (!hasBody()) {
          return false;
        }
        if (!getHeader().isInitialized()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getHeaderFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                body_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header header_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header.Builder, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderOrBuilder> headerBuilder_;
      /**
       * <pre>
       * Public data about this message (to be bound in the signature)
       * </pre>
       *
       * <code>required .securemessage.Header header = 1;</code>
       * @return Whether the header field is set.
       */
      public boolean hasHeader() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Public data about this message (to be bound in the signature)
       * </pre>
       *
       * <code>required .securemessage.Header header = 1;</code>
       * @return The header.
       */
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header getHeader() {
        if (headerBuilder_ == null) {
          return header_ == null ? com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header.getDefaultInstance() : header_;
        } else {
          return headerBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Public data about this message (to be bound in the signature)
       * </pre>
       *
       * <code>required .securemessage.Header header = 1;</code>
       */
      public Builder setHeader(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header value) {
        if (headerBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          header_ = value;
        } else {
          headerBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Public data about this message (to be bound in the signature)
       * </pre>
       *
       * <code>required .securemessage.Header header = 1;</code>
       */
      public Builder setHeader(
          com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header.Builder builderForValue) {
        if (headerBuilder_ == null) {
          header_ = builderForValue.build();
        } else {
          headerBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Public data about this message (to be bound in the signature)
       * </pre>
       *
       * <code>required .securemessage.Header header = 1;</code>
       */
      public Builder mergeHeader(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header value) {
        if (headerBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            header_ != null &&
            header_ != com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header.getDefaultInstance()) {
            getHeaderBuilder().mergeFrom(value);
          } else {
            header_ = value;
          }
        } else {
          headerBuilder_.mergeFrom(value);
        }
        if (header_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Public data about this message (to be bound in the signature)
       * </pre>
       *
       * <code>required .securemessage.Header header = 1;</code>
       */
      public Builder clearHeader() {
        bitField0_ = (bitField0_ & ~0x00000001);
        header_ = null;
        if (headerBuilder_ != null) {
          headerBuilder_.dispose();
          headerBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Public data about this message (to be bound in the signature)
       * </pre>
       *
       * <code>required .securemessage.Header header = 1;</code>
       */
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header.Builder getHeaderBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getHeaderFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Public data about this message (to be bound in the signature)
       * </pre>
       *
       * <code>required .securemessage.Header header = 1;</code>
       */
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderOrBuilder getHeaderOrBuilder() {
        if (headerBuilder_ != null) {
          return headerBuilder_.getMessageOrBuilder();
        } else {
          return header_ == null ?
              com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header.getDefaultInstance() : header_;
        }
      }
      /**
       * <pre>
       * Public data about this message (to be bound in the signature)
       * </pre>
       *
       * <code>required .securemessage.Header header = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header.Builder, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderOrBuilder> 
          getHeaderFieldBuilder() {
        if (headerBuilder_ == null) {
          headerBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.Header.Builder, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderOrBuilder>(
                  getHeader(),
                  getParentForChildren(),
                  isClean());
          header_ = null;
        }
        return headerBuilder_;
      }

      private com.google.protobuf.ByteString body_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Payload data
       * </pre>
       *
       * <code>required bytes body = 2;</code>
       * @return Whether the body field is set.
       */
      @java.lang.Override
      public boolean hasBody() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Payload data
       * </pre>
       *
       * <code>required bytes body = 2;</code>
       * @return The body.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getBody() {
        return body_;
      }
      /**
       * <pre>
       * Payload data
       * </pre>
       *
       * <code>required bytes body = 2;</code>
       * @param value The body to set.
       * @return This builder for chaining.
       */
      public Builder setBody(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        body_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Payload data
       * </pre>
       *
       * <code>required bytes body = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearBody() {
        bitField0_ = (bitField0_ & ~0x00000002);
        body_ = getDefaultInstance().getBody();
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:securemessage.HeaderAndBody)
    }

    // @@protoc_insertion_point(class_scope:securemessage.HeaderAndBody)
    private static final com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody();
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<HeaderAndBody>
        PARSER = new com.google.protobuf.AbstractParser<HeaderAndBody>() {
      @java.lang.Override
      public HeaderAndBody parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<HeaderAndBody> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<HeaderAndBody> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBody getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface HeaderAndBodyInternalOrBuilder extends
      // @@protoc_insertion_point(interface_extends:securemessage.HeaderAndBodyInternal)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * A raw (wire-format) byte encoding of a Header, suitable for hashing
     * </pre>
     *
     * <code>required bytes header = 1;</code>
     * @return Whether the header field is set.
     */
    boolean hasHeader();
    /**
     * <pre>
     * A raw (wire-format) byte encoding of a Header, suitable for hashing
     * </pre>
     *
     * <code>required bytes header = 1;</code>
     * @return The header.
     */
    com.google.protobuf.ByteString getHeader();

    /**
     * <pre>
     * Payload data
     * </pre>
     *
     * <code>required bytes body = 2;</code>
     * @return Whether the body field is set.
     */
    boolean hasBody();
    /**
     * <pre>
     * Payload data
     * </pre>
     *
     * <code>required bytes body = 2;</code>
     * @return The body.
     */
    com.google.protobuf.ByteString getBody();
  }
  /**
   * <pre>
   * Must be kept wire-format compatible with HeaderAndBody. Provides the
   * SecureMessage code with a consistent wire-format representation that
   * remains stable irrespective of protobuf implementation choices. This
   * low-level representation of a HeaderAndBody should not be used by
   * any code outside of the SecureMessage library implementation/tests.
   * </pre>
   *
   * Protobuf type {@code securemessage.HeaderAndBodyInternal}
   */
  public static final class HeaderAndBodyInternal extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:securemessage.HeaderAndBodyInternal)
      HeaderAndBodyInternalOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        HeaderAndBodyInternal.class.getName());
    }
    // Use HeaderAndBodyInternal.newBuilder() to construct.
    private HeaderAndBodyInternal(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private HeaderAndBodyInternal() {
      header_ = com.google.protobuf.ByteString.EMPTY;
      body_ = com.google.protobuf.ByteString.EMPTY;
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_HeaderAndBodyInternal_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_HeaderAndBodyInternal_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal.class, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal.Builder.class);
    }

    private int bitField0_;
    public static final int HEADER_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString header_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * A raw (wire-format) byte encoding of a Header, suitable for hashing
     * </pre>
     *
     * <code>required bytes header = 1;</code>
     * @return Whether the header field is set.
     */
    @java.lang.Override
    public boolean hasHeader() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * A raw (wire-format) byte encoding of a Header, suitable for hashing
     * </pre>
     *
     * <code>required bytes header = 1;</code>
     * @return The header.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getHeader() {
      return header_;
    }

    public static final int BODY_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString body_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * Payload data
     * </pre>
     *
     * <code>required bytes body = 2;</code>
     * @return Whether the body field is set.
     */
    @java.lang.Override
    public boolean hasBody() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Payload data
     * </pre>
     *
     * <code>required bytes body = 2;</code>
     * @return The body.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getBody() {
      return body_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasHeader()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (!hasBody()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeBytes(1, header_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeBytes(2, body_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, header_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, body_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal)) {
        return super.equals(obj);
      }
      com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal other = (com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal) obj;

      if (hasHeader() != other.hasHeader()) return false;
      if (hasHeader()) {
        if (!getHeader()
            .equals(other.getHeader())) return false;
      }
      if (hasBody() != other.hasBody()) return false;
      if (hasBody()) {
        if (!getBody()
            .equals(other.getBody())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasHeader()) {
        hash = (37 * hash) + HEADER_FIELD_NUMBER;
        hash = (53 * hash) + getHeader().hashCode();
      }
      if (hasBody()) {
        hash = (37 * hash) + BODY_FIELD_NUMBER;
        hash = (53 * hash) + getBody().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Must be kept wire-format compatible with HeaderAndBody. Provides the
     * SecureMessage code with a consistent wire-format representation that
     * remains stable irrespective of protobuf implementation choices. This
     * low-level representation of a HeaderAndBody should not be used by
     * any code outside of the SecureMessage library implementation/tests.
     * </pre>
     *
     * Protobuf type {@code securemessage.HeaderAndBodyInternal}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:securemessage.HeaderAndBodyInternal)
        com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternalOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_HeaderAndBodyInternal_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_HeaderAndBodyInternal_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal.class, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal.Builder.class);
      }

      // Construct using com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        header_ = com.google.protobuf.ByteString.EMPTY;
        body_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_HeaderAndBodyInternal_descriptor;
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal getDefaultInstanceForType() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal build() {
        com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal buildPartial() {
        com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal result = new com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.header_ = header_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.body_ = body_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal) {
          return mergeFrom((com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal other) {
        if (other == com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal.getDefaultInstance()) return this;
        if (other.hasHeader()) {
          setHeader(other.getHeader());
        }
        if (other.hasBody()) {
          setBody(other.getBody());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasHeader()) {
          return false;
        }
        if (!hasBody()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                header_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                body_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString header_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * A raw (wire-format) byte encoding of a Header, suitable for hashing
       * </pre>
       *
       * <code>required bytes header = 1;</code>
       * @return Whether the header field is set.
       */
      @java.lang.Override
      public boolean hasHeader() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * A raw (wire-format) byte encoding of a Header, suitable for hashing
       * </pre>
       *
       * <code>required bytes header = 1;</code>
       * @return The header.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getHeader() {
        return header_;
      }
      /**
       * <pre>
       * A raw (wire-format) byte encoding of a Header, suitable for hashing
       * </pre>
       *
       * <code>required bytes header = 1;</code>
       * @param value The header to set.
       * @return This builder for chaining.
       */
      public Builder setHeader(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        header_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A raw (wire-format) byte encoding of a Header, suitable for hashing
       * </pre>
       *
       * <code>required bytes header = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearHeader() {
        bitField0_ = (bitField0_ & ~0x00000001);
        header_ = getDefaultInstance().getHeader();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString body_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Payload data
       * </pre>
       *
       * <code>required bytes body = 2;</code>
       * @return Whether the body field is set.
       */
      @java.lang.Override
      public boolean hasBody() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Payload data
       * </pre>
       *
       * <code>required bytes body = 2;</code>
       * @return The body.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getBody() {
        return body_;
      }
      /**
       * <pre>
       * Payload data
       * </pre>
       *
       * <code>required bytes body = 2;</code>
       * @param value The body to set.
       * @return This builder for chaining.
       */
      public Builder setBody(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        body_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Payload data
       * </pre>
       *
       * <code>required bytes body = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearBody() {
        bitField0_ = (bitField0_ & ~0x00000002);
        body_ = getDefaultInstance().getBody();
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:securemessage.HeaderAndBodyInternal)
    }

    // @@protoc_insertion_point(class_scope:securemessage.HeaderAndBodyInternal)
    private static final com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal();
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<HeaderAndBodyInternal>
        PARSER = new com.google.protobuf.AbstractParser<HeaderAndBodyInternal>() {
      @java.lang.Override
      public HeaderAndBodyInternal parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<HeaderAndBodyInternal> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<HeaderAndBodyInternal> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.HeaderAndBodyInternal getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface EcP256PublicKeyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:securemessage.EcP256PublicKey)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * x and y are encoded in big-endian two's complement (slightly wasteful)
     * Client MUST verify (x,y) is a valid point on NIST P256
     * </pre>
     *
     * <code>required bytes x = 1;</code>
     * @return Whether the x field is set.
     */
    boolean hasX();
    /**
     * <pre>
     * x and y are encoded in big-endian two's complement (slightly wasteful)
     * Client MUST verify (x,y) is a valid point on NIST P256
     * </pre>
     *
     * <code>required bytes x = 1;</code>
     * @return The x.
     */
    com.google.protobuf.ByteString getX();

    /**
     * <code>required bytes y = 2;</code>
     * @return Whether the y field is set.
     */
    boolean hasY();
    /**
     * <code>required bytes y = 2;</code>
     * @return The y.
     */
    com.google.protobuf.ByteString getY();
  }
  /**
   * <pre>
   * A convenience proto for encoding NIST P-256 elliptic curve public keys
   * </pre>
   *
   * Protobuf type {@code securemessage.EcP256PublicKey}
   */
  public static final class EcP256PublicKey extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:securemessage.EcP256PublicKey)
      EcP256PublicKeyOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        EcP256PublicKey.class.getName());
    }
    // Use EcP256PublicKey.newBuilder() to construct.
    private EcP256PublicKey(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private EcP256PublicKey() {
      x_ = com.google.protobuf.ByteString.EMPTY;
      y_ = com.google.protobuf.ByteString.EMPTY;
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_EcP256PublicKey_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_EcP256PublicKey_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey.class, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey.Builder.class);
    }

    private int bitField0_;
    public static final int X_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString x_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * x and y are encoded in big-endian two's complement (slightly wasteful)
     * Client MUST verify (x,y) is a valid point on NIST P256
     * </pre>
     *
     * <code>required bytes x = 1;</code>
     * @return Whether the x field is set.
     */
    @java.lang.Override
    public boolean hasX() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * x and y are encoded in big-endian two's complement (slightly wasteful)
     * Client MUST verify (x,y) is a valid point on NIST P256
     * </pre>
     *
     * <code>required bytes x = 1;</code>
     * @return The x.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getX() {
      return x_;
    }

    public static final int Y_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString y_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <code>required bytes y = 2;</code>
     * @return Whether the y field is set.
     */
    @java.lang.Override
    public boolean hasY() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>required bytes y = 2;</code>
     * @return The y.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getY() {
      return y_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasX()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (!hasY()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeBytes(1, x_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeBytes(2, y_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, x_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, y_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey)) {
        return super.equals(obj);
      }
      com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey other = (com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey) obj;

      if (hasX() != other.hasX()) return false;
      if (hasX()) {
        if (!getX()
            .equals(other.getX())) return false;
      }
      if (hasY() != other.hasY()) return false;
      if (hasY()) {
        if (!getY()
            .equals(other.getY())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasX()) {
        hash = (37 * hash) + X_FIELD_NUMBER;
        hash = (53 * hash) + getX().hashCode();
      }
      if (hasY()) {
        hash = (37 * hash) + Y_FIELD_NUMBER;
        hash = (53 * hash) + getY().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * A convenience proto for encoding NIST P-256 elliptic curve public keys
     * </pre>
     *
     * Protobuf type {@code securemessage.EcP256PublicKey}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:securemessage.EcP256PublicKey)
        com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKeyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_EcP256PublicKey_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_EcP256PublicKey_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey.class, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey.Builder.class);
      }

      // Construct using com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        x_ = com.google.protobuf.ByteString.EMPTY;
        y_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_EcP256PublicKey_descriptor;
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey getDefaultInstanceForType() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey build() {
        com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey buildPartial() {
        com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey result = new com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.x_ = x_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.y_ = y_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey) {
          return mergeFrom((com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey other) {
        if (other == com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey.getDefaultInstance()) return this;
        if (other.hasX()) {
          setX(other.getX());
        }
        if (other.hasY()) {
          setY(other.getY());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasX()) {
          return false;
        }
        if (!hasY()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                x_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                y_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString x_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * x and y are encoded in big-endian two's complement (slightly wasteful)
       * Client MUST verify (x,y) is a valid point on NIST P256
       * </pre>
       *
       * <code>required bytes x = 1;</code>
       * @return Whether the x field is set.
       */
      @java.lang.Override
      public boolean hasX() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * x and y are encoded in big-endian two's complement (slightly wasteful)
       * Client MUST verify (x,y) is a valid point on NIST P256
       * </pre>
       *
       * <code>required bytes x = 1;</code>
       * @return The x.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getX() {
        return x_;
      }
      /**
       * <pre>
       * x and y are encoded in big-endian two's complement (slightly wasteful)
       * Client MUST verify (x,y) is a valid point on NIST P256
       * </pre>
       *
       * <code>required bytes x = 1;</code>
       * @param value The x to set.
       * @return This builder for chaining.
       */
      public Builder setX(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        x_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * x and y are encoded in big-endian two's complement (slightly wasteful)
       * Client MUST verify (x,y) is a valid point on NIST P256
       * </pre>
       *
       * <code>required bytes x = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearX() {
        bitField0_ = (bitField0_ & ~0x00000001);
        x_ = getDefaultInstance().getX();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString y_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <code>required bytes y = 2;</code>
       * @return Whether the y field is set.
       */
      @java.lang.Override
      public boolean hasY() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>required bytes y = 2;</code>
       * @return The y.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getY() {
        return y_;
      }
      /**
       * <code>required bytes y = 2;</code>
       * @param value The y to set.
       * @return This builder for chaining.
       */
      public Builder setY(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        y_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>required bytes y = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearY() {
        bitField0_ = (bitField0_ & ~0x00000002);
        y_ = getDefaultInstance().getY();
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:securemessage.EcP256PublicKey)
    }

    // @@protoc_insertion_point(class_scope:securemessage.EcP256PublicKey)
    private static final com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey();
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<EcP256PublicKey>
        PARSER = new com.google.protobuf.AbstractParser<EcP256PublicKey>() {
      @java.lang.Override
      public EcP256PublicKey parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<EcP256PublicKey> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<EcP256PublicKey> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SimpleRsaPublicKeyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:securemessage.SimpleRsaPublicKey)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Encoded in big-endian two's complement
     * </pre>
     *
     * <code>required bytes n = 1;</code>
     * @return Whether the n field is set.
     */
    boolean hasN();
    /**
     * <pre>
     * Encoded in big-endian two's complement
     * </pre>
     *
     * <code>required bytes n = 1;</code>
     * @return The n.
     */
    com.google.protobuf.ByteString getN();

    /**
     * <code>optional int32 e = 2 [default = 65537];</code>
     * @return Whether the e field is set.
     */
    boolean hasE();
    /**
     * <code>optional int32 e = 2 [default = 65537];</code>
     * @return The e.
     */
    int getE();
  }
  /**
   * <pre>
   * A convenience proto for encoding RSA public keys with small exponents
   * </pre>
   *
   * Protobuf type {@code securemessage.SimpleRsaPublicKey}
   */
  public static final class SimpleRsaPublicKey extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:securemessage.SimpleRsaPublicKey)
      SimpleRsaPublicKeyOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        SimpleRsaPublicKey.class.getName());
    }
    // Use SimpleRsaPublicKey.newBuilder() to construct.
    private SimpleRsaPublicKey(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private SimpleRsaPublicKey() {
      n_ = com.google.protobuf.ByteString.EMPTY;
      e_ = 65537;
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_SimpleRsaPublicKey_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_SimpleRsaPublicKey_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey.class, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey.Builder.class);
    }

    private int bitField0_;
    public static final int N_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString n_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * Encoded in big-endian two's complement
     * </pre>
     *
     * <code>required bytes n = 1;</code>
     * @return Whether the n field is set.
     */
    @java.lang.Override
    public boolean hasN() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Encoded in big-endian two's complement
     * </pre>
     *
     * <code>required bytes n = 1;</code>
     * @return The n.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getN() {
      return n_;
    }

    public static final int E_FIELD_NUMBER = 2;
    private int e_ = 65537;
    /**
     * <code>optional int32 e = 2 [default = 65537];</code>
     * @return Whether the e field is set.
     */
    @java.lang.Override
    public boolean hasE() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional int32 e = 2 [default = 65537];</code>
     * @return The e.
     */
    @java.lang.Override
    public int getE() {
      return e_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasN()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeBytes(1, n_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt32(2, e_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, n_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, e_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey)) {
        return super.equals(obj);
      }
      com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey other = (com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey) obj;

      if (hasN() != other.hasN()) return false;
      if (hasN()) {
        if (!getN()
            .equals(other.getN())) return false;
      }
      if (hasE() != other.hasE()) return false;
      if (hasE()) {
        if (getE()
            != other.getE()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasN()) {
        hash = (37 * hash) + N_FIELD_NUMBER;
        hash = (53 * hash) + getN().hashCode();
      }
      if (hasE()) {
        hash = (37 * hash) + E_FIELD_NUMBER;
        hash = (53 * hash) + getE();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * A convenience proto for encoding RSA public keys with small exponents
     * </pre>
     *
     * Protobuf type {@code securemessage.SimpleRsaPublicKey}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:securemessage.SimpleRsaPublicKey)
        com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKeyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_SimpleRsaPublicKey_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_SimpleRsaPublicKey_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey.class, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey.Builder.class);
      }

      // Construct using com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        n_ = com.google.protobuf.ByteString.EMPTY;
        e_ = 65537;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_SimpleRsaPublicKey_descriptor;
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey getDefaultInstanceForType() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey build() {
        com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey buildPartial() {
        com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey result = new com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.n_ = n_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.e_ = e_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey) {
          return mergeFrom((com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey other) {
        if (other == com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey.getDefaultInstance()) return this;
        if (other.hasN()) {
          setN(other.getN());
        }
        if (other.hasE()) {
          setE(other.getE());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasN()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                n_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 16: {
                e_ = input.readInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString n_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Encoded in big-endian two's complement
       * </pre>
       *
       * <code>required bytes n = 1;</code>
       * @return Whether the n field is set.
       */
      @java.lang.Override
      public boolean hasN() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Encoded in big-endian two's complement
       * </pre>
       *
       * <code>required bytes n = 1;</code>
       * @return The n.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getN() {
        return n_;
      }
      /**
       * <pre>
       * Encoded in big-endian two's complement
       * </pre>
       *
       * <code>required bytes n = 1;</code>
       * @param value The n to set.
       * @return This builder for chaining.
       */
      public Builder setN(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        n_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Encoded in big-endian two's complement
       * </pre>
       *
       * <code>required bytes n = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearN() {
        bitField0_ = (bitField0_ & ~0x00000001);
        n_ = getDefaultInstance().getN();
        onChanged();
        return this;
      }

      private int e_ = 65537;
      /**
       * <code>optional int32 e = 2 [default = 65537];</code>
       * @return Whether the e field is set.
       */
      @java.lang.Override
      public boolean hasE() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional int32 e = 2 [default = 65537];</code>
       * @return The e.
       */
      @java.lang.Override
      public int getE() {
        return e_;
      }
      /**
       * <code>optional int32 e = 2 [default = 65537];</code>
       * @param value The e to set.
       * @return This builder for chaining.
       */
      public Builder setE(int value) {

        e_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 e = 2 [default = 65537];</code>
       * @return This builder for chaining.
       */
      public Builder clearE() {
        bitField0_ = (bitField0_ & ~0x00000002);
        e_ = 65537;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:securemessage.SimpleRsaPublicKey)
    }

    // @@protoc_insertion_point(class_scope:securemessage.SimpleRsaPublicKey)
    private static final com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey();
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SimpleRsaPublicKey>
        PARSER = new com.google.protobuf.AbstractParser<SimpleRsaPublicKey>() {
      @java.lang.Override
      public SimpleRsaPublicKey parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<SimpleRsaPublicKey> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SimpleRsaPublicKey> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DhPublicKeyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:securemessage.DhPublicKey)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Big-endian two's complement encoded group element
     * </pre>
     *
     * <code>required bytes y = 1;</code>
     * @return Whether the y field is set.
     */
    boolean hasY();
    /**
     * <pre>
     * Big-endian two's complement encoded group element
     * </pre>
     *
     * <code>required bytes y = 1;</code>
     * @return The y.
     */
    com.google.protobuf.ByteString getY();
  }
  /**
   * <pre>
   * A convenience proto for encoding Diffie-Hellman public keys,
   * for use only when Elliptic Curve based key exchanges are not possible.
   * (Note that the group parameters must be specified separately)
   * </pre>
   *
   * Protobuf type {@code securemessage.DhPublicKey}
   */
  public static final class DhPublicKey extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:securemessage.DhPublicKey)
      DhPublicKeyOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        DhPublicKey.class.getName());
    }
    // Use DhPublicKey.newBuilder() to construct.
    private DhPublicKey(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private DhPublicKey() {
      y_ = com.google.protobuf.ByteString.EMPTY;
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_DhPublicKey_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_DhPublicKey_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey.class, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey.Builder.class);
    }

    private int bitField0_;
    public static final int Y_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString y_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * Big-endian two's complement encoded group element
     * </pre>
     *
     * <code>required bytes y = 1;</code>
     * @return Whether the y field is set.
     */
    @java.lang.Override
    public boolean hasY() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Big-endian two's complement encoded group element
     * </pre>
     *
     * <code>required bytes y = 1;</code>
     * @return The y.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getY() {
      return y_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasY()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeBytes(1, y_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, y_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey)) {
        return super.equals(obj);
      }
      com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey other = (com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey) obj;

      if (hasY() != other.hasY()) return false;
      if (hasY()) {
        if (!getY()
            .equals(other.getY())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasY()) {
        hash = (37 * hash) + Y_FIELD_NUMBER;
        hash = (53 * hash) + getY().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * A convenience proto for encoding Diffie-Hellman public keys,
     * for use only when Elliptic Curve based key exchanges are not possible.
     * (Note that the group parameters must be specified separately)
     * </pre>
     *
     * Protobuf type {@code securemessage.DhPublicKey}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:securemessage.DhPublicKey)
        com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKeyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_DhPublicKey_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_DhPublicKey_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey.class, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey.Builder.class);
      }

      // Construct using com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        y_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_DhPublicKey_descriptor;
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey getDefaultInstanceForType() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey build() {
        com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey buildPartial() {
        com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey result = new com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.y_ = y_;
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey) {
          return mergeFrom((com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey other) {
        if (other == com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey.getDefaultInstance()) return this;
        if (other.hasY()) {
          setY(other.getY());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasY()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                y_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString y_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Big-endian two's complement encoded group element
       * </pre>
       *
       * <code>required bytes y = 1;</code>
       * @return Whether the y field is set.
       */
      @java.lang.Override
      public boolean hasY() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Big-endian two's complement encoded group element
       * </pre>
       *
       * <code>required bytes y = 1;</code>
       * @return The y.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getY() {
        return y_;
      }
      /**
       * <pre>
       * Big-endian two's complement encoded group element
       * </pre>
       *
       * <code>required bytes y = 1;</code>
       * @param value The y to set.
       * @return This builder for chaining.
       */
      public Builder setY(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        y_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Big-endian two's complement encoded group element
       * </pre>
       *
       * <code>required bytes y = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearY() {
        bitField0_ = (bitField0_ & ~0x00000001);
        y_ = getDefaultInstance().getY();
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:securemessage.DhPublicKey)
    }

    // @@protoc_insertion_point(class_scope:securemessage.DhPublicKey)
    private static final com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey();
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DhPublicKey>
        PARSER = new com.google.protobuf.AbstractParser<DhPublicKey>() {
      @java.lang.Override
      public DhPublicKey parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<DhPublicKey> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DhPublicKey> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface GenericPublicKeyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:securemessage.GenericPublicKey)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>required .securemessage.PublicKeyType type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <code>required .securemessage.PublicKeyType type = 1;</code>
     * @return The type.
     */
    com.google.security.cryptauth.lib.securemessage.SecureMessageProto.PublicKeyType getType();

    /**
     * <code>optional .securemessage.EcP256PublicKey ec_p256_public_key = 2;</code>
     * @return Whether the ecP256PublicKey field is set.
     */
    boolean hasEcP256PublicKey();
    /**
     * <code>optional .securemessage.EcP256PublicKey ec_p256_public_key = 2;</code>
     * @return The ecP256PublicKey.
     */
    com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey getEcP256PublicKey();
    /**
     * <code>optional .securemessage.EcP256PublicKey ec_p256_public_key = 2;</code>
     */
    com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKeyOrBuilder getEcP256PublicKeyOrBuilder();

    /**
     * <code>optional .securemessage.SimpleRsaPublicKey rsa2048_public_key = 3;</code>
     * @return Whether the rsa2048PublicKey field is set.
     */
    boolean hasRsa2048PublicKey();
    /**
     * <code>optional .securemessage.SimpleRsaPublicKey rsa2048_public_key = 3;</code>
     * @return The rsa2048PublicKey.
     */
    com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey getRsa2048PublicKey();
    /**
     * <code>optional .securemessage.SimpleRsaPublicKey rsa2048_public_key = 3;</code>
     */
    com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKeyOrBuilder getRsa2048PublicKeyOrBuilder();

    /**
     * <pre>
     * Use only as a last resort
     * </pre>
     *
     * <code>optional .securemessage.DhPublicKey dh2048_public_key = 4;</code>
     * @return Whether the dh2048PublicKey field is set.
     */
    boolean hasDh2048PublicKey();
    /**
     * <pre>
     * Use only as a last resort
     * </pre>
     *
     * <code>optional .securemessage.DhPublicKey dh2048_public_key = 4;</code>
     * @return The dh2048PublicKey.
     */
    com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey getDh2048PublicKey();
    /**
     * <pre>
     * Use only as a last resort
     * </pre>
     *
     * <code>optional .securemessage.DhPublicKey dh2048_public_key = 4;</code>
     */
    com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKeyOrBuilder getDh2048PublicKeyOrBuilder();
  }
  /**
   * Protobuf type {@code securemessage.GenericPublicKey}
   */
  public static final class GenericPublicKey extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:securemessage.GenericPublicKey)
      GenericPublicKeyOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        GenericPublicKey.class.getName());
    }
    // Use GenericPublicKey.newBuilder() to construct.
    private GenericPublicKey(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private GenericPublicKey() {
      type_ = 1;
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_GenericPublicKey_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_GenericPublicKey_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey.class, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey.Builder.class);
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private int type_ = 1;
    /**
     * <code>required .securemessage.PublicKeyType type = 1;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>required .securemessage.PublicKeyType type = 1;</code>
     * @return The type.
     */
    @java.lang.Override public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.PublicKeyType getType() {
      com.google.security.cryptauth.lib.securemessage.SecureMessageProto.PublicKeyType result = com.google.security.cryptauth.lib.securemessage.SecureMessageProto.PublicKeyType.forNumber(type_);
      return result == null ? com.google.security.cryptauth.lib.securemessage.SecureMessageProto.PublicKeyType.EC_P256 : result;
    }

    public static final int EC_P256_PUBLIC_KEY_FIELD_NUMBER = 2;
    private com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey ecP256PublicKey_;
    /**
     * <code>optional .securemessage.EcP256PublicKey ec_p256_public_key = 2;</code>
     * @return Whether the ecP256PublicKey field is set.
     */
    @java.lang.Override
    public boolean hasEcP256PublicKey() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional .securemessage.EcP256PublicKey ec_p256_public_key = 2;</code>
     * @return The ecP256PublicKey.
     */
    @java.lang.Override
    public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey getEcP256PublicKey() {
      return ecP256PublicKey_ == null ? com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey.getDefaultInstance() : ecP256PublicKey_;
    }
    /**
     * <code>optional .securemessage.EcP256PublicKey ec_p256_public_key = 2;</code>
     */
    @java.lang.Override
    public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKeyOrBuilder getEcP256PublicKeyOrBuilder() {
      return ecP256PublicKey_ == null ? com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey.getDefaultInstance() : ecP256PublicKey_;
    }

    public static final int RSA2048_PUBLIC_KEY_FIELD_NUMBER = 3;
    private com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey rsa2048PublicKey_;
    /**
     * <code>optional .securemessage.SimpleRsaPublicKey rsa2048_public_key = 3;</code>
     * @return Whether the rsa2048PublicKey field is set.
     */
    @java.lang.Override
    public boolean hasRsa2048PublicKey() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional .securemessage.SimpleRsaPublicKey rsa2048_public_key = 3;</code>
     * @return The rsa2048PublicKey.
     */
    @java.lang.Override
    public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey getRsa2048PublicKey() {
      return rsa2048PublicKey_ == null ? com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey.getDefaultInstance() : rsa2048PublicKey_;
    }
    /**
     * <code>optional .securemessage.SimpleRsaPublicKey rsa2048_public_key = 3;</code>
     */
    @java.lang.Override
    public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKeyOrBuilder getRsa2048PublicKeyOrBuilder() {
      return rsa2048PublicKey_ == null ? com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey.getDefaultInstance() : rsa2048PublicKey_;
    }

    public static final int DH2048_PUBLIC_KEY_FIELD_NUMBER = 4;
    private com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey dh2048PublicKey_;
    /**
     * <pre>
     * Use only as a last resort
     * </pre>
     *
     * <code>optional .securemessage.DhPublicKey dh2048_public_key = 4;</code>
     * @return Whether the dh2048PublicKey field is set.
     */
    @java.lang.Override
    public boolean hasDh2048PublicKey() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Use only as a last resort
     * </pre>
     *
     * <code>optional .securemessage.DhPublicKey dh2048_public_key = 4;</code>
     * @return The dh2048PublicKey.
     */
    @java.lang.Override
    public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey getDh2048PublicKey() {
      return dh2048PublicKey_ == null ? com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey.getDefaultInstance() : dh2048PublicKey_;
    }
    /**
     * <pre>
     * Use only as a last resort
     * </pre>
     *
     * <code>optional .securemessage.DhPublicKey dh2048_public_key = 4;</code>
     */
    @java.lang.Override
    public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKeyOrBuilder getDh2048PublicKeyOrBuilder() {
      return dh2048PublicKey_ == null ? com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey.getDefaultInstance() : dh2048PublicKey_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasType()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (hasEcP256PublicKey()) {
        if (!getEcP256PublicKey().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasRsa2048PublicKey()) {
        if (!getRsa2048PublicKey().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasDh2048PublicKey()) {
        if (!getDh2048PublicKey().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeEnum(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getEcP256PublicKey());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(3, getRsa2048PublicKey());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeMessage(4, getDh2048PublicKey());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getEcP256PublicKey());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getRsa2048PublicKey());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getDh2048PublicKey());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey)) {
        return super.equals(obj);
      }
      com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey other = (com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey) obj;

      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (type_ != other.type_) return false;
      }
      if (hasEcP256PublicKey() != other.hasEcP256PublicKey()) return false;
      if (hasEcP256PublicKey()) {
        if (!getEcP256PublicKey()
            .equals(other.getEcP256PublicKey())) return false;
      }
      if (hasRsa2048PublicKey() != other.hasRsa2048PublicKey()) return false;
      if (hasRsa2048PublicKey()) {
        if (!getRsa2048PublicKey()
            .equals(other.getRsa2048PublicKey())) return false;
      }
      if (hasDh2048PublicKey() != other.hasDh2048PublicKey()) return false;
      if (hasDh2048PublicKey()) {
        if (!getDh2048PublicKey()
            .equals(other.getDh2048PublicKey())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + type_;
      }
      if (hasEcP256PublicKey()) {
        hash = (37 * hash) + EC_P256_PUBLIC_KEY_FIELD_NUMBER;
        hash = (53 * hash) + getEcP256PublicKey().hashCode();
      }
      if (hasRsa2048PublicKey()) {
        hash = (37 * hash) + RSA2048_PUBLIC_KEY_FIELD_NUMBER;
        hash = (53 * hash) + getRsa2048PublicKey().hashCode();
      }
      if (hasDh2048PublicKey()) {
        hash = (37 * hash) + DH2048_PUBLIC_KEY_FIELD_NUMBER;
        hash = (53 * hash) + getDh2048PublicKey().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code securemessage.GenericPublicKey}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:securemessage.GenericPublicKey)
        com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKeyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_GenericPublicKey_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_GenericPublicKey_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey.class, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey.Builder.class);
      }

      // Construct using com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getEcP256PublicKeyFieldBuilder();
          getRsa2048PublicKeyFieldBuilder();
          getDh2048PublicKeyFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        type_ = 1;
        ecP256PublicKey_ = null;
        if (ecP256PublicKeyBuilder_ != null) {
          ecP256PublicKeyBuilder_.dispose();
          ecP256PublicKeyBuilder_ = null;
        }
        rsa2048PublicKey_ = null;
        if (rsa2048PublicKeyBuilder_ != null) {
          rsa2048PublicKeyBuilder_.dispose();
          rsa2048PublicKeyBuilder_ = null;
        }
        dh2048PublicKey_ = null;
        if (dh2048PublicKeyBuilder_ != null) {
          dh2048PublicKeyBuilder_.dispose();
          dh2048PublicKeyBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.internal_static_securemessage_GenericPublicKey_descriptor;
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey getDefaultInstanceForType() {
        return com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey build() {
        com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey buildPartial() {
        com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey result = new com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.type_ = type_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.ecP256PublicKey_ = ecP256PublicKeyBuilder_ == null
              ? ecP256PublicKey_
              : ecP256PublicKeyBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.rsa2048PublicKey_ = rsa2048PublicKeyBuilder_ == null
              ? rsa2048PublicKey_
              : rsa2048PublicKeyBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.dh2048PublicKey_ = dh2048PublicKeyBuilder_ == null
              ? dh2048PublicKey_
              : dh2048PublicKeyBuilder_.build();
          to_bitField0_ |= 0x00000008;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey) {
          return mergeFrom((com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey other) {
        if (other == com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey.getDefaultInstance()) return this;
        if (other.hasType()) {
          setType(other.getType());
        }
        if (other.hasEcP256PublicKey()) {
          mergeEcP256PublicKey(other.getEcP256PublicKey());
        }
        if (other.hasRsa2048PublicKey()) {
          mergeRsa2048PublicKey(other.getRsa2048PublicKey());
        }
        if (other.hasDh2048PublicKey()) {
          mergeDh2048PublicKey(other.getDh2048PublicKey());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasType()) {
          return false;
        }
        if (hasEcP256PublicKey()) {
          if (!getEcP256PublicKey().isInitialized()) {
            return false;
          }
        }
        if (hasRsa2048PublicKey()) {
          if (!getRsa2048PublicKey().isInitialized()) {
            return false;
          }
        }
        if (hasDh2048PublicKey()) {
          if (!getDh2048PublicKey().isInitialized()) {
            return false;
          }
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                int tmpRaw = input.readEnum();
                com.google.security.cryptauth.lib.securemessage.SecureMessageProto.PublicKeyType tmpValue =
                    com.google.security.cryptauth.lib.securemessage.SecureMessageProto.PublicKeyType.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(1, tmpRaw);
                } else {
                  type_ = tmpRaw;
                  bitField0_ |= 0x00000001;
                }
                break;
              } // case 8
              case 18: {
                input.readMessage(
                    getEcP256PublicKeyFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getRsa2048PublicKeyFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                input.readMessage(
                    getDh2048PublicKeyFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int type_ = 1;
      /**
       * <code>required .securemessage.PublicKeyType type = 1;</code>
       * @return Whether the type field is set.
       */
      @java.lang.Override public boolean hasType() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>required .securemessage.PublicKeyType type = 1;</code>
       * @return The type.
       */
      @java.lang.Override
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.PublicKeyType getType() {
        com.google.security.cryptauth.lib.securemessage.SecureMessageProto.PublicKeyType result = com.google.security.cryptauth.lib.securemessage.SecureMessageProto.PublicKeyType.forNumber(type_);
        return result == null ? com.google.security.cryptauth.lib.securemessage.SecureMessageProto.PublicKeyType.EC_P256 : result;
      }
      /**
       * <code>required .securemessage.PublicKeyType type = 1;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.PublicKeyType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        type_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>required .securemessage.PublicKeyType type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000001);
        type_ = 1;
        onChanged();
        return this;
      }

      private com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey ecP256PublicKey_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey.Builder, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKeyOrBuilder> ecP256PublicKeyBuilder_;
      /**
       * <code>optional .securemessage.EcP256PublicKey ec_p256_public_key = 2;</code>
       * @return Whether the ecP256PublicKey field is set.
       */
      public boolean hasEcP256PublicKey() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional .securemessage.EcP256PublicKey ec_p256_public_key = 2;</code>
       * @return The ecP256PublicKey.
       */
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey getEcP256PublicKey() {
        if (ecP256PublicKeyBuilder_ == null) {
          return ecP256PublicKey_ == null ? com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey.getDefaultInstance() : ecP256PublicKey_;
        } else {
          return ecP256PublicKeyBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .securemessage.EcP256PublicKey ec_p256_public_key = 2;</code>
       */
      public Builder setEcP256PublicKey(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey value) {
        if (ecP256PublicKeyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ecP256PublicKey_ = value;
        } else {
          ecP256PublicKeyBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>optional .securemessage.EcP256PublicKey ec_p256_public_key = 2;</code>
       */
      public Builder setEcP256PublicKey(
          com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey.Builder builderForValue) {
        if (ecP256PublicKeyBuilder_ == null) {
          ecP256PublicKey_ = builderForValue.build();
        } else {
          ecP256PublicKeyBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>optional .securemessage.EcP256PublicKey ec_p256_public_key = 2;</code>
       */
      public Builder mergeEcP256PublicKey(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey value) {
        if (ecP256PublicKeyBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            ecP256PublicKey_ != null &&
            ecP256PublicKey_ != com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey.getDefaultInstance()) {
            getEcP256PublicKeyBuilder().mergeFrom(value);
          } else {
            ecP256PublicKey_ = value;
          }
        } else {
          ecP256PublicKeyBuilder_.mergeFrom(value);
        }
        if (ecP256PublicKey_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <code>optional .securemessage.EcP256PublicKey ec_p256_public_key = 2;</code>
       */
      public Builder clearEcP256PublicKey() {
        bitField0_ = (bitField0_ & ~0x00000002);
        ecP256PublicKey_ = null;
        if (ecP256PublicKeyBuilder_ != null) {
          ecP256PublicKeyBuilder_.dispose();
          ecP256PublicKeyBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .securemessage.EcP256PublicKey ec_p256_public_key = 2;</code>
       */
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey.Builder getEcP256PublicKeyBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getEcP256PublicKeyFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .securemessage.EcP256PublicKey ec_p256_public_key = 2;</code>
       */
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKeyOrBuilder getEcP256PublicKeyOrBuilder() {
        if (ecP256PublicKeyBuilder_ != null) {
          return ecP256PublicKeyBuilder_.getMessageOrBuilder();
        } else {
          return ecP256PublicKey_ == null ?
              com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey.getDefaultInstance() : ecP256PublicKey_;
        }
      }
      /**
       * <code>optional .securemessage.EcP256PublicKey ec_p256_public_key = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey.Builder, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKeyOrBuilder> 
          getEcP256PublicKeyFieldBuilder() {
        if (ecP256PublicKeyBuilder_ == null) {
          ecP256PublicKeyBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKey.Builder, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.EcP256PublicKeyOrBuilder>(
                  getEcP256PublicKey(),
                  getParentForChildren(),
                  isClean());
          ecP256PublicKey_ = null;
        }
        return ecP256PublicKeyBuilder_;
      }

      private com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey rsa2048PublicKey_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey.Builder, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKeyOrBuilder> rsa2048PublicKeyBuilder_;
      /**
       * <code>optional .securemessage.SimpleRsaPublicKey rsa2048_public_key = 3;</code>
       * @return Whether the rsa2048PublicKey field is set.
       */
      public boolean hasRsa2048PublicKey() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <code>optional .securemessage.SimpleRsaPublicKey rsa2048_public_key = 3;</code>
       * @return The rsa2048PublicKey.
       */
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey getRsa2048PublicKey() {
        if (rsa2048PublicKeyBuilder_ == null) {
          return rsa2048PublicKey_ == null ? com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey.getDefaultInstance() : rsa2048PublicKey_;
        } else {
          return rsa2048PublicKeyBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .securemessage.SimpleRsaPublicKey rsa2048_public_key = 3;</code>
       */
      public Builder setRsa2048PublicKey(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey value) {
        if (rsa2048PublicKeyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          rsa2048PublicKey_ = value;
        } else {
          rsa2048PublicKeyBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <code>optional .securemessage.SimpleRsaPublicKey rsa2048_public_key = 3;</code>
       */
      public Builder setRsa2048PublicKey(
          com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey.Builder builderForValue) {
        if (rsa2048PublicKeyBuilder_ == null) {
          rsa2048PublicKey_ = builderForValue.build();
        } else {
          rsa2048PublicKeyBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <code>optional .securemessage.SimpleRsaPublicKey rsa2048_public_key = 3;</code>
       */
      public Builder mergeRsa2048PublicKey(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey value) {
        if (rsa2048PublicKeyBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            rsa2048PublicKey_ != null &&
            rsa2048PublicKey_ != com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey.getDefaultInstance()) {
            getRsa2048PublicKeyBuilder().mergeFrom(value);
          } else {
            rsa2048PublicKey_ = value;
          }
        } else {
          rsa2048PublicKeyBuilder_.mergeFrom(value);
        }
        if (rsa2048PublicKey_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }
      /**
       * <code>optional .securemessage.SimpleRsaPublicKey rsa2048_public_key = 3;</code>
       */
      public Builder clearRsa2048PublicKey() {
        bitField0_ = (bitField0_ & ~0x00000004);
        rsa2048PublicKey_ = null;
        if (rsa2048PublicKeyBuilder_ != null) {
          rsa2048PublicKeyBuilder_.dispose();
          rsa2048PublicKeyBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .securemessage.SimpleRsaPublicKey rsa2048_public_key = 3;</code>
       */
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey.Builder getRsa2048PublicKeyBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getRsa2048PublicKeyFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .securemessage.SimpleRsaPublicKey rsa2048_public_key = 3;</code>
       */
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKeyOrBuilder getRsa2048PublicKeyOrBuilder() {
        if (rsa2048PublicKeyBuilder_ != null) {
          return rsa2048PublicKeyBuilder_.getMessageOrBuilder();
        } else {
          return rsa2048PublicKey_ == null ?
              com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey.getDefaultInstance() : rsa2048PublicKey_;
        }
      }
      /**
       * <code>optional .securemessage.SimpleRsaPublicKey rsa2048_public_key = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey.Builder, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKeyOrBuilder> 
          getRsa2048PublicKeyFieldBuilder() {
        if (rsa2048PublicKeyBuilder_ == null) {
          rsa2048PublicKeyBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKey.Builder, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.SimpleRsaPublicKeyOrBuilder>(
                  getRsa2048PublicKey(),
                  getParentForChildren(),
                  isClean());
          rsa2048PublicKey_ = null;
        }
        return rsa2048PublicKeyBuilder_;
      }

      private com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey dh2048PublicKey_;
      private com.google.protobuf.SingleFieldBuilder<
          com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey.Builder, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKeyOrBuilder> dh2048PublicKeyBuilder_;
      /**
       * <pre>
       * Use only as a last resort
       * </pre>
       *
       * <code>optional .securemessage.DhPublicKey dh2048_public_key = 4;</code>
       * @return Whether the dh2048PublicKey field is set.
       */
      public boolean hasDh2048PublicKey() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Use only as a last resort
       * </pre>
       *
       * <code>optional .securemessage.DhPublicKey dh2048_public_key = 4;</code>
       * @return The dh2048PublicKey.
       */
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey getDh2048PublicKey() {
        if (dh2048PublicKeyBuilder_ == null) {
          return dh2048PublicKey_ == null ? com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey.getDefaultInstance() : dh2048PublicKey_;
        } else {
          return dh2048PublicKeyBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Use only as a last resort
       * </pre>
       *
       * <code>optional .securemessage.DhPublicKey dh2048_public_key = 4;</code>
       */
      public Builder setDh2048PublicKey(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey value) {
        if (dh2048PublicKeyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          dh2048PublicKey_ = value;
        } else {
          dh2048PublicKeyBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Use only as a last resort
       * </pre>
       *
       * <code>optional .securemessage.DhPublicKey dh2048_public_key = 4;</code>
       */
      public Builder setDh2048PublicKey(
          com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey.Builder builderForValue) {
        if (dh2048PublicKeyBuilder_ == null) {
          dh2048PublicKey_ = builderForValue.build();
        } else {
          dh2048PublicKeyBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Use only as a last resort
       * </pre>
       *
       * <code>optional .securemessage.DhPublicKey dh2048_public_key = 4;</code>
       */
      public Builder mergeDh2048PublicKey(com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey value) {
        if (dh2048PublicKeyBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0) &&
            dh2048PublicKey_ != null &&
            dh2048PublicKey_ != com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey.getDefaultInstance()) {
            getDh2048PublicKeyBuilder().mergeFrom(value);
          } else {
            dh2048PublicKey_ = value;
          }
        } else {
          dh2048PublicKeyBuilder_.mergeFrom(value);
        }
        if (dh2048PublicKey_ != null) {
          bitField0_ |= 0x00000008;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Use only as a last resort
       * </pre>
       *
       * <code>optional .securemessage.DhPublicKey dh2048_public_key = 4;</code>
       */
      public Builder clearDh2048PublicKey() {
        bitField0_ = (bitField0_ & ~0x00000008);
        dh2048PublicKey_ = null;
        if (dh2048PublicKeyBuilder_ != null) {
          dh2048PublicKeyBuilder_.dispose();
          dh2048PublicKeyBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Use only as a last resort
       * </pre>
       *
       * <code>optional .securemessage.DhPublicKey dh2048_public_key = 4;</code>
       */
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey.Builder getDh2048PublicKeyBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getDh2048PublicKeyFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Use only as a last resort
       * </pre>
       *
       * <code>optional .securemessage.DhPublicKey dh2048_public_key = 4;</code>
       */
      public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKeyOrBuilder getDh2048PublicKeyOrBuilder() {
        if (dh2048PublicKeyBuilder_ != null) {
          return dh2048PublicKeyBuilder_.getMessageOrBuilder();
        } else {
          return dh2048PublicKey_ == null ?
              com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey.getDefaultInstance() : dh2048PublicKey_;
        }
      }
      /**
       * <pre>
       * Use only as a last resort
       * </pre>
       *
       * <code>optional .securemessage.DhPublicKey dh2048_public_key = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey.Builder, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKeyOrBuilder> 
          getDh2048PublicKeyFieldBuilder() {
        if (dh2048PublicKeyBuilder_ == null) {
          dh2048PublicKeyBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKey.Builder, com.google.security.cryptauth.lib.securemessage.SecureMessageProto.DhPublicKeyOrBuilder>(
                  getDh2048PublicKey(),
                  getParentForChildren(),
                  isClean());
          dh2048PublicKey_ = null;
        }
        return dh2048PublicKeyBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:securemessage.GenericPublicKey)
    }

    // @@protoc_insertion_point(class_scope:securemessage.GenericPublicKey)
    private static final com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey();
    }

    public static com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GenericPublicKey>
        PARSER = new com.google.protobuf.AbstractParser<GenericPublicKey>() {
      @java.lang.Override
      public GenericPublicKey parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<GenericPublicKey> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GenericPublicKey> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.security.cryptauth.lib.securemessage.SecureMessageProto.GenericPublicKey getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_securemessage_SecureMessage_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_securemessage_SecureMessage_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_securemessage_Header_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_securemessage_Header_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_securemessage_HeaderAndBody_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_securemessage_HeaderAndBody_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_securemessage_HeaderAndBodyInternal_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_securemessage_HeaderAndBodyInternal_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_securemessage_EcP256PublicKey_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_securemessage_EcP256PublicKey_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_securemessage_SimpleRsaPublicKey_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_securemessage_SimpleRsaPublicKey_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_securemessage_DhPublicKey_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_securemessage_DhPublicKey_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_securemessage_GenericPublicKey_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_securemessage_GenericPublicKey_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\023securemessage.proto\022\rsecuremessage\";\n\r" +
      "SecureMessage\022\027\n\017header_and_body\030\001 \002(\014\022\021" +
      "\n\tsignature\030\002 \002(\014\"\361\001\n\006Header\0222\n\020signatur" +
      "e_scheme\030\001 \002(\0162\030.securemessage.SigScheme" +
      "\0223\n\021encryption_scheme\030\002 \002(\0162\030.securemess" +
      "age.EncScheme\022\033\n\023verification_key_id\030\003 \001" +
      "(\014\022\031\n\021decryption_key_id\030\004 \001(\014\022\n\n\002iv\030\005 \001(" +
      "\014\022\027\n\017public_metadata\030\006 \001(\014\022!\n\026associated" +
      "_data_length\030\007 \001(\r:\0010\"D\n\rHeaderAndBody\022%" +
      "\n\006header\030\001 \002(\0132\025.securemessage.Header\022\014\n" +
      "\004body\030\002 \002(\014\"5\n\025HeaderAndBodyInternal\022\016\n\006" +
      "header\030\001 \002(\014\022\014\n\004body\030\002 \002(\014\"\'\n\017EcP256Publ" +
      "icKey\022\t\n\001x\030\001 \002(\014\022\t\n\001y\030\002 \002(\014\"1\n\022SimpleRsa" +
      "PublicKey\022\t\n\001n\030\001 \002(\014\022\020\n\001e\030\002 \001(\005:\00565537\"\030" +
      "\n\013DhPublicKey\022\t\n\001y\030\001 \002(\014\"\360\001\n\020GenericPubl" +
      "icKey\022*\n\004type\030\001 \002(\0162\034.securemessage.Publ" +
      "icKeyType\022:\n\022ec_p256_public_key\030\002 \001(\0132\036." +
      "securemessage.EcP256PublicKey\022=\n\022rsa2048" +
      "_public_key\030\003 \001(\0132!.securemessage.Simple" +
      "RsaPublicKey\0225\n\021dh2048_public_key\030\004 \001(\0132" +
      "\032.securemessage.DhPublicKey*G\n\tSigScheme" +
      "\022\017\n\013HMAC_SHA256\020\001\022\025\n\021ECDSA_P256_SHA256\020\002" +
      "\022\022\n\016RSA2048_SHA256\020\003*&\n\tEncScheme\022\010\n\004NON" +
      "E\020\001\022\017\n\013AES_256_CBC\020\002*:\n\rPublicKeyType\022\013\n" +
      "\007EC_P256\020\001\022\013\n\007RSA2048\020\002\022\017\n\013DH2048_MODP\020\003" +
      "BN\n/com.google.security.cryptauth.lib.se" +
      "curemessageB\022SecureMessageProtoH\003\242\002\004SMSG"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        });
    internal_static_securemessage_SecureMessage_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_securemessage_SecureMessage_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_securemessage_SecureMessage_descriptor,
        new java.lang.String[] { "HeaderAndBody", "Signature", });
    internal_static_securemessage_Header_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_securemessage_Header_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_securemessage_Header_descriptor,
        new java.lang.String[] { "SignatureScheme", "EncryptionScheme", "VerificationKeyId", "DecryptionKeyId", "Iv", "PublicMetadata", "AssociatedDataLength", });
    internal_static_securemessage_HeaderAndBody_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_securemessage_HeaderAndBody_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_securemessage_HeaderAndBody_descriptor,
        new java.lang.String[] { "Header", "Body", });
    internal_static_securemessage_HeaderAndBodyInternal_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_securemessage_HeaderAndBodyInternal_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_securemessage_HeaderAndBodyInternal_descriptor,
        new java.lang.String[] { "Header", "Body", });
    internal_static_securemessage_EcP256PublicKey_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_securemessage_EcP256PublicKey_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_securemessage_EcP256PublicKey_descriptor,
        new java.lang.String[] { "X", "Y", });
    internal_static_securemessage_SimpleRsaPublicKey_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_securemessage_SimpleRsaPublicKey_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_securemessage_SimpleRsaPublicKey_descriptor,
        new java.lang.String[] { "N", "E", });
    internal_static_securemessage_DhPublicKey_descriptor =
      getDescriptor().getMessageTypes().get(6);
    internal_static_securemessage_DhPublicKey_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_securemessage_DhPublicKey_descriptor,
        new java.lang.String[] { "Y", });
    internal_static_securemessage_GenericPublicKey_descriptor =
      getDescriptor().getMessageTypes().get(7);
    internal_static_securemessage_GenericPublicKey_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_securemessage_GenericPublicKey_descriptor,
        new java.lang.String[] { "Type", "EcP256PublicKey", "Rsa2048PublicKey", "Dh2048PublicKey", });
    descriptor.resolveAllFeaturesImmutable();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
