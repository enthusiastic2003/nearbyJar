// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: securegcm.proto
// Protobuf Java Version: 4.26.1

package com.google.security.cryptauth.lib.securegcm;

public final class SecureGcmProto {
  private SecureGcmProto() {}
  static {
    com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
      com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
      /* major= */ 4,
      /* minor= */ 26,
      /* patch= */ 1,
      /* suffix= */ "",
      SecureGcmProto.class.getName());
  }
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  /**
   * <pre>
   * This enum is used by iOS devices as values for device_display_diagonal_mils
   * in GcmDeviceInfo. There is no good way to calculate it on those devices.
   * </pre>
   *
   * Protobuf enum {@code securegcm.AppleDeviceDiagonalMils}
   */
  public enum AppleDeviceDiagonalMils
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * This is the mils diagonal on an iPhone 5.
     * </pre>
     *
     * <code>APPLE_PHONE = 4000;</code>
     */
    APPLE_PHONE(4000),
    /**
     * <pre>
     * This is the mils diagonal on an iPad mini.
     * </pre>
     *
     * <code>APPLE_PAD = 7900;</code>
     */
    APPLE_PAD(7900),
    ;

    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        AppleDeviceDiagonalMils.class.getName());
    }
    /**
     * <pre>
     * This is the mils diagonal on an iPhone 5.
     * </pre>
     *
     * <code>APPLE_PHONE = 4000;</code>
     */
    public static final int APPLE_PHONE_VALUE = 4000;
    /**
     * <pre>
     * This is the mils diagonal on an iPad mini.
     * </pre>
     *
     * <code>APPLE_PAD = 7900;</code>
     */
    public static final int APPLE_PAD_VALUE = 7900;


    public final int getNumber() {
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AppleDeviceDiagonalMils valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AppleDeviceDiagonalMils forNumber(int value) {
      switch (value) {
        case 4000: return APPLE_PHONE;
        case 7900: return APPLE_PAD;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AppleDeviceDiagonalMils>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        AppleDeviceDiagonalMils> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<AppleDeviceDiagonalMils>() {
            public AppleDeviceDiagonalMils findValueByNumber(int number) {
              return AppleDeviceDiagonalMils.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.getDescriptor().getEnumTypes().get(0);
    }

    private static final AppleDeviceDiagonalMils[] VALUES = values();

    public static AppleDeviceDiagonalMils valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AppleDeviceDiagonalMils(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:securegcm.AppleDeviceDiagonalMils)
  }

  /**
   * <pre>
   * This should be kept in sync with DeviceType in:
   * java/com/google/security/cryptauth/backend/services/common/common_enums.proto
   * </pre>
   *
   * Protobuf enum {@code securegcm.DeviceType}
   */
  public enum DeviceType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>UNKNOWN = 0;</code>
     */
    UNKNOWN(0),
    /**
     * <code>ANDROID = 1;</code>
     */
    ANDROID(1),
    /**
     * <code>CHROME = 2;</code>
     */
    CHROME(2),
    /**
     * <code>IOS = 3;</code>
     */
    IOS(3),
    /**
     * <code>BROWSER = 4;</code>
     */
    BROWSER(4),
    /**
     * <code>OSX = 5;</code>
     */
    OSX(5),
    ;

    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        DeviceType.class.getName());
    }
    /**
     * <code>UNKNOWN = 0;</code>
     */
    public static final int UNKNOWN_VALUE = 0;
    /**
     * <code>ANDROID = 1;</code>
     */
    public static final int ANDROID_VALUE = 1;
    /**
     * <code>CHROME = 2;</code>
     */
    public static final int CHROME_VALUE = 2;
    /**
     * <code>IOS = 3;</code>
     */
    public static final int IOS_VALUE = 3;
    /**
     * <code>BROWSER = 4;</code>
     */
    public static final int BROWSER_VALUE = 4;
    /**
     * <code>OSX = 5;</code>
     */
    public static final int OSX_VALUE = 5;


    public final int getNumber() {
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static DeviceType valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static DeviceType forNumber(int value) {
      switch (value) {
        case 0: return UNKNOWN;
        case 1: return ANDROID;
        case 2: return CHROME;
        case 3: return IOS;
        case 4: return BROWSER;
        case 5: return OSX;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<DeviceType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        DeviceType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<DeviceType>() {
            public DeviceType findValueByNumber(int number) {
              return DeviceType.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.getDescriptor().getEnumTypes().get(1);
    }

    private static final DeviceType[] VALUES = values();

    public static DeviceType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private DeviceType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:securegcm.DeviceType)
  }

  /**
   * <pre>
   * MultiDevice features which may be supported and enabled on a device. See
   * </pre>
   *
   * Protobuf enum {@code securegcm.SoftwareFeature}
   */
  public enum SoftwareFeature
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>UNKNOWN_FEATURE = 0;</code>
     */
    UNKNOWN_FEATURE(0),
    /**
     * <code>BETTER_TOGETHER_HOST = 1;</code>
     */
    BETTER_TOGETHER_HOST(1),
    /**
     * <code>BETTER_TOGETHER_CLIENT = 2;</code>
     */
    BETTER_TOGETHER_CLIENT(2),
    /**
     * <code>EASY_UNLOCK_HOST = 3;</code>
     */
    EASY_UNLOCK_HOST(3),
    /**
     * <code>EASY_UNLOCK_CLIENT = 4;</code>
     */
    EASY_UNLOCK_CLIENT(4),
    /**
     * <code>MAGIC_TETHER_HOST = 5;</code>
     */
    MAGIC_TETHER_HOST(5),
    /**
     * <code>MAGIC_TETHER_CLIENT = 6;</code>
     */
    MAGIC_TETHER_CLIENT(6),
    /**
     * <code>SMS_CONNECT_HOST = 7;</code>
     */
    SMS_CONNECT_HOST(7),
    /**
     * <code>SMS_CONNECT_CLIENT = 8;</code>
     */
    SMS_CONNECT_CLIENT(8),
    ;

    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        SoftwareFeature.class.getName());
    }
    /**
     * <code>UNKNOWN_FEATURE = 0;</code>
     */
    public static final int UNKNOWN_FEATURE_VALUE = 0;
    /**
     * <code>BETTER_TOGETHER_HOST = 1;</code>
     */
    public static final int BETTER_TOGETHER_HOST_VALUE = 1;
    /**
     * <code>BETTER_TOGETHER_CLIENT = 2;</code>
     */
    public static final int BETTER_TOGETHER_CLIENT_VALUE = 2;
    /**
     * <code>EASY_UNLOCK_HOST = 3;</code>
     */
    public static final int EASY_UNLOCK_HOST_VALUE = 3;
    /**
     * <code>EASY_UNLOCK_CLIENT = 4;</code>
     */
    public static final int EASY_UNLOCK_CLIENT_VALUE = 4;
    /**
     * <code>MAGIC_TETHER_HOST = 5;</code>
     */
    public static final int MAGIC_TETHER_HOST_VALUE = 5;
    /**
     * <code>MAGIC_TETHER_CLIENT = 6;</code>
     */
    public static final int MAGIC_TETHER_CLIENT_VALUE = 6;
    /**
     * <code>SMS_CONNECT_HOST = 7;</code>
     */
    public static final int SMS_CONNECT_HOST_VALUE = 7;
    /**
     * <code>SMS_CONNECT_CLIENT = 8;</code>
     */
    public static final int SMS_CONNECT_CLIENT_VALUE = 8;


    public final int getNumber() {
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static SoftwareFeature valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static SoftwareFeature forNumber(int value) {
      switch (value) {
        case 0: return UNKNOWN_FEATURE;
        case 1: return BETTER_TOGETHER_HOST;
        case 2: return BETTER_TOGETHER_CLIENT;
        case 3: return EASY_UNLOCK_HOST;
        case 4: return EASY_UNLOCK_CLIENT;
        case 5: return MAGIC_TETHER_HOST;
        case 6: return MAGIC_TETHER_CLIENT;
        case 7: return SMS_CONNECT_HOST;
        case 8: return SMS_CONNECT_CLIENT;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<SoftwareFeature>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        SoftwareFeature> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<SoftwareFeature>() {
            public SoftwareFeature findValueByNumber(int number) {
              return SoftwareFeature.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.getDescriptor().getEnumTypes().get(2);
    }

    private static final SoftwareFeature[] VALUES = values();

    public static SoftwareFeature valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private SoftwareFeature(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:securegcm.SoftwareFeature)
  }

  /**
   * <pre>
   * A list of "reasons" that can be provided for calling server-side APIs.
   * This is particularly important for calls that can be triggered by different
   * kinds of events. Please try to keep reasons as generic as possible, so that
   * codes can be re-used by various callers in a sensible fashion.
   * </pre>
   *
   * Protobuf enum {@code securegcm.InvocationReason}
   */
  public enum InvocationReason
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>REASON_UNKNOWN = 0;</code>
     */
    REASON_UNKNOWN(0),
    /**
     * <pre>
     * First run of the software package invoking this call
     * </pre>
     *
     * <code>REASON_INITIALIZATION = 1;</code>
     */
    REASON_INITIALIZATION(1),
    /**
     * <pre>
     * Ordinary periodic actions (e.g. monthly master key rotation)
     * </pre>
     *
     * <code>REASON_PERIODIC = 2;</code>
     */
    REASON_PERIODIC(2),
    /**
     * <pre>
     * Slow-cycle periodic action (e.g. yearly keypair rotation???)
     * </pre>
     *
     * <code>REASON_SLOW_PERIODIC = 3;</code>
     */
    REASON_SLOW_PERIODIC(3),
    /**
     * <pre>
     * Fast-cycle periodic action (e.g. daily sync for Smart Lock users)
     * </pre>
     *
     * <code>REASON_FAST_PERIODIC = 4;</code>
     */
    REASON_FAST_PERIODIC(4),
    /**
     * <pre>
     * Expired state (e.g. expired credentials, or cached entries) was detected
     * </pre>
     *
     * <code>REASON_EXPIRATION = 5;</code>
     */
    REASON_EXPIRATION(5),
    /**
     * <pre>
     * An unexpected protocol failure occurred (so attempting to repair state)
     * </pre>
     *
     * <code>REASON_FAILURE_RECOVERY = 6;</code>
     */
    REASON_FAILURE_RECOVERY(6),
    /**
     * <pre>
     * A new account has been added to the device
     * </pre>
     *
     * <code>REASON_NEW_ACCOUNT = 7;</code>
     */
    REASON_NEW_ACCOUNT(7),
    /**
     * <pre>
     * An existing account on the device has been changed
     * </pre>
     *
     * <code>REASON_CHANGED_ACCOUNT = 8;</code>
     */
    REASON_CHANGED_ACCOUNT(8),
    /**
     * <pre>
     * The user toggled the state of a feature (e.g. Smart Lock enabled via BT)
     * </pre>
     *
     * <code>REASON_FEATURE_TOGGLED = 9;</code>
     */
    REASON_FEATURE_TOGGLED(9),
    /**
     * <pre>
     * A "push" from the server caused this action (e.g. a sync tickle)
     * </pre>
     *
     * <code>REASON_SERVER_INITIATED = 10;</code>
     */
    REASON_SERVER_INITIATED(10),
    /**
     * <pre>
     * A local address change triggered this (e.g. GCM registration id changed)
     * </pre>
     *
     * <code>REASON_ADDRESS_CHANGE = 11;</code>
     */
    REASON_ADDRESS_CHANGE(11),
    /**
     * <pre>
     * A software update has triggered this
     * </pre>
     *
     * <code>REASON_SOFTWARE_UPDATE = 12;</code>
     */
    REASON_SOFTWARE_UPDATE(12),
    /**
     * <pre>
     * A manual action by the user triggered this (e.g. commands sent via adb)
     * </pre>
     *
     * <code>REASON_MANUAL = 13;</code>
     */
    REASON_MANUAL(13),
    /**
     * <pre>
     * A custom key has been invalidated on the device (e.g. screen lock is
     * disabled).
     * </pre>
     *
     * <code>REASON_CUSTOM_KEY_INVALIDATION = 14;</code>
     */
    REASON_CUSTOM_KEY_INVALIDATION(14),
    /**
     * <pre>
     * Periodic action triggered by auth_proximity
     * </pre>
     *
     * <code>REASON_PROXIMITY_PERIODIC = 15;</code>
     */
    REASON_PROXIMITY_PERIODIC(15),
    ;

    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        InvocationReason.class.getName());
    }
    /**
     * <code>REASON_UNKNOWN = 0;</code>
     */
    public static final int REASON_UNKNOWN_VALUE = 0;
    /**
     * <pre>
     * First run of the software package invoking this call
     * </pre>
     *
     * <code>REASON_INITIALIZATION = 1;</code>
     */
    public static final int REASON_INITIALIZATION_VALUE = 1;
    /**
     * <pre>
     * Ordinary periodic actions (e.g. monthly master key rotation)
     * </pre>
     *
     * <code>REASON_PERIODIC = 2;</code>
     */
    public static final int REASON_PERIODIC_VALUE = 2;
    /**
     * <pre>
     * Slow-cycle periodic action (e.g. yearly keypair rotation???)
     * </pre>
     *
     * <code>REASON_SLOW_PERIODIC = 3;</code>
     */
    public static final int REASON_SLOW_PERIODIC_VALUE = 3;
    /**
     * <pre>
     * Fast-cycle periodic action (e.g. daily sync for Smart Lock users)
     * </pre>
     *
     * <code>REASON_FAST_PERIODIC = 4;</code>
     */
    public static final int REASON_FAST_PERIODIC_VALUE = 4;
    /**
     * <pre>
     * Expired state (e.g. expired credentials, or cached entries) was detected
     * </pre>
     *
     * <code>REASON_EXPIRATION = 5;</code>
     */
    public static final int REASON_EXPIRATION_VALUE = 5;
    /**
     * <pre>
     * An unexpected protocol failure occurred (so attempting to repair state)
     * </pre>
     *
     * <code>REASON_FAILURE_RECOVERY = 6;</code>
     */
    public static final int REASON_FAILURE_RECOVERY_VALUE = 6;
    /**
     * <pre>
     * A new account has been added to the device
     * </pre>
     *
     * <code>REASON_NEW_ACCOUNT = 7;</code>
     */
    public static final int REASON_NEW_ACCOUNT_VALUE = 7;
    /**
     * <pre>
     * An existing account on the device has been changed
     * </pre>
     *
     * <code>REASON_CHANGED_ACCOUNT = 8;</code>
     */
    public static final int REASON_CHANGED_ACCOUNT_VALUE = 8;
    /**
     * <pre>
     * The user toggled the state of a feature (e.g. Smart Lock enabled via BT)
     * </pre>
     *
     * <code>REASON_FEATURE_TOGGLED = 9;</code>
     */
    public static final int REASON_FEATURE_TOGGLED_VALUE = 9;
    /**
     * <pre>
     * A "push" from the server caused this action (e.g. a sync tickle)
     * </pre>
     *
     * <code>REASON_SERVER_INITIATED = 10;</code>
     */
    public static final int REASON_SERVER_INITIATED_VALUE = 10;
    /**
     * <pre>
     * A local address change triggered this (e.g. GCM registration id changed)
     * </pre>
     *
     * <code>REASON_ADDRESS_CHANGE = 11;</code>
     */
    public static final int REASON_ADDRESS_CHANGE_VALUE = 11;
    /**
     * <pre>
     * A software update has triggered this
     * </pre>
     *
     * <code>REASON_SOFTWARE_UPDATE = 12;</code>
     */
    public static final int REASON_SOFTWARE_UPDATE_VALUE = 12;
    /**
     * <pre>
     * A manual action by the user triggered this (e.g. commands sent via adb)
     * </pre>
     *
     * <code>REASON_MANUAL = 13;</code>
     */
    public static final int REASON_MANUAL_VALUE = 13;
    /**
     * <pre>
     * A custom key has been invalidated on the device (e.g. screen lock is
     * disabled).
     * </pre>
     *
     * <code>REASON_CUSTOM_KEY_INVALIDATION = 14;</code>
     */
    public static final int REASON_CUSTOM_KEY_INVALIDATION_VALUE = 14;
    /**
     * <pre>
     * Periodic action triggered by auth_proximity
     * </pre>
     *
     * <code>REASON_PROXIMITY_PERIODIC = 15;</code>
     */
    public static final int REASON_PROXIMITY_PERIODIC_VALUE = 15;


    public final int getNumber() {
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static InvocationReason valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static InvocationReason forNumber(int value) {
      switch (value) {
        case 0: return REASON_UNKNOWN;
        case 1: return REASON_INITIALIZATION;
        case 2: return REASON_PERIODIC;
        case 3: return REASON_SLOW_PERIODIC;
        case 4: return REASON_FAST_PERIODIC;
        case 5: return REASON_EXPIRATION;
        case 6: return REASON_FAILURE_RECOVERY;
        case 7: return REASON_NEW_ACCOUNT;
        case 8: return REASON_CHANGED_ACCOUNT;
        case 9: return REASON_FEATURE_TOGGLED;
        case 10: return REASON_SERVER_INITIATED;
        case 11: return REASON_ADDRESS_CHANGE;
        case 12: return REASON_SOFTWARE_UPDATE;
        case 13: return REASON_MANUAL;
        case 14: return REASON_CUSTOM_KEY_INVALIDATION;
        case 15: return REASON_PROXIMITY_PERIODIC;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<InvocationReason>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        InvocationReason> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<InvocationReason>() {
            public InvocationReason findValueByNumber(int number) {
              return InvocationReason.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.getDescriptor().getEnumTypes().get(3);
    }

    private static final InvocationReason[] VALUES = values();

    public static InvocationReason valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private InvocationReason(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:securegcm.InvocationReason)
  }

  /**
   * Protobuf enum {@code securegcm.Type}
   */
  public enum Type
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>ENROLLMENT = 0;</code>
     */
    ENROLLMENT(0),
    /**
     * <code>TICKLE = 1;</code>
     */
    TICKLE(1),
    /**
     * <code>TX_REQUEST = 2;</code>
     */
    TX_REQUEST(2),
    /**
     * <code>TX_REPLY = 3;</code>
     */
    TX_REPLY(3),
    /**
     * <code>TX_SYNC_REQUEST = 4;</code>
     */
    TX_SYNC_REQUEST(4),
    /**
     * <code>TX_SYNC_RESPONSE = 5;</code>
     */
    TX_SYNC_RESPONSE(5),
    /**
     * <code>TX_PING = 6;</code>
     */
    TX_PING(6),
    /**
     * <code>DEVICE_INFO_UPDATE = 7;</code>
     */
    DEVICE_INFO_UPDATE(7),
    /**
     * <code>TX_CANCEL_REQUEST = 8;</code>
     */
    TX_CANCEL_REQUEST(8),
    /**
     * <pre>
     * DEPRECATED (can be re-used after Aug 2015)
     * </pre>
     *
     * <code>PROXIMITYAUTH_PAIRING = 10;</code>
     */
    PROXIMITYAUTH_PAIRING(10),
    /**
     * <pre>
     * The kind of identity assertion generated by a "GCM V1" device (i.e.,
     * an Android phone that has registered with us a public and a symmetric
     * key)
     * </pre>
     *
     * <code>GCMV1_IDENTITY_ASSERTION = 11;</code>
     */
    GCMV1_IDENTITY_ASSERTION(11),
    /**
     * <pre>
     * Device-to-device communications are protected by an unauthenticated
     * Diffie-Hellman exchange. The InitiatorHello message is simply the
     * initiator's public DH key, and is not encoded as a SecureMessage, so
     * it doesn't have a tag.
     * The ResponderHello message (which is sent by the responder
     * to the initiator), on the other hand, carries a payload that is protected
     * by the derived shared key. It also contains the responder's
     * public DH key. ResponderHelloAndPayload messages have the
     * DEVICE_TO_DEVICE_RESPONDER_HELLO tag.
     * </pre>
     *
     * <code>DEVICE_TO_DEVICE_RESPONDER_HELLO_PAYLOAD = 12;</code>
     */
    DEVICE_TO_DEVICE_RESPONDER_HELLO_PAYLOAD(12),
    /**
     * <pre>
     * Device-to-device communications are protected by an unauthenticated
     * Diffie-Hellman exchange. Once the initiator and responder
     * agree on a shared key (through Diffie-Hellman), they will use messages
     * tagged with DEVICE_TO_DEVICE_MESSAGE to exchange data.
     * </pre>
     *
     * <code>DEVICE_TO_DEVICE_MESSAGE = 13;</code>
     */
    DEVICE_TO_DEVICE_MESSAGE(13),
    /**
     * <pre>
     * Notification to let a device know it should contact a nearby device.
     * </pre>
     *
     * <code>DEVICE_PROXIMITY_CALLBACK = 14;</code>
     */
    DEVICE_PROXIMITY_CALLBACK(14),
    /**
     * <pre>
     * Device-to-device communications are protected by an unauthenticated
     * Diffie-Hellman exchange. During device-to-device authentication, the first
     * message from initiator (the challenge) is signed and put into the payload
     * of the message sent back to the initiator.
     * </pre>
     *
     * <code>UNLOCK_KEY_SIGNED_CHALLENGE = 15;</code>
     */
    UNLOCK_KEY_SIGNED_CHALLENGE(15),
    /**
     * <pre>
     * Specialty (corp only) features
     * </pre>
     *
     * <code>LOGIN_NOTIFICATION = 101;</code>
     */
    LOGIN_NOTIFICATION(101),
    ;

    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        Type.class.getName());
    }
    /**
     * <code>ENROLLMENT = 0;</code>
     */
    public static final int ENROLLMENT_VALUE = 0;
    /**
     * <code>TICKLE = 1;</code>
     */
    public static final int TICKLE_VALUE = 1;
    /**
     * <code>TX_REQUEST = 2;</code>
     */
    public static final int TX_REQUEST_VALUE = 2;
    /**
     * <code>TX_REPLY = 3;</code>
     */
    public static final int TX_REPLY_VALUE = 3;
    /**
     * <code>TX_SYNC_REQUEST = 4;</code>
     */
    public static final int TX_SYNC_REQUEST_VALUE = 4;
    /**
     * <code>TX_SYNC_RESPONSE = 5;</code>
     */
    public static final int TX_SYNC_RESPONSE_VALUE = 5;
    /**
     * <code>TX_PING = 6;</code>
     */
    public static final int TX_PING_VALUE = 6;
    /**
     * <code>DEVICE_INFO_UPDATE = 7;</code>
     */
    public static final int DEVICE_INFO_UPDATE_VALUE = 7;
    /**
     * <code>TX_CANCEL_REQUEST = 8;</code>
     */
    public static final int TX_CANCEL_REQUEST_VALUE = 8;
    /**
     * <pre>
     * DEPRECATED (can be re-used after Aug 2015)
     * </pre>
     *
     * <code>PROXIMITYAUTH_PAIRING = 10;</code>
     */
    public static final int PROXIMITYAUTH_PAIRING_VALUE = 10;
    /**
     * <pre>
     * The kind of identity assertion generated by a "GCM V1" device (i.e.,
     * an Android phone that has registered with us a public and a symmetric
     * key)
     * </pre>
     *
     * <code>GCMV1_IDENTITY_ASSERTION = 11;</code>
     */
    public static final int GCMV1_IDENTITY_ASSERTION_VALUE = 11;
    /**
     * <pre>
     * Device-to-device communications are protected by an unauthenticated
     * Diffie-Hellman exchange. The InitiatorHello message is simply the
     * initiator's public DH key, and is not encoded as a SecureMessage, so
     * it doesn't have a tag.
     * The ResponderHello message (which is sent by the responder
     * to the initiator), on the other hand, carries a payload that is protected
     * by the derived shared key. It also contains the responder's
     * public DH key. ResponderHelloAndPayload messages have the
     * DEVICE_TO_DEVICE_RESPONDER_HELLO tag.
     * </pre>
     *
     * <code>DEVICE_TO_DEVICE_RESPONDER_HELLO_PAYLOAD = 12;</code>
     */
    public static final int DEVICE_TO_DEVICE_RESPONDER_HELLO_PAYLOAD_VALUE = 12;
    /**
     * <pre>
     * Device-to-device communications are protected by an unauthenticated
     * Diffie-Hellman exchange. Once the initiator and responder
     * agree on a shared key (through Diffie-Hellman), they will use messages
     * tagged with DEVICE_TO_DEVICE_MESSAGE to exchange data.
     * </pre>
     *
     * <code>DEVICE_TO_DEVICE_MESSAGE = 13;</code>
     */
    public static final int DEVICE_TO_DEVICE_MESSAGE_VALUE = 13;
    /**
     * <pre>
     * Notification to let a device know it should contact a nearby device.
     * </pre>
     *
     * <code>DEVICE_PROXIMITY_CALLBACK = 14;</code>
     */
    public static final int DEVICE_PROXIMITY_CALLBACK_VALUE = 14;
    /**
     * <pre>
     * Device-to-device communications are protected by an unauthenticated
     * Diffie-Hellman exchange. During device-to-device authentication, the first
     * message from initiator (the challenge) is signed and put into the payload
     * of the message sent back to the initiator.
     * </pre>
     *
     * <code>UNLOCK_KEY_SIGNED_CHALLENGE = 15;</code>
     */
    public static final int UNLOCK_KEY_SIGNED_CHALLENGE_VALUE = 15;
    /**
     * <pre>
     * Specialty (corp only) features
     * </pre>
     *
     * <code>LOGIN_NOTIFICATION = 101;</code>
     */
    public static final int LOGIN_NOTIFICATION_VALUE = 101;


    public final int getNumber() {
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static Type valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static Type forNumber(int value) {
      switch (value) {
        case 0: return ENROLLMENT;
        case 1: return TICKLE;
        case 2: return TX_REQUEST;
        case 3: return TX_REPLY;
        case 4: return TX_SYNC_REQUEST;
        case 5: return TX_SYNC_RESPONSE;
        case 6: return TX_PING;
        case 7: return DEVICE_INFO_UPDATE;
        case 8: return TX_CANCEL_REQUEST;
        case 10: return PROXIMITYAUTH_PAIRING;
        case 11: return GCMV1_IDENTITY_ASSERTION;
        case 12: return DEVICE_TO_DEVICE_RESPONDER_HELLO_PAYLOAD;
        case 13: return DEVICE_TO_DEVICE_MESSAGE;
        case 14: return DEVICE_PROXIMITY_CALLBACK;
        case 15: return UNLOCK_KEY_SIGNED_CHALLENGE;
        case 101: return LOGIN_NOTIFICATION;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<Type>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        Type> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<Type>() {
            public Type findValueByNumber(int number) {
              return Type.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.getDescriptor().getEnumTypes().get(4);
    }

    private static final Type[] VALUES = values();

    public static Type valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private Type(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:securegcm.Type)
  }

  public interface GcmDeviceInfoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:securegcm.GcmDeviceInfo)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * This field's name does not match the one in DeviceInfo for legacy reasons.
     * Consider using long_device_id and device_type instead when enrolling
     * non-android devices.
     * </pre>
     *
     * <code>optional fixed64 android_device_id = 1;</code>
     * @return Whether the androidDeviceId field is set.
     */
    boolean hasAndroidDeviceId();
    /**
     * <pre>
     * This field's name does not match the one in DeviceInfo for legacy reasons.
     * Consider using long_device_id and device_type instead when enrolling
     * non-android devices.
     * </pre>
     *
     * <code>optional fixed64 android_device_id = 1;</code>
     * @return The androidDeviceId.
     */
    long getAndroidDeviceId();

    /**
     * <pre>
     * Used for device_address of DeviceInfo field 2, but for GCM capable devices.
     * </pre>
     *
     * <code>optional bytes gcm_registration_id = 102;</code>
     * @return Whether the gcmRegistrationId field is set.
     */
    boolean hasGcmRegistrationId();
    /**
     * <pre>
     * Used for device_address of DeviceInfo field 2, but for GCM capable devices.
     * </pre>
     *
     * <code>optional bytes gcm_registration_id = 102;</code>
     * @return The gcmRegistrationId.
     */
    com.google.protobuf.ByteString getGcmRegistrationId();

    /**
     * <pre>
     * Used for device_address of DeviceInfo field 2, but for iOS devices.
     * </pre>
     *
     * <code>optional bytes apn_registration_id = 202;</code>
     * @return Whether the apnRegistrationId field is set.
     */
    boolean hasApnRegistrationId();
    /**
     * <pre>
     * Used for device_address of DeviceInfo field 2, but for iOS devices.
     * </pre>
     *
     * <code>optional bytes apn_registration_id = 202;</code>
     * @return The apnRegistrationId.
     */
    com.google.protobuf.ByteString getApnRegistrationId();

    /**
     * <pre>
     * Does the user have notifications enabled for the given device address.
     * </pre>
     *
     * <code>optional bool notification_enabled = 203 [default = true];</code>
     * @return Whether the notificationEnabled field is set.
     */
    boolean hasNotificationEnabled();
    /**
     * <pre>
     * Does the user have notifications enabled for the given device address.
     * </pre>
     *
     * <code>optional bool notification_enabled = 203 [default = true];</code>
     * @return The notificationEnabled.
     */
    boolean getNotificationEnabled();

    /**
     * <pre>
     * Used for device_address of DeviceInfo field 2, a Bluetooth Mac address for
     * the device (e.g., to be used with EasyUnlock)
     * </pre>
     *
     * <code>optional string bluetooth_mac_address = 302;</code>
     * @return Whether the bluetoothMacAddress field is set.
     */
    boolean hasBluetoothMacAddress();
    /**
     * <pre>
     * Used for device_address of DeviceInfo field 2, a Bluetooth Mac address for
     * the device (e.g., to be used with EasyUnlock)
     * </pre>
     *
     * <code>optional string bluetooth_mac_address = 302;</code>
     * @return The bluetoothMacAddress.
     */
    java.lang.String getBluetoothMacAddress();
    /**
     * <pre>
     * Used for device_address of DeviceInfo field 2, a Bluetooth Mac address for
     * the device (e.g., to be used with EasyUnlock)
     * </pre>
     *
     * <code>optional string bluetooth_mac_address = 302;</code>
     * @return The bytes for bluetoothMacAddress.
     */
    com.google.protobuf.ByteString
        getBluetoothMacAddressBytes();

    /**
     * <pre>
     * SHA-256 hash of the device master key (from the key exchange).
     * Differs from DeviceInfo field 3, which contains the actual master key.
     * </pre>
     *
     * <code>optional bytes device_master_key_hash = 103;</code>
     * @return Whether the deviceMasterKeyHash field is set.
     */
    boolean hasDeviceMasterKeyHash();
    /**
     * <pre>
     * SHA-256 hash of the device master key (from the key exchange).
     * Differs from DeviceInfo field 3, which contains the actual master key.
     * </pre>
     *
     * <code>optional bytes device_master_key_hash = 103;</code>
     * @return The deviceMasterKeyHash.
     */
    com.google.protobuf.ByteString getDeviceMasterKeyHash();

    /**
     * <pre>
     * A SecureMessage.EcP256PublicKey
     * </pre>
     *
     * <code>required bytes user_public_key = 4;</code>
     * @return Whether the userPublicKey field is set.
     */
    boolean hasUserPublicKey();
    /**
     * <pre>
     * A SecureMessage.EcP256PublicKey
     * </pre>
     *
     * <code>required bytes user_public_key = 4;</code>
     * @return The userPublicKey.
     */
    com.google.protobuf.ByteString getUserPublicKey();

    /**
     * <pre>
     * device's model name
     * (e.g., an android.os.Build.MODEL or UIDevice.model)
     * </pre>
     *
     * <code>optional string device_model = 7;</code>
     * @return Whether the deviceModel field is set.
     */
    boolean hasDeviceModel();
    /**
     * <pre>
     * device's model name
     * (e.g., an android.os.Build.MODEL or UIDevice.model)
     * </pre>
     *
     * <code>optional string device_model = 7;</code>
     * @return The deviceModel.
     */
    java.lang.String getDeviceModel();
    /**
     * <pre>
     * device's model name
     * (e.g., an android.os.Build.MODEL or UIDevice.model)
     * </pre>
     *
     * <code>optional string device_model = 7;</code>
     * @return The bytes for deviceModel.
     */
    com.google.protobuf.ByteString
        getDeviceModelBytes();

    /**
     * <pre>
     * device's locale
     * </pre>
     *
     * <code>optional string locale = 8;</code>
     * @return Whether the locale field is set.
     */
    boolean hasLocale();
    /**
     * <pre>
     * device's locale
     * </pre>
     *
     * <code>optional string locale = 8;</code>
     * @return The locale.
     */
    java.lang.String getLocale();
    /**
     * <pre>
     * device's locale
     * </pre>
     *
     * <code>optional string locale = 8;</code>
     * @return The bytes for locale.
     */
    com.google.protobuf.ByteString
        getLocaleBytes();

    /**
     * <pre>
     * The handle for user_public_key (and implicitly, a master key)
     * </pre>
     *
     * <code>optional bytes key_handle = 9;</code>
     * @return Whether the keyHandle field is set.
     */
    boolean hasKeyHandle();
    /**
     * <pre>
     * The handle for user_public_key (and implicitly, a master key)
     * </pre>
     *
     * <code>optional bytes key_handle = 9;</code>
     * @return The keyHandle.
     */
    com.google.protobuf.ByteString getKeyHandle();

    /**
     * <pre>
     * The initial counter value for the device, sent by the device
     * </pre>
     *
     * <code>optional int64 counter = 12 [default = 0];</code>
     * @return Whether the counter field is set.
     */
    boolean hasCounter();
    /**
     * <pre>
     * The initial counter value for the device, sent by the device
     * </pre>
     *
     * <code>optional int64 counter = 12 [default = 0];</code>
     * @return The counter.
     */
    long getCounter();

    /**
     * <pre>
     * The Operating System version on the device
     * (e.g., an android.os.Build.DISPLAY or UIDevice.systemVersion)
     * </pre>
     *
     * <code>optional string device_os_version = 13;</code>
     * @return Whether the deviceOsVersion field is set.
     */
    boolean hasDeviceOsVersion();
    /**
     * <pre>
     * The Operating System version on the device
     * (e.g., an android.os.Build.DISPLAY or UIDevice.systemVersion)
     * </pre>
     *
     * <code>optional string device_os_version = 13;</code>
     * @return The deviceOsVersion.
     */
    java.lang.String getDeviceOsVersion();
    /**
     * <pre>
     * The Operating System version on the device
     * (e.g., an android.os.Build.DISPLAY or UIDevice.systemVersion)
     * </pre>
     *
     * <code>optional string device_os_version = 13;</code>
     * @return The bytes for deviceOsVersion.
     */
    com.google.protobuf.ByteString
        getDeviceOsVersionBytes();

    /**
     * <pre>
     * The Operating System version number on the device
     * (e.g., an android.os.Build.VERSION.SDK_INT)
     * </pre>
     *
     * <code>optional int64 device_os_version_code = 14;</code>
     * @return Whether the deviceOsVersionCode field is set.
     */
    boolean hasDeviceOsVersionCode();
    /**
     * <pre>
     * The Operating System version number on the device
     * (e.g., an android.os.Build.VERSION.SDK_INT)
     * </pre>
     *
     * <code>optional int64 device_os_version_code = 14;</code>
     * @return The deviceOsVersionCode.
     */
    long getDeviceOsVersionCode();

    /**
     * <pre>
     * The Operating System release on the device
     * (e.g., an android.os.Build.VERSION.RELEASE)
     * </pre>
     *
     * <code>optional string device_os_release = 15;</code>
     * @return Whether the deviceOsRelease field is set.
     */
    boolean hasDeviceOsRelease();
    /**
     * <pre>
     * The Operating System release on the device
     * (e.g., an android.os.Build.VERSION.RELEASE)
     * </pre>
     *
     * <code>optional string device_os_release = 15;</code>
     * @return The deviceOsRelease.
     */
    java.lang.String getDeviceOsRelease();
    /**
     * <pre>
     * The Operating System release on the device
     * (e.g., an android.os.Build.VERSION.RELEASE)
     * </pre>
     *
     * <code>optional string device_os_release = 15;</code>
     * @return The bytes for deviceOsRelease.
     */
    com.google.protobuf.ByteString
        getDeviceOsReleaseBytes();

    /**
     * <pre>
     * The Operating System codename on the device
     * (e.g., an android.os.Build.VERSION.CODENAME or UIDevice.systemName)
     * </pre>
     *
     * <code>optional string device_os_codename = 16;</code>
     * @return Whether the deviceOsCodename field is set.
     */
    boolean hasDeviceOsCodename();
    /**
     * <pre>
     * The Operating System codename on the device
     * (e.g., an android.os.Build.VERSION.CODENAME or UIDevice.systemName)
     * </pre>
     *
     * <code>optional string device_os_codename = 16;</code>
     * @return The deviceOsCodename.
     */
    java.lang.String getDeviceOsCodename();
    /**
     * <pre>
     * The Operating System codename on the device
     * (e.g., an android.os.Build.VERSION.CODENAME or UIDevice.systemName)
     * </pre>
     *
     * <code>optional string device_os_codename = 16;</code>
     * @return The bytes for deviceOsCodename.
     */
    com.google.protobuf.ByteString
        getDeviceOsCodenameBytes();

    /**
     * <pre>
     * The software version running on the device
     * (e.g., Authenticator app version string)
     * </pre>
     *
     * <code>optional string device_software_version = 17;</code>
     * @return Whether the deviceSoftwareVersion field is set.
     */
    boolean hasDeviceSoftwareVersion();
    /**
     * <pre>
     * The software version running on the device
     * (e.g., Authenticator app version string)
     * </pre>
     *
     * <code>optional string device_software_version = 17;</code>
     * @return The deviceSoftwareVersion.
     */
    java.lang.String getDeviceSoftwareVersion();
    /**
     * <pre>
     * The software version running on the device
     * (e.g., Authenticator app version string)
     * </pre>
     *
     * <code>optional string device_software_version = 17;</code>
     * @return The bytes for deviceSoftwareVersion.
     */
    com.google.protobuf.ByteString
        getDeviceSoftwareVersionBytes();

    /**
     * <pre>
     * The software version number running on the device
     * (e.g., Authenticator app version code)
     * </pre>
     *
     * <code>optional int64 device_software_version_code = 18;</code>
     * @return Whether the deviceSoftwareVersionCode field is set.
     */
    boolean hasDeviceSoftwareVersionCode();
    /**
     * <pre>
     * The software version number running on the device
     * (e.g., Authenticator app version code)
     * </pre>
     *
     * <code>optional int64 device_software_version_code = 18;</code>
     * @return The deviceSoftwareVersionCode.
     */
    long getDeviceSoftwareVersionCode();

    /**
     * <pre>
     * Software package information if applicable
     * (e.g., com.google.android.apps.authenticator2)
     * </pre>
     *
     * <code>optional string device_software_package = 19;</code>
     * @return Whether the deviceSoftwarePackage field is set.
     */
    boolean hasDeviceSoftwarePackage();
    /**
     * <pre>
     * Software package information if applicable
     * (e.g., com.google.android.apps.authenticator2)
     * </pre>
     *
     * <code>optional string device_software_package = 19;</code>
     * @return The deviceSoftwarePackage.
     */
    java.lang.String getDeviceSoftwarePackage();
    /**
     * <pre>
     * Software package information if applicable
     * (e.g., com.google.android.apps.authenticator2)
     * </pre>
     *
     * <code>optional string device_software_package = 19;</code>
     * @return The bytes for deviceSoftwarePackage.
     */
    com.google.protobuf.ByteString
        getDeviceSoftwarePackageBytes();

    /**
     * <pre>
     * Size of the display in thousandths of an inch (e.g., 7000 mils = 7 in)
     * </pre>
     *
     * <code>optional int32 device_display_diagonal_mils = 22;</code>
     * @return Whether the deviceDisplayDiagonalMils field is set.
     */
    boolean hasDeviceDisplayDiagonalMils();
    /**
     * <pre>
     * Size of the display in thousandths of an inch (e.g., 7000 mils = 7 in)
     * </pre>
     *
     * <code>optional int32 device_display_diagonal_mils = 22;</code>
     * @return The deviceDisplayDiagonalMils.
     */
    int getDeviceDisplayDiagonalMils();

    /**
     * <pre>
     * For Authzen capable devices, their Authzen protocol version
     * </pre>
     *
     * <code>optional int32 device_authzen_version = 24;</code>
     * @return Whether the deviceAuthzenVersion field is set.
     */
    boolean hasDeviceAuthzenVersion();
    /**
     * <pre>
     * For Authzen capable devices, their Authzen protocol version
     * </pre>
     *
     * <code>optional int32 device_authzen_version = 24;</code>
     * @return The deviceAuthzenVersion.
     */
    int getDeviceAuthzenVersion();

    /**
     * <pre>
     * Not all devices have device identifiers that fit in 64 bits.
     * </pre>
     *
     * <code>optional bytes long_device_id = 29;</code>
     * @return Whether the longDeviceId field is set.
     */
    boolean hasLongDeviceId();
    /**
     * <pre>
     * Not all devices have device identifiers that fit in 64 bits.
     * </pre>
     *
     * <code>optional bytes long_device_id = 29;</code>
     * @return The longDeviceId.
     */
    com.google.protobuf.ByteString getLongDeviceId();

    /**
     * <pre>
     * The device manufacturer name
     * (e.g., android.os.Build.MANUFACTURER)
     * </pre>
     *
     * <code>optional string device_manufacturer = 31;</code>
     * @return Whether the deviceManufacturer field is set.
     */
    boolean hasDeviceManufacturer();
    /**
     * <pre>
     * The device manufacturer name
     * (e.g., android.os.Build.MANUFACTURER)
     * </pre>
     *
     * <code>optional string device_manufacturer = 31;</code>
     * @return The deviceManufacturer.
     */
    java.lang.String getDeviceManufacturer();
    /**
     * <pre>
     * The device manufacturer name
     * (e.g., android.os.Build.MANUFACTURER)
     * </pre>
     *
     * <code>optional string device_manufacturer = 31;</code>
     * @return The bytes for deviceManufacturer.
     */
    com.google.protobuf.ByteString
        getDeviceManufacturerBytes();

    /**
     * <pre>
     * Used to indicate which type of device this is.
     * </pre>
     *
     * <code>optional .securegcm.DeviceType device_type = 32 [default = ANDROID];</code>
     * @return Whether the deviceType field is set.
     */
    boolean hasDeviceType();
    /**
     * <pre>
     * Used to indicate which type of device this is.
     * </pre>
     *
     * <code>optional .securegcm.DeviceType device_type = 32 [default = ANDROID];</code>
     * @return The deviceType.
     */
    com.google.security.cryptauth.lib.securegcm.SecureGcmProto.DeviceType getDeviceType();

    /**
     * <pre>
     * Is this device using  a secure screenlock (e.g., pattern or pin unlock)
     * </pre>
     *
     * <code>optional bool using_secure_screenlock = 400 [default = false];</code>
     * @return Whether the usingSecureScreenlock field is set.
     */
    boolean hasUsingSecureScreenlock();
    /**
     * <pre>
     * Is this device using  a secure screenlock (e.g., pattern or pin unlock)
     * </pre>
     *
     * <code>optional bool using_secure_screenlock = 400 [default = false];</code>
     * @return The usingSecureScreenlock.
     */
    boolean getUsingSecureScreenlock();

    /**
     * <pre>
     * Is auto-unlocking the screenlock (e.g., when at "home") supported?
     * </pre>
     *
     * <code>optional bool auto_unlock_screenlock_supported = 401 [default = false];</code>
     * @return Whether the autoUnlockScreenlockSupported field is set.
     */
    boolean hasAutoUnlockScreenlockSupported();
    /**
     * <pre>
     * Is auto-unlocking the screenlock (e.g., when at "home") supported?
     * </pre>
     *
     * <code>optional bool auto_unlock_screenlock_supported = 401 [default = false];</code>
     * @return The autoUnlockScreenlockSupported.
     */
    boolean getAutoUnlockScreenlockSupported();

    /**
     * <pre>
     * Is auto-unlocking the screenlock (e.g., when at "home") enabled?
     * </pre>
     *
     * <code>optional bool auto_unlock_screenlock_enabled = 402 [default = false];</code>
     * @return Whether the autoUnlockScreenlockEnabled field is set.
     */
    boolean hasAutoUnlockScreenlockEnabled();
    /**
     * <pre>
     * Is auto-unlocking the screenlock (e.g., when at "home") enabled?
     * </pre>
     *
     * <code>optional bool auto_unlock_screenlock_enabled = 402 [default = false];</code>
     * @return The autoUnlockScreenlockEnabled.
     */
    boolean getAutoUnlockScreenlockEnabled();

    /**
     * <pre>
     * Does the device have a Bluetooth (classic) radio?
     * </pre>
     *
     * <code>optional bool bluetooth_radio_supported = 403 [default = false];</code>
     * @return Whether the bluetoothRadioSupported field is set.
     */
    boolean hasBluetoothRadioSupported();
    /**
     * <pre>
     * Does the device have a Bluetooth (classic) radio?
     * </pre>
     *
     * <code>optional bool bluetooth_radio_supported = 403 [default = false];</code>
     * @return The bluetoothRadioSupported.
     */
    boolean getBluetoothRadioSupported();

    /**
     * <pre>
     * Is the Bluetooth (classic) radio on?
     * </pre>
     *
     * <code>optional bool bluetooth_radio_enabled = 404 [default = false];</code>
     * @return Whether the bluetoothRadioEnabled field is set.
     */
    boolean hasBluetoothRadioEnabled();
    /**
     * <pre>
     * Is the Bluetooth (classic) radio on?
     * </pre>
     *
     * <code>optional bool bluetooth_radio_enabled = 404 [default = false];</code>
     * @return The bluetoothRadioEnabled.
     */
    boolean getBluetoothRadioEnabled();

    /**
     * <pre>
     * Does the device hardware support a mobile data connection?
     * </pre>
     *
     * <code>optional bool mobile_data_supported = 405 [default = false];</code>
     * @return Whether the mobileDataSupported field is set.
     */
    boolean hasMobileDataSupported();
    /**
     * <pre>
     * Does the device hardware support a mobile data connection?
     * </pre>
     *
     * <code>optional bool mobile_data_supported = 405 [default = false];</code>
     * @return The mobileDataSupported.
     */
    boolean getMobileDataSupported();

    /**
     * <pre>
     * Does the device support tethering?
     * </pre>
     *
     * <code>optional bool tethering_supported = 406 [default = false];</code>
     * @return Whether the tetheringSupported field is set.
     */
    boolean hasTetheringSupported();
    /**
     * <pre>
     * Does the device support tethering?
     * </pre>
     *
     * <code>optional bool tethering_supported = 406 [default = false];</code>
     * @return The tetheringSupported.
     */
    boolean getTetheringSupported();

    /**
     * <pre>
     * Does the device have a BLE radio?
     * </pre>
     *
     * <code>optional bool ble_radio_supported = 407 [default = false];</code>
     * @return Whether the bleRadioSupported field is set.
     */
    boolean hasBleRadioSupported();
    /**
     * <pre>
     * Does the device have a BLE radio?
     * </pre>
     *
     * <code>optional bool ble_radio_supported = 407 [default = false];</code>
     * @return The bleRadioSupported.
     */
    boolean getBleRadioSupported();

    /**
     * <pre>
     * Is the device a "Pixel Experience" Android device?
     * </pre>
     *
     * <code>optional bool pixel_experience = 408 [default = false];</code>
     * @return Whether the pixelExperience field is set.
     */
    boolean hasPixelExperience();
    /**
     * <pre>
     * Is the device a "Pixel Experience" Android device?
     * </pre>
     *
     * <code>optional bool pixel_experience = 408 [default = false];</code>
     * @return The pixelExperience.
     */
    boolean getPixelExperience();

    /**
     * <pre>
     * Is the device running in the ARC++ container on a chromebook?
     * </pre>
     *
     * <code>optional bool arc_plus_plus = 409 [default = false];</code>
     * @return Whether the arcPlusPlus field is set.
     */
    boolean hasArcPlusPlus();
    /**
     * <pre>
     * Is the device running in the ARC++ container on a chromebook?
     * </pre>
     *
     * <code>optional bool arc_plus_plus = 409 [default = false];</code>
     * @return The arcPlusPlus.
     */
    boolean getArcPlusPlus();

    /**
     * <pre>
     * Is the value set in |using_secure_screenlock| reliable? On some Android
     * devices, the platform API to get the screenlock state is not trustworthy.
     * See b/32212161.
     * </pre>
     *
     * <code>optional bool is_screenlock_state_flaky = 410 [default = false];</code>
     * @return Whether the isScreenlockStateFlaky field is set.
     */
    boolean hasIsScreenlockStateFlaky();
    /**
     * <pre>
     * Is the value set in |using_secure_screenlock| reliable? On some Android
     * devices, the platform API to get the screenlock state is not trustworthy.
     * See b/32212161.
     * </pre>
     *
     * <code>optional bool is_screenlock_state_flaky = 410 [default = false];</code>
     * @return The isScreenlockStateFlaky.
     */
    boolean getIsScreenlockStateFlaky();

    /**
     * <pre>
     * A list of multi-device software features supported by the device.
     * </pre>
     *
     * <code>repeated .securegcm.SoftwareFeature supported_software_features = 411;</code>
     * @return A list containing the supportedSoftwareFeatures.
     */
    java.util.List<com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature> getSupportedSoftwareFeaturesList();
    /**
     * <pre>
     * A list of multi-device software features supported by the device.
     * </pre>
     *
     * <code>repeated .securegcm.SoftwareFeature supported_software_features = 411;</code>
     * @return The count of supportedSoftwareFeatures.
     */
    int getSupportedSoftwareFeaturesCount();
    /**
     * <pre>
     * A list of multi-device software features supported by the device.
     * </pre>
     *
     * <code>repeated .securegcm.SoftwareFeature supported_software_features = 411;</code>
     * @param index The index of the element to return.
     * @return The supportedSoftwareFeatures at the given index.
     */
    com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature getSupportedSoftwareFeatures(int index);

    /**
     * <pre>
     * A list of multi-device software features currently enabled (active) on the
     * device.
     * </pre>
     *
     * <code>repeated .securegcm.SoftwareFeature enabled_software_features = 412;</code>
     * @return A list containing the enabledSoftwareFeatures.
     */
    java.util.List<com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature> getEnabledSoftwareFeaturesList();
    /**
     * <pre>
     * A list of multi-device software features currently enabled (active) on the
     * device.
     * </pre>
     *
     * <code>repeated .securegcm.SoftwareFeature enabled_software_features = 412;</code>
     * @return The count of enabledSoftwareFeatures.
     */
    int getEnabledSoftwareFeaturesCount();
    /**
     * <pre>
     * A list of multi-device software features currently enabled (active) on the
     * device.
     * </pre>
     *
     * <code>repeated .securegcm.SoftwareFeature enabled_software_features = 412;</code>
     * @param index The index of the element to return.
     * @return The enabledSoftwareFeatures at the given index.
     */
    com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature getEnabledSoftwareFeatures(int index);

    /**
     * <pre>
     * The enrollment session id this is sent with
     * </pre>
     *
     * <code>optional bytes enrollment_session_id = 1000;</code>
     * @return Whether the enrollmentSessionId field is set.
     */
    boolean hasEnrollmentSessionId();
    /**
     * <pre>
     * The enrollment session id this is sent with
     * </pre>
     *
     * <code>optional bytes enrollment_session_id = 1000;</code>
     * @return The enrollmentSessionId.
     */
    com.google.protobuf.ByteString getEnrollmentSessionId();

    /**
     * <pre>
     * A copy of the user's OAuth token
     * </pre>
     *
     * <code>optional string oauth_token = 1001;</code>
     * @return Whether the oauthToken field is set.
     */
    boolean hasOauthToken();
    /**
     * <pre>
     * A copy of the user's OAuth token
     * </pre>
     *
     * <code>optional string oauth_token = 1001;</code>
     * @return The oauthToken.
     */
    java.lang.String getOauthToken();
    /**
     * <pre>
     * A copy of the user's OAuth token
     * </pre>
     *
     * <code>optional string oauth_token = 1001;</code>
     * @return The bytes for oauthToken.
     */
    com.google.protobuf.ByteString
        getOauthTokenBytes();
  }
  /**
   * <pre>
   * Message used only during enrollment
   * Field numbers should be kept in sync with DeviceInfo in:
   * java/com/google/security/cryptauth/backend/services/common/common.proto
   * </pre>
   *
   * Protobuf type {@code securegcm.GcmDeviceInfo}
   */
  public static final class GcmDeviceInfo extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:securegcm.GcmDeviceInfo)
      GcmDeviceInfoOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        GcmDeviceInfo.class.getName());
    }
    // Use GcmDeviceInfo.newBuilder() to construct.
    private GcmDeviceInfo(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private GcmDeviceInfo() {
      gcmRegistrationId_ = com.google.protobuf.ByteString.EMPTY;
      apnRegistrationId_ = com.google.protobuf.ByteString.EMPTY;
      notificationEnabled_ = true;
      bluetoothMacAddress_ = "";
      deviceMasterKeyHash_ = com.google.protobuf.ByteString.EMPTY;
      userPublicKey_ = com.google.protobuf.ByteString.EMPTY;
      deviceModel_ = "";
      locale_ = "";
      keyHandle_ = com.google.protobuf.ByteString.EMPTY;
      deviceOsVersion_ = "";
      deviceOsRelease_ = "";
      deviceOsCodename_ = "";
      deviceSoftwareVersion_ = "";
      deviceSoftwarePackage_ = "";
      longDeviceId_ = com.google.protobuf.ByteString.EMPTY;
      deviceManufacturer_ = "";
      deviceType_ = 1;
      supportedSoftwareFeatures_ = java.util.Collections.emptyList();
      enabledSoftwareFeatures_ = java.util.Collections.emptyList();
      enrollmentSessionId_ = com.google.protobuf.ByteString.EMPTY;
      oauthToken_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.internal_static_securegcm_GcmDeviceInfo_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.internal_static_securegcm_GcmDeviceInfo_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo.class, com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo.Builder.class);
    }

    private int bitField0_;
    private int bitField1_;
    public static final int ANDROID_DEVICE_ID_FIELD_NUMBER = 1;
    private long androidDeviceId_ = 0L;
    /**
     * <pre>
     * This field's name does not match the one in DeviceInfo for legacy reasons.
     * Consider using long_device_id and device_type instead when enrolling
     * non-android devices.
     * </pre>
     *
     * <code>optional fixed64 android_device_id = 1;</code>
     * @return Whether the androidDeviceId field is set.
     */
    @java.lang.Override
    public boolean hasAndroidDeviceId() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * This field's name does not match the one in DeviceInfo for legacy reasons.
     * Consider using long_device_id and device_type instead when enrolling
     * non-android devices.
     * </pre>
     *
     * <code>optional fixed64 android_device_id = 1;</code>
     * @return The androidDeviceId.
     */
    @java.lang.Override
    public long getAndroidDeviceId() {
      return androidDeviceId_;
    }

    public static final int GCM_REGISTRATION_ID_FIELD_NUMBER = 102;
    private com.google.protobuf.ByteString gcmRegistrationId_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * Used for device_address of DeviceInfo field 2, but for GCM capable devices.
     * </pre>
     *
     * <code>optional bytes gcm_registration_id = 102;</code>
     * @return Whether the gcmRegistrationId field is set.
     */
    @java.lang.Override
    public boolean hasGcmRegistrationId() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Used for device_address of DeviceInfo field 2, but for GCM capable devices.
     * </pre>
     *
     * <code>optional bytes gcm_registration_id = 102;</code>
     * @return The gcmRegistrationId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getGcmRegistrationId() {
      return gcmRegistrationId_;
    }

    public static final int APN_REGISTRATION_ID_FIELD_NUMBER = 202;
    private com.google.protobuf.ByteString apnRegistrationId_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * Used for device_address of DeviceInfo field 2, but for iOS devices.
     * </pre>
     *
     * <code>optional bytes apn_registration_id = 202;</code>
     * @return Whether the apnRegistrationId field is set.
     */
    @java.lang.Override
    public boolean hasApnRegistrationId() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Used for device_address of DeviceInfo field 2, but for iOS devices.
     * </pre>
     *
     * <code>optional bytes apn_registration_id = 202;</code>
     * @return The apnRegistrationId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getApnRegistrationId() {
      return apnRegistrationId_;
    }

    public static final int NOTIFICATION_ENABLED_FIELD_NUMBER = 203;
    private boolean notificationEnabled_ = true;
    /**
     * <pre>
     * Does the user have notifications enabled for the given device address.
     * </pre>
     *
     * <code>optional bool notification_enabled = 203 [default = true];</code>
     * @return Whether the notificationEnabled field is set.
     */
    @java.lang.Override
    public boolean hasNotificationEnabled() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Does the user have notifications enabled for the given device address.
     * </pre>
     *
     * <code>optional bool notification_enabled = 203 [default = true];</code>
     * @return The notificationEnabled.
     */
    @java.lang.Override
    public boolean getNotificationEnabled() {
      return notificationEnabled_;
    }

    public static final int BLUETOOTH_MAC_ADDRESS_FIELD_NUMBER = 302;
    @SuppressWarnings("serial")
    private volatile java.lang.Object bluetoothMacAddress_ = "";
    /**
     * <pre>
     * Used for device_address of DeviceInfo field 2, a Bluetooth Mac address for
     * the device (e.g., to be used with EasyUnlock)
     * </pre>
     *
     * <code>optional string bluetooth_mac_address = 302;</code>
     * @return Whether the bluetoothMacAddress field is set.
     */
    @java.lang.Override
    public boolean hasBluetoothMacAddress() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Used for device_address of DeviceInfo field 2, a Bluetooth Mac address for
     * the device (e.g., to be used with EasyUnlock)
     * </pre>
     *
     * <code>optional string bluetooth_mac_address = 302;</code>
     * @return The bluetoothMacAddress.
     */
    @java.lang.Override
    public java.lang.String getBluetoothMacAddress() {
      java.lang.Object ref = bluetoothMacAddress_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          bluetoothMacAddress_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Used for device_address of DeviceInfo field 2, a Bluetooth Mac address for
     * the device (e.g., to be used with EasyUnlock)
     * </pre>
     *
     * <code>optional string bluetooth_mac_address = 302;</code>
     * @return The bytes for bluetoothMacAddress.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getBluetoothMacAddressBytes() {
      java.lang.Object ref = bluetoothMacAddress_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        bluetoothMacAddress_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int DEVICE_MASTER_KEY_HASH_FIELD_NUMBER = 103;
    private com.google.protobuf.ByteString deviceMasterKeyHash_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * SHA-256 hash of the device master key (from the key exchange).
     * Differs from DeviceInfo field 3, which contains the actual master key.
     * </pre>
     *
     * <code>optional bytes device_master_key_hash = 103;</code>
     * @return Whether the deviceMasterKeyHash field is set.
     */
    @java.lang.Override
    public boolean hasDeviceMasterKeyHash() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * SHA-256 hash of the device master key (from the key exchange).
     * Differs from DeviceInfo field 3, which contains the actual master key.
     * </pre>
     *
     * <code>optional bytes device_master_key_hash = 103;</code>
     * @return The deviceMasterKeyHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getDeviceMasterKeyHash() {
      return deviceMasterKeyHash_;
    }

    public static final int USER_PUBLIC_KEY_FIELD_NUMBER = 4;
    private com.google.protobuf.ByteString userPublicKey_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * A SecureMessage.EcP256PublicKey
     * </pre>
     *
     * <code>required bytes user_public_key = 4;</code>
     * @return Whether the userPublicKey field is set.
     */
    @java.lang.Override
    public boolean hasUserPublicKey() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * A SecureMessage.EcP256PublicKey
     * </pre>
     *
     * <code>required bytes user_public_key = 4;</code>
     * @return The userPublicKey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getUserPublicKey() {
      return userPublicKey_;
    }

    public static final int DEVICE_MODEL_FIELD_NUMBER = 7;
    @SuppressWarnings("serial")
    private volatile java.lang.Object deviceModel_ = "";
    /**
     * <pre>
     * device's model name
     * (e.g., an android.os.Build.MODEL or UIDevice.model)
     * </pre>
     *
     * <code>optional string device_model = 7;</code>
     * @return Whether the deviceModel field is set.
     */
    @java.lang.Override
    public boolean hasDeviceModel() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * device's model name
     * (e.g., an android.os.Build.MODEL or UIDevice.model)
     * </pre>
     *
     * <code>optional string device_model = 7;</code>
     * @return The deviceModel.
     */
    @java.lang.Override
    public java.lang.String getDeviceModel() {
      java.lang.Object ref = deviceModel_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          deviceModel_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * device's model name
     * (e.g., an android.os.Build.MODEL or UIDevice.model)
     * </pre>
     *
     * <code>optional string device_model = 7;</code>
     * @return The bytes for deviceModel.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDeviceModelBytes() {
      java.lang.Object ref = deviceModel_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        deviceModel_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int LOCALE_FIELD_NUMBER = 8;
    @SuppressWarnings("serial")
    private volatile java.lang.Object locale_ = "";
    /**
     * <pre>
     * device's locale
     * </pre>
     *
     * <code>optional string locale = 8;</code>
     * @return Whether the locale field is set.
     */
    @java.lang.Override
    public boolean hasLocale() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * device's locale
     * </pre>
     *
     * <code>optional string locale = 8;</code>
     * @return The locale.
     */
    @java.lang.Override
    public java.lang.String getLocale() {
      java.lang.Object ref = locale_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          locale_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * device's locale
     * </pre>
     *
     * <code>optional string locale = 8;</code>
     * @return The bytes for locale.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getLocaleBytes() {
      java.lang.Object ref = locale_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        locale_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int KEY_HANDLE_FIELD_NUMBER = 9;
    private com.google.protobuf.ByteString keyHandle_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * The handle for user_public_key (and implicitly, a master key)
     * </pre>
     *
     * <code>optional bytes key_handle = 9;</code>
     * @return Whether the keyHandle field is set.
     */
    @java.lang.Override
    public boolean hasKeyHandle() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * The handle for user_public_key (and implicitly, a master key)
     * </pre>
     *
     * <code>optional bytes key_handle = 9;</code>
     * @return The keyHandle.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getKeyHandle() {
      return keyHandle_;
    }

    public static final int COUNTER_FIELD_NUMBER = 12;
    private long counter_ = 0L;
    /**
     * <pre>
     * The initial counter value for the device, sent by the device
     * </pre>
     *
     * <code>optional int64 counter = 12 [default = 0];</code>
     * @return Whether the counter field is set.
     */
    @java.lang.Override
    public boolean hasCounter() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * The initial counter value for the device, sent by the device
     * </pre>
     *
     * <code>optional int64 counter = 12 [default = 0];</code>
     * @return The counter.
     */
    @java.lang.Override
    public long getCounter() {
      return counter_;
    }

    public static final int DEVICE_OS_VERSION_FIELD_NUMBER = 13;
    @SuppressWarnings("serial")
    private volatile java.lang.Object deviceOsVersion_ = "";
    /**
     * <pre>
     * The Operating System version on the device
     * (e.g., an android.os.Build.DISPLAY or UIDevice.systemVersion)
     * </pre>
     *
     * <code>optional string device_os_version = 13;</code>
     * @return Whether the deviceOsVersion field is set.
     */
    @java.lang.Override
    public boolean hasDeviceOsVersion() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * The Operating System version on the device
     * (e.g., an android.os.Build.DISPLAY or UIDevice.systemVersion)
     * </pre>
     *
     * <code>optional string device_os_version = 13;</code>
     * @return The deviceOsVersion.
     */
    @java.lang.Override
    public java.lang.String getDeviceOsVersion() {
      java.lang.Object ref = deviceOsVersion_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          deviceOsVersion_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The Operating System version on the device
     * (e.g., an android.os.Build.DISPLAY or UIDevice.systemVersion)
     * </pre>
     *
     * <code>optional string device_os_version = 13;</code>
     * @return The bytes for deviceOsVersion.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDeviceOsVersionBytes() {
      java.lang.Object ref = deviceOsVersion_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        deviceOsVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int DEVICE_OS_VERSION_CODE_FIELD_NUMBER = 14;
    private long deviceOsVersionCode_ = 0L;
    /**
     * <pre>
     * The Operating System version number on the device
     * (e.g., an android.os.Build.VERSION.SDK_INT)
     * </pre>
     *
     * <code>optional int64 device_os_version_code = 14;</code>
     * @return Whether the deviceOsVersionCode field is set.
     */
    @java.lang.Override
    public boolean hasDeviceOsVersionCode() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     * <pre>
     * The Operating System version number on the device
     * (e.g., an android.os.Build.VERSION.SDK_INT)
     * </pre>
     *
     * <code>optional int64 device_os_version_code = 14;</code>
     * @return The deviceOsVersionCode.
     */
    @java.lang.Override
    public long getDeviceOsVersionCode() {
      return deviceOsVersionCode_;
    }

    public static final int DEVICE_OS_RELEASE_FIELD_NUMBER = 15;
    @SuppressWarnings("serial")
    private volatile java.lang.Object deviceOsRelease_ = "";
    /**
     * <pre>
     * The Operating System release on the device
     * (e.g., an android.os.Build.VERSION.RELEASE)
     * </pre>
     *
     * <code>optional string device_os_release = 15;</code>
     * @return Whether the deviceOsRelease field is set.
     */
    @java.lang.Override
    public boolean hasDeviceOsRelease() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     * <pre>
     * The Operating System release on the device
     * (e.g., an android.os.Build.VERSION.RELEASE)
     * </pre>
     *
     * <code>optional string device_os_release = 15;</code>
     * @return The deviceOsRelease.
     */
    @java.lang.Override
    public java.lang.String getDeviceOsRelease() {
      java.lang.Object ref = deviceOsRelease_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          deviceOsRelease_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The Operating System release on the device
     * (e.g., an android.os.Build.VERSION.RELEASE)
     * </pre>
     *
     * <code>optional string device_os_release = 15;</code>
     * @return The bytes for deviceOsRelease.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDeviceOsReleaseBytes() {
      java.lang.Object ref = deviceOsRelease_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        deviceOsRelease_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int DEVICE_OS_CODENAME_FIELD_NUMBER = 16;
    @SuppressWarnings("serial")
    private volatile java.lang.Object deviceOsCodename_ = "";
    /**
     * <pre>
     * The Operating System codename on the device
     * (e.g., an android.os.Build.VERSION.CODENAME or UIDevice.systemName)
     * </pre>
     *
     * <code>optional string device_os_codename = 16;</code>
     * @return Whether the deviceOsCodename field is set.
     */
    @java.lang.Override
    public boolean hasDeviceOsCodename() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     * <pre>
     * The Operating System codename on the device
     * (e.g., an android.os.Build.VERSION.CODENAME or UIDevice.systemName)
     * </pre>
     *
     * <code>optional string device_os_codename = 16;</code>
     * @return The deviceOsCodename.
     */
    @java.lang.Override
    public java.lang.String getDeviceOsCodename() {
      java.lang.Object ref = deviceOsCodename_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          deviceOsCodename_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The Operating System codename on the device
     * (e.g., an android.os.Build.VERSION.CODENAME or UIDevice.systemName)
     * </pre>
     *
     * <code>optional string device_os_codename = 16;</code>
     * @return The bytes for deviceOsCodename.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDeviceOsCodenameBytes() {
      java.lang.Object ref = deviceOsCodename_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        deviceOsCodename_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int DEVICE_SOFTWARE_VERSION_FIELD_NUMBER = 17;
    @SuppressWarnings("serial")
    private volatile java.lang.Object deviceSoftwareVersion_ = "";
    /**
     * <pre>
     * The software version running on the device
     * (e.g., Authenticator app version string)
     * </pre>
     *
     * <code>optional string device_software_version = 17;</code>
     * @return Whether the deviceSoftwareVersion field is set.
     */
    @java.lang.Override
    public boolean hasDeviceSoftwareVersion() {
      return ((bitField0_ & 0x00008000) != 0);
    }
    /**
     * <pre>
     * The software version running on the device
     * (e.g., Authenticator app version string)
     * </pre>
     *
     * <code>optional string device_software_version = 17;</code>
     * @return The deviceSoftwareVersion.
     */
    @java.lang.Override
    public java.lang.String getDeviceSoftwareVersion() {
      java.lang.Object ref = deviceSoftwareVersion_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          deviceSoftwareVersion_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The software version running on the device
     * (e.g., Authenticator app version string)
     * </pre>
     *
     * <code>optional string device_software_version = 17;</code>
     * @return The bytes for deviceSoftwareVersion.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDeviceSoftwareVersionBytes() {
      java.lang.Object ref = deviceSoftwareVersion_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        deviceSoftwareVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int DEVICE_SOFTWARE_VERSION_CODE_FIELD_NUMBER = 18;
    private long deviceSoftwareVersionCode_ = 0L;
    /**
     * <pre>
     * The software version number running on the device
     * (e.g., Authenticator app version code)
     * </pre>
     *
     * <code>optional int64 device_software_version_code = 18;</code>
     * @return Whether the deviceSoftwareVersionCode field is set.
     */
    @java.lang.Override
    public boolean hasDeviceSoftwareVersionCode() {
      return ((bitField0_ & 0x00010000) != 0);
    }
    /**
     * <pre>
     * The software version number running on the device
     * (e.g., Authenticator app version code)
     * </pre>
     *
     * <code>optional int64 device_software_version_code = 18;</code>
     * @return The deviceSoftwareVersionCode.
     */
    @java.lang.Override
    public long getDeviceSoftwareVersionCode() {
      return deviceSoftwareVersionCode_;
    }

    public static final int DEVICE_SOFTWARE_PACKAGE_FIELD_NUMBER = 19;
    @SuppressWarnings("serial")
    private volatile java.lang.Object deviceSoftwarePackage_ = "";
    /**
     * <pre>
     * Software package information if applicable
     * (e.g., com.google.android.apps.authenticator2)
     * </pre>
     *
     * <code>optional string device_software_package = 19;</code>
     * @return Whether the deviceSoftwarePackage field is set.
     */
    @java.lang.Override
    public boolean hasDeviceSoftwarePackage() {
      return ((bitField0_ & 0x00020000) != 0);
    }
    /**
     * <pre>
     * Software package information if applicable
     * (e.g., com.google.android.apps.authenticator2)
     * </pre>
     *
     * <code>optional string device_software_package = 19;</code>
     * @return The deviceSoftwarePackage.
     */
    @java.lang.Override
    public java.lang.String getDeviceSoftwarePackage() {
      java.lang.Object ref = deviceSoftwarePackage_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          deviceSoftwarePackage_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Software package information if applicable
     * (e.g., com.google.android.apps.authenticator2)
     * </pre>
     *
     * <code>optional string device_software_package = 19;</code>
     * @return The bytes for deviceSoftwarePackage.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDeviceSoftwarePackageBytes() {
      java.lang.Object ref = deviceSoftwarePackage_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        deviceSoftwarePackage_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int DEVICE_DISPLAY_DIAGONAL_MILS_FIELD_NUMBER = 22;
    private int deviceDisplayDiagonalMils_ = 0;
    /**
     * <pre>
     * Size of the display in thousandths of an inch (e.g., 7000 mils = 7 in)
     * </pre>
     *
     * <code>optional int32 device_display_diagonal_mils = 22;</code>
     * @return Whether the deviceDisplayDiagonalMils field is set.
     */
    @java.lang.Override
    public boolean hasDeviceDisplayDiagonalMils() {
      return ((bitField0_ & 0x00040000) != 0);
    }
    /**
     * <pre>
     * Size of the display in thousandths of an inch (e.g., 7000 mils = 7 in)
     * </pre>
     *
     * <code>optional int32 device_display_diagonal_mils = 22;</code>
     * @return The deviceDisplayDiagonalMils.
     */
    @java.lang.Override
    public int getDeviceDisplayDiagonalMils() {
      return deviceDisplayDiagonalMils_;
    }

    public static final int DEVICE_AUTHZEN_VERSION_FIELD_NUMBER = 24;
    private int deviceAuthzenVersion_ = 0;
    /**
     * <pre>
     * For Authzen capable devices, their Authzen protocol version
     * </pre>
     *
     * <code>optional int32 device_authzen_version = 24;</code>
     * @return Whether the deviceAuthzenVersion field is set.
     */
    @java.lang.Override
    public boolean hasDeviceAuthzenVersion() {
      return ((bitField0_ & 0x00080000) != 0);
    }
    /**
     * <pre>
     * For Authzen capable devices, their Authzen protocol version
     * </pre>
     *
     * <code>optional int32 device_authzen_version = 24;</code>
     * @return The deviceAuthzenVersion.
     */
    @java.lang.Override
    public int getDeviceAuthzenVersion() {
      return deviceAuthzenVersion_;
    }

    public static final int LONG_DEVICE_ID_FIELD_NUMBER = 29;
    private com.google.protobuf.ByteString longDeviceId_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * Not all devices have device identifiers that fit in 64 bits.
     * </pre>
     *
     * <code>optional bytes long_device_id = 29;</code>
     * @return Whether the longDeviceId field is set.
     */
    @java.lang.Override
    public boolean hasLongDeviceId() {
      return ((bitField0_ & 0x00100000) != 0);
    }
    /**
     * <pre>
     * Not all devices have device identifiers that fit in 64 bits.
     * </pre>
     *
     * <code>optional bytes long_device_id = 29;</code>
     * @return The longDeviceId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getLongDeviceId() {
      return longDeviceId_;
    }

    public static final int DEVICE_MANUFACTURER_FIELD_NUMBER = 31;
    @SuppressWarnings("serial")
    private volatile java.lang.Object deviceManufacturer_ = "";
    /**
     * <pre>
     * The device manufacturer name
     * (e.g., android.os.Build.MANUFACTURER)
     * </pre>
     *
     * <code>optional string device_manufacturer = 31;</code>
     * @return Whether the deviceManufacturer field is set.
     */
    @java.lang.Override
    public boolean hasDeviceManufacturer() {
      return ((bitField0_ & 0x00200000) != 0);
    }
    /**
     * <pre>
     * The device manufacturer name
     * (e.g., android.os.Build.MANUFACTURER)
     * </pre>
     *
     * <code>optional string device_manufacturer = 31;</code>
     * @return The deviceManufacturer.
     */
    @java.lang.Override
    public java.lang.String getDeviceManufacturer() {
      java.lang.Object ref = deviceManufacturer_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          deviceManufacturer_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The device manufacturer name
     * (e.g., android.os.Build.MANUFACTURER)
     * </pre>
     *
     * <code>optional string device_manufacturer = 31;</code>
     * @return The bytes for deviceManufacturer.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDeviceManufacturerBytes() {
      java.lang.Object ref = deviceManufacturer_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        deviceManufacturer_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int DEVICE_TYPE_FIELD_NUMBER = 32;
    private int deviceType_ = 1;
    /**
     * <pre>
     * Used to indicate which type of device this is.
     * </pre>
     *
     * <code>optional .securegcm.DeviceType device_type = 32 [default = ANDROID];</code>
     * @return Whether the deviceType field is set.
     */
    @java.lang.Override public boolean hasDeviceType() {
      return ((bitField0_ & 0x00400000) != 0);
    }
    /**
     * <pre>
     * Used to indicate which type of device this is.
     * </pre>
     *
     * <code>optional .securegcm.DeviceType device_type = 32 [default = ANDROID];</code>
     * @return The deviceType.
     */
    @java.lang.Override public com.google.security.cryptauth.lib.securegcm.SecureGcmProto.DeviceType getDeviceType() {
      com.google.security.cryptauth.lib.securegcm.SecureGcmProto.DeviceType result = com.google.security.cryptauth.lib.securegcm.SecureGcmProto.DeviceType.forNumber(deviceType_);
      return result == null ? com.google.security.cryptauth.lib.securegcm.SecureGcmProto.DeviceType.ANDROID : result;
    }

    public static final int USING_SECURE_SCREENLOCK_FIELD_NUMBER = 400;
    private boolean usingSecureScreenlock_ = false;
    /**
     * <pre>
     * Is this device using  a secure screenlock (e.g., pattern or pin unlock)
     * </pre>
     *
     * <code>optional bool using_secure_screenlock = 400 [default = false];</code>
     * @return Whether the usingSecureScreenlock field is set.
     */
    @java.lang.Override
    public boolean hasUsingSecureScreenlock() {
      return ((bitField0_ & 0x00800000) != 0);
    }
    /**
     * <pre>
     * Is this device using  a secure screenlock (e.g., pattern or pin unlock)
     * </pre>
     *
     * <code>optional bool using_secure_screenlock = 400 [default = false];</code>
     * @return The usingSecureScreenlock.
     */
    @java.lang.Override
    public boolean getUsingSecureScreenlock() {
      return usingSecureScreenlock_;
    }

    public static final int AUTO_UNLOCK_SCREENLOCK_SUPPORTED_FIELD_NUMBER = 401;
    private boolean autoUnlockScreenlockSupported_ = false;
    /**
     * <pre>
     * Is auto-unlocking the screenlock (e.g., when at "home") supported?
     * </pre>
     *
     * <code>optional bool auto_unlock_screenlock_supported = 401 [default = false];</code>
     * @return Whether the autoUnlockScreenlockSupported field is set.
     */
    @java.lang.Override
    public boolean hasAutoUnlockScreenlockSupported() {
      return ((bitField0_ & 0x01000000) != 0);
    }
    /**
     * <pre>
     * Is auto-unlocking the screenlock (e.g., when at "home") supported?
     * </pre>
     *
     * <code>optional bool auto_unlock_screenlock_supported = 401 [default = false];</code>
     * @return The autoUnlockScreenlockSupported.
     */
    @java.lang.Override
    public boolean getAutoUnlockScreenlockSupported() {
      return autoUnlockScreenlockSupported_;
    }

    public static final int AUTO_UNLOCK_SCREENLOCK_ENABLED_FIELD_NUMBER = 402;
    private boolean autoUnlockScreenlockEnabled_ = false;
    /**
     * <pre>
     * Is auto-unlocking the screenlock (e.g., when at "home") enabled?
     * </pre>
     *
     * <code>optional bool auto_unlock_screenlock_enabled = 402 [default = false];</code>
     * @return Whether the autoUnlockScreenlockEnabled field is set.
     */
    @java.lang.Override
    public boolean hasAutoUnlockScreenlockEnabled() {
      return ((bitField0_ & 0x02000000) != 0);
    }
    /**
     * <pre>
     * Is auto-unlocking the screenlock (e.g., when at "home") enabled?
     * </pre>
     *
     * <code>optional bool auto_unlock_screenlock_enabled = 402 [default = false];</code>
     * @return The autoUnlockScreenlockEnabled.
     */
    @java.lang.Override
    public boolean getAutoUnlockScreenlockEnabled() {
      return autoUnlockScreenlockEnabled_;
    }

    public static final int BLUETOOTH_RADIO_SUPPORTED_FIELD_NUMBER = 403;
    private boolean bluetoothRadioSupported_ = false;
    /**
     * <pre>
     * Does the device have a Bluetooth (classic) radio?
     * </pre>
     *
     * <code>optional bool bluetooth_radio_supported = 403 [default = false];</code>
     * @return Whether the bluetoothRadioSupported field is set.
     */
    @java.lang.Override
    public boolean hasBluetoothRadioSupported() {
      return ((bitField0_ & 0x04000000) != 0);
    }
    /**
     * <pre>
     * Does the device have a Bluetooth (classic) radio?
     * </pre>
     *
     * <code>optional bool bluetooth_radio_supported = 403 [default = false];</code>
     * @return The bluetoothRadioSupported.
     */
    @java.lang.Override
    public boolean getBluetoothRadioSupported() {
      return bluetoothRadioSupported_;
    }

    public static final int BLUETOOTH_RADIO_ENABLED_FIELD_NUMBER = 404;
    private boolean bluetoothRadioEnabled_ = false;
    /**
     * <pre>
     * Is the Bluetooth (classic) radio on?
     * </pre>
     *
     * <code>optional bool bluetooth_radio_enabled = 404 [default = false];</code>
     * @return Whether the bluetoothRadioEnabled field is set.
     */
    @java.lang.Override
    public boolean hasBluetoothRadioEnabled() {
      return ((bitField0_ & 0x08000000) != 0);
    }
    /**
     * <pre>
     * Is the Bluetooth (classic) radio on?
     * </pre>
     *
     * <code>optional bool bluetooth_radio_enabled = 404 [default = false];</code>
     * @return The bluetoothRadioEnabled.
     */
    @java.lang.Override
    public boolean getBluetoothRadioEnabled() {
      return bluetoothRadioEnabled_;
    }

    public static final int MOBILE_DATA_SUPPORTED_FIELD_NUMBER = 405;
    private boolean mobileDataSupported_ = false;
    /**
     * <pre>
     * Does the device hardware support a mobile data connection?
     * </pre>
     *
     * <code>optional bool mobile_data_supported = 405 [default = false];</code>
     * @return Whether the mobileDataSupported field is set.
     */
    @java.lang.Override
    public boolean hasMobileDataSupported() {
      return ((bitField0_ & 0x10000000) != 0);
    }
    /**
     * <pre>
     * Does the device hardware support a mobile data connection?
     * </pre>
     *
     * <code>optional bool mobile_data_supported = 405 [default = false];</code>
     * @return The mobileDataSupported.
     */
    @java.lang.Override
    public boolean getMobileDataSupported() {
      return mobileDataSupported_;
    }

    public static final int TETHERING_SUPPORTED_FIELD_NUMBER = 406;
    private boolean tetheringSupported_ = false;
    /**
     * <pre>
     * Does the device support tethering?
     * </pre>
     *
     * <code>optional bool tethering_supported = 406 [default = false];</code>
     * @return Whether the tetheringSupported field is set.
     */
    @java.lang.Override
    public boolean hasTetheringSupported() {
      return ((bitField0_ & 0x20000000) != 0);
    }
    /**
     * <pre>
     * Does the device support tethering?
     * </pre>
     *
     * <code>optional bool tethering_supported = 406 [default = false];</code>
     * @return The tetheringSupported.
     */
    @java.lang.Override
    public boolean getTetheringSupported() {
      return tetheringSupported_;
    }

    public static final int BLE_RADIO_SUPPORTED_FIELD_NUMBER = 407;
    private boolean bleRadioSupported_ = false;
    /**
     * <pre>
     * Does the device have a BLE radio?
     * </pre>
     *
     * <code>optional bool ble_radio_supported = 407 [default = false];</code>
     * @return Whether the bleRadioSupported field is set.
     */
    @java.lang.Override
    public boolean hasBleRadioSupported() {
      return ((bitField0_ & 0x40000000) != 0);
    }
    /**
     * <pre>
     * Does the device have a BLE radio?
     * </pre>
     *
     * <code>optional bool ble_radio_supported = 407 [default = false];</code>
     * @return The bleRadioSupported.
     */
    @java.lang.Override
    public boolean getBleRadioSupported() {
      return bleRadioSupported_;
    }

    public static final int PIXEL_EXPERIENCE_FIELD_NUMBER = 408;
    private boolean pixelExperience_ = false;
    /**
     * <pre>
     * Is the device a "Pixel Experience" Android device?
     * </pre>
     *
     * <code>optional bool pixel_experience = 408 [default = false];</code>
     * @return Whether the pixelExperience field is set.
     */
    @java.lang.Override
    public boolean hasPixelExperience() {
      return ((bitField0_ & 0x80000000) != 0);
    }
    /**
     * <pre>
     * Is the device a "Pixel Experience" Android device?
     * </pre>
     *
     * <code>optional bool pixel_experience = 408 [default = false];</code>
     * @return The pixelExperience.
     */
    @java.lang.Override
    public boolean getPixelExperience() {
      return pixelExperience_;
    }

    public static final int ARC_PLUS_PLUS_FIELD_NUMBER = 409;
    private boolean arcPlusPlus_ = false;
    /**
     * <pre>
     * Is the device running in the ARC++ container on a chromebook?
     * </pre>
     *
     * <code>optional bool arc_plus_plus = 409 [default = false];</code>
     * @return Whether the arcPlusPlus field is set.
     */
    @java.lang.Override
    public boolean hasArcPlusPlus() {
      return ((bitField1_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Is the device running in the ARC++ container on a chromebook?
     * </pre>
     *
     * <code>optional bool arc_plus_plus = 409 [default = false];</code>
     * @return The arcPlusPlus.
     */
    @java.lang.Override
    public boolean getArcPlusPlus() {
      return arcPlusPlus_;
    }

    public static final int IS_SCREENLOCK_STATE_FLAKY_FIELD_NUMBER = 410;
    private boolean isScreenlockStateFlaky_ = false;
    /**
     * <pre>
     * Is the value set in |using_secure_screenlock| reliable? On some Android
     * devices, the platform API to get the screenlock state is not trustworthy.
     * See b/32212161.
     * </pre>
     *
     * <code>optional bool is_screenlock_state_flaky = 410 [default = false];</code>
     * @return Whether the isScreenlockStateFlaky field is set.
     */
    @java.lang.Override
    public boolean hasIsScreenlockStateFlaky() {
      return ((bitField1_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Is the value set in |using_secure_screenlock| reliable? On some Android
     * devices, the platform API to get the screenlock state is not trustworthy.
     * See b/32212161.
     * </pre>
     *
     * <code>optional bool is_screenlock_state_flaky = 410 [default = false];</code>
     * @return The isScreenlockStateFlaky.
     */
    @java.lang.Override
    public boolean getIsScreenlockStateFlaky() {
      return isScreenlockStateFlaky_;
    }

    public static final int SUPPORTED_SOFTWARE_FEATURES_FIELD_NUMBER = 411;
    @SuppressWarnings("serial")
    private java.util.List<java.lang.Integer> supportedSoftwareFeatures_;
    private static final com.google.protobuf.Internal.ListAdapter.Converter<
        java.lang.Integer, com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature> supportedSoftwareFeatures_converter_ =
            new com.google.protobuf.Internal.ListAdapter.Converter<
                java.lang.Integer, com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature>() {
              public com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature convert(java.lang.Integer from) {
                com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature result = com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature.forNumber(from);
                return result == null ? com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature.UNKNOWN_FEATURE : result;
              }
            };
    /**
     * <pre>
     * A list of multi-device software features supported by the device.
     * </pre>
     *
     * <code>repeated .securegcm.SoftwareFeature supported_software_features = 411;</code>
     * @return A list containing the supportedSoftwareFeatures.
     */
    @java.lang.Override
    public java.util.List<com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature> getSupportedSoftwareFeaturesList() {
      return new com.google.protobuf.Internal.ListAdapter<
          java.lang.Integer, com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature>(supportedSoftwareFeatures_, supportedSoftwareFeatures_converter_);
    }
    /**
     * <pre>
     * A list of multi-device software features supported by the device.
     * </pre>
     *
     * <code>repeated .securegcm.SoftwareFeature supported_software_features = 411;</code>
     * @return The count of supportedSoftwareFeatures.
     */
    @java.lang.Override
    public int getSupportedSoftwareFeaturesCount() {
      return supportedSoftwareFeatures_.size();
    }
    /**
     * <pre>
     * A list of multi-device software features supported by the device.
     * </pre>
     *
     * <code>repeated .securegcm.SoftwareFeature supported_software_features = 411;</code>
     * @param index The index of the element to return.
     * @return The supportedSoftwareFeatures at the given index.
     */
    @java.lang.Override
    public com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature getSupportedSoftwareFeatures(int index) {
      return supportedSoftwareFeatures_converter_.convert(supportedSoftwareFeatures_.get(index));
    }

    public static final int ENABLED_SOFTWARE_FEATURES_FIELD_NUMBER = 412;
    @SuppressWarnings("serial")
    private java.util.List<java.lang.Integer> enabledSoftwareFeatures_;
    private static final com.google.protobuf.Internal.ListAdapter.Converter<
        java.lang.Integer, com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature> enabledSoftwareFeatures_converter_ =
            new com.google.protobuf.Internal.ListAdapter.Converter<
                java.lang.Integer, com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature>() {
              public com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature convert(java.lang.Integer from) {
                com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature result = com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature.forNumber(from);
                return result == null ? com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature.UNKNOWN_FEATURE : result;
              }
            };
    /**
     * <pre>
     * A list of multi-device software features currently enabled (active) on the
     * device.
     * </pre>
     *
     * <code>repeated .securegcm.SoftwareFeature enabled_software_features = 412;</code>
     * @return A list containing the enabledSoftwareFeatures.
     */
    @java.lang.Override
    public java.util.List<com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature> getEnabledSoftwareFeaturesList() {
      return new com.google.protobuf.Internal.ListAdapter<
          java.lang.Integer, com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature>(enabledSoftwareFeatures_, enabledSoftwareFeatures_converter_);
    }
    /**
     * <pre>
     * A list of multi-device software features currently enabled (active) on the
     * device.
     * </pre>
     *
     * <code>repeated .securegcm.SoftwareFeature enabled_software_features = 412;</code>
     * @return The count of enabledSoftwareFeatures.
     */
    @java.lang.Override
    public int getEnabledSoftwareFeaturesCount() {
      return enabledSoftwareFeatures_.size();
    }
    /**
     * <pre>
     * A list of multi-device software features currently enabled (active) on the
     * device.
     * </pre>
     *
     * <code>repeated .securegcm.SoftwareFeature enabled_software_features = 412;</code>
     * @param index The index of the element to return.
     * @return The enabledSoftwareFeatures at the given index.
     */
    @java.lang.Override
    public com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature getEnabledSoftwareFeatures(int index) {
      return enabledSoftwareFeatures_converter_.convert(enabledSoftwareFeatures_.get(index));
    }

    public static final int ENROLLMENT_SESSION_ID_FIELD_NUMBER = 1000;
    private com.google.protobuf.ByteString enrollmentSessionId_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * The enrollment session id this is sent with
     * </pre>
     *
     * <code>optional bytes enrollment_session_id = 1000;</code>
     * @return Whether the enrollmentSessionId field is set.
     */
    @java.lang.Override
    public boolean hasEnrollmentSessionId() {
      return ((bitField1_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The enrollment session id this is sent with
     * </pre>
     *
     * <code>optional bytes enrollment_session_id = 1000;</code>
     * @return The enrollmentSessionId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getEnrollmentSessionId() {
      return enrollmentSessionId_;
    }

    public static final int OAUTH_TOKEN_FIELD_NUMBER = 1001;
    @SuppressWarnings("serial")
    private volatile java.lang.Object oauthToken_ = "";
    /**
     * <pre>
     * A copy of the user's OAuth token
     * </pre>
     *
     * <code>optional string oauth_token = 1001;</code>
     * @return Whether the oauthToken field is set.
     */
    @java.lang.Override
    public boolean hasOauthToken() {
      return ((bitField1_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * A copy of the user's OAuth token
     * </pre>
     *
     * <code>optional string oauth_token = 1001;</code>
     * @return The oauthToken.
     */
    @java.lang.Override
    public java.lang.String getOauthToken() {
      java.lang.Object ref = oauthToken_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          oauthToken_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * A copy of the user's OAuth token
     * </pre>
     *
     * <code>optional string oauth_token = 1001;</code>
     * @return The bytes for oauthToken.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getOauthTokenBytes() {
      java.lang.Object ref = oauthToken_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        oauthToken_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasUserPublicKey()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeFixed64(1, androidDeviceId_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeBytes(4, userPublicKey_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 7, deviceModel_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 8, locale_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeBytes(9, keyHandle_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        output.writeInt64(12, counter_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 13, deviceOsVersion_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        output.writeInt64(14, deviceOsVersionCode_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 15, deviceOsRelease_);
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 16, deviceOsCodename_);
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 17, deviceSoftwareVersion_);
      }
      if (((bitField0_ & 0x00010000) != 0)) {
        output.writeInt64(18, deviceSoftwareVersionCode_);
      }
      if (((bitField0_ & 0x00020000) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 19, deviceSoftwarePackage_);
      }
      if (((bitField0_ & 0x00040000) != 0)) {
        output.writeInt32(22, deviceDisplayDiagonalMils_);
      }
      if (((bitField0_ & 0x00080000) != 0)) {
        output.writeInt32(24, deviceAuthzenVersion_);
      }
      if (((bitField0_ & 0x00100000) != 0)) {
        output.writeBytes(29, longDeviceId_);
      }
      if (((bitField0_ & 0x00200000) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 31, deviceManufacturer_);
      }
      if (((bitField0_ & 0x00400000) != 0)) {
        output.writeEnum(32, deviceType_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeBytes(102, gcmRegistrationId_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeBytes(103, deviceMasterKeyHash_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeBytes(202, apnRegistrationId_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeBool(203, notificationEnabled_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 302, bluetoothMacAddress_);
      }
      if (((bitField0_ & 0x00800000) != 0)) {
        output.writeBool(400, usingSecureScreenlock_);
      }
      if (((bitField0_ & 0x01000000) != 0)) {
        output.writeBool(401, autoUnlockScreenlockSupported_);
      }
      if (((bitField0_ & 0x02000000) != 0)) {
        output.writeBool(402, autoUnlockScreenlockEnabled_);
      }
      if (((bitField0_ & 0x04000000) != 0)) {
        output.writeBool(403, bluetoothRadioSupported_);
      }
      if (((bitField0_ & 0x08000000) != 0)) {
        output.writeBool(404, bluetoothRadioEnabled_);
      }
      if (((bitField0_ & 0x10000000) != 0)) {
        output.writeBool(405, mobileDataSupported_);
      }
      if (((bitField0_ & 0x20000000) != 0)) {
        output.writeBool(406, tetheringSupported_);
      }
      if (((bitField0_ & 0x40000000) != 0)) {
        output.writeBool(407, bleRadioSupported_);
      }
      if (((bitField0_ & 0x80000000) != 0)) {
        output.writeBool(408, pixelExperience_);
      }
      if (((bitField1_ & 0x00000001) != 0)) {
        output.writeBool(409, arcPlusPlus_);
      }
      if (((bitField1_ & 0x00000002) != 0)) {
        output.writeBool(410, isScreenlockStateFlaky_);
      }
      for (int i = 0; i < supportedSoftwareFeatures_.size(); i++) {
        output.writeEnum(411, supportedSoftwareFeatures_.get(i));
      }
      for (int i = 0; i < enabledSoftwareFeatures_.size(); i++) {
        output.writeEnum(412, enabledSoftwareFeatures_.get(i));
      }
      if (((bitField1_ & 0x00000004) != 0)) {
        output.writeBytes(1000, enrollmentSessionId_);
      }
      if (((bitField1_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1001, oauthToken_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFixed64Size(1, androidDeviceId_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(4, userPublicKey_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(7, deviceModel_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(8, locale_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(9, keyHandle_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(12, counter_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(13, deviceOsVersion_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(14, deviceOsVersionCode_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(15, deviceOsRelease_);
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(16, deviceOsCodename_);
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(17, deviceSoftwareVersion_);
      }
      if (((bitField0_ & 0x00010000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(18, deviceSoftwareVersionCode_);
      }
      if (((bitField0_ & 0x00020000) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(19, deviceSoftwarePackage_);
      }
      if (((bitField0_ & 0x00040000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(22, deviceDisplayDiagonalMils_);
      }
      if (((bitField0_ & 0x00080000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(24, deviceAuthzenVersion_);
      }
      if (((bitField0_ & 0x00100000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(29, longDeviceId_);
      }
      if (((bitField0_ & 0x00200000) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(31, deviceManufacturer_);
      }
      if (((bitField0_ & 0x00400000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(32, deviceType_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(102, gcmRegistrationId_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(103, deviceMasterKeyHash_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(202, apnRegistrationId_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(203, notificationEnabled_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(302, bluetoothMacAddress_);
      }
      if (((bitField0_ & 0x00800000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(400, usingSecureScreenlock_);
      }
      if (((bitField0_ & 0x01000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(401, autoUnlockScreenlockSupported_);
      }
      if (((bitField0_ & 0x02000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(402, autoUnlockScreenlockEnabled_);
      }
      if (((bitField0_ & 0x04000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(403, bluetoothRadioSupported_);
      }
      if (((bitField0_ & 0x08000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(404, bluetoothRadioEnabled_);
      }
      if (((bitField0_ & 0x10000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(405, mobileDataSupported_);
      }
      if (((bitField0_ & 0x20000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(406, tetheringSupported_);
      }
      if (((bitField0_ & 0x40000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(407, bleRadioSupported_);
      }
      if (((bitField0_ & 0x80000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(408, pixelExperience_);
      }
      if (((bitField1_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(409, arcPlusPlus_);
      }
      if (((bitField1_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(410, isScreenlockStateFlaky_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < supportedSoftwareFeatures_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeEnumSizeNoTag(supportedSoftwareFeatures_.get(i));
        }
        size += dataSize;
        size += 2 * supportedSoftwareFeatures_.size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < enabledSoftwareFeatures_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeEnumSizeNoTag(enabledSoftwareFeatures_.get(i));
        }
        size += dataSize;
        size += 2 * enabledSoftwareFeatures_.size();
      }
      if (((bitField1_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1000, enrollmentSessionId_);
      }
      if (((bitField1_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1001, oauthToken_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo)) {
        return super.equals(obj);
      }
      com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo other = (com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo) obj;

      if (hasAndroidDeviceId() != other.hasAndroidDeviceId()) return false;
      if (hasAndroidDeviceId()) {
        if (getAndroidDeviceId()
            != other.getAndroidDeviceId()) return false;
      }
      if (hasGcmRegistrationId() != other.hasGcmRegistrationId()) return false;
      if (hasGcmRegistrationId()) {
        if (!getGcmRegistrationId()
            .equals(other.getGcmRegistrationId())) return false;
      }
      if (hasApnRegistrationId() != other.hasApnRegistrationId()) return false;
      if (hasApnRegistrationId()) {
        if (!getApnRegistrationId()
            .equals(other.getApnRegistrationId())) return false;
      }
      if (hasNotificationEnabled() != other.hasNotificationEnabled()) return false;
      if (hasNotificationEnabled()) {
        if (getNotificationEnabled()
            != other.getNotificationEnabled()) return false;
      }
      if (hasBluetoothMacAddress() != other.hasBluetoothMacAddress()) return false;
      if (hasBluetoothMacAddress()) {
        if (!getBluetoothMacAddress()
            .equals(other.getBluetoothMacAddress())) return false;
      }
      if (hasDeviceMasterKeyHash() != other.hasDeviceMasterKeyHash()) return false;
      if (hasDeviceMasterKeyHash()) {
        if (!getDeviceMasterKeyHash()
            .equals(other.getDeviceMasterKeyHash())) return false;
      }
      if (hasUserPublicKey() != other.hasUserPublicKey()) return false;
      if (hasUserPublicKey()) {
        if (!getUserPublicKey()
            .equals(other.getUserPublicKey())) return false;
      }
      if (hasDeviceModel() != other.hasDeviceModel()) return false;
      if (hasDeviceModel()) {
        if (!getDeviceModel()
            .equals(other.getDeviceModel())) return false;
      }
      if (hasLocale() != other.hasLocale()) return false;
      if (hasLocale()) {
        if (!getLocale()
            .equals(other.getLocale())) return false;
      }
      if (hasKeyHandle() != other.hasKeyHandle()) return false;
      if (hasKeyHandle()) {
        if (!getKeyHandle()
            .equals(other.getKeyHandle())) return false;
      }
      if (hasCounter() != other.hasCounter()) return false;
      if (hasCounter()) {
        if (getCounter()
            != other.getCounter()) return false;
      }
      if (hasDeviceOsVersion() != other.hasDeviceOsVersion()) return false;
      if (hasDeviceOsVersion()) {
        if (!getDeviceOsVersion()
            .equals(other.getDeviceOsVersion())) return false;
      }
      if (hasDeviceOsVersionCode() != other.hasDeviceOsVersionCode()) return false;
      if (hasDeviceOsVersionCode()) {
        if (getDeviceOsVersionCode()
            != other.getDeviceOsVersionCode()) return false;
      }
      if (hasDeviceOsRelease() != other.hasDeviceOsRelease()) return false;
      if (hasDeviceOsRelease()) {
        if (!getDeviceOsRelease()
            .equals(other.getDeviceOsRelease())) return false;
      }
      if (hasDeviceOsCodename() != other.hasDeviceOsCodename()) return false;
      if (hasDeviceOsCodename()) {
        if (!getDeviceOsCodename()
            .equals(other.getDeviceOsCodename())) return false;
      }
      if (hasDeviceSoftwareVersion() != other.hasDeviceSoftwareVersion()) return false;
      if (hasDeviceSoftwareVersion()) {
        if (!getDeviceSoftwareVersion()
            .equals(other.getDeviceSoftwareVersion())) return false;
      }
      if (hasDeviceSoftwareVersionCode() != other.hasDeviceSoftwareVersionCode()) return false;
      if (hasDeviceSoftwareVersionCode()) {
        if (getDeviceSoftwareVersionCode()
            != other.getDeviceSoftwareVersionCode()) return false;
      }
      if (hasDeviceSoftwarePackage() != other.hasDeviceSoftwarePackage()) return false;
      if (hasDeviceSoftwarePackage()) {
        if (!getDeviceSoftwarePackage()
            .equals(other.getDeviceSoftwarePackage())) return false;
      }
      if (hasDeviceDisplayDiagonalMils() != other.hasDeviceDisplayDiagonalMils()) return false;
      if (hasDeviceDisplayDiagonalMils()) {
        if (getDeviceDisplayDiagonalMils()
            != other.getDeviceDisplayDiagonalMils()) return false;
      }
      if (hasDeviceAuthzenVersion() != other.hasDeviceAuthzenVersion()) return false;
      if (hasDeviceAuthzenVersion()) {
        if (getDeviceAuthzenVersion()
            != other.getDeviceAuthzenVersion()) return false;
      }
      if (hasLongDeviceId() != other.hasLongDeviceId()) return false;
      if (hasLongDeviceId()) {
        if (!getLongDeviceId()
            .equals(other.getLongDeviceId())) return false;
      }
      if (hasDeviceManufacturer() != other.hasDeviceManufacturer()) return false;
      if (hasDeviceManufacturer()) {
        if (!getDeviceManufacturer()
            .equals(other.getDeviceManufacturer())) return false;
      }
      if (hasDeviceType() != other.hasDeviceType()) return false;
      if (hasDeviceType()) {
        if (deviceType_ != other.deviceType_) return false;
      }
      if (hasUsingSecureScreenlock() != other.hasUsingSecureScreenlock()) return false;
      if (hasUsingSecureScreenlock()) {
        if (getUsingSecureScreenlock()
            != other.getUsingSecureScreenlock()) return false;
      }
      if (hasAutoUnlockScreenlockSupported() != other.hasAutoUnlockScreenlockSupported()) return false;
      if (hasAutoUnlockScreenlockSupported()) {
        if (getAutoUnlockScreenlockSupported()
            != other.getAutoUnlockScreenlockSupported()) return false;
      }
      if (hasAutoUnlockScreenlockEnabled() != other.hasAutoUnlockScreenlockEnabled()) return false;
      if (hasAutoUnlockScreenlockEnabled()) {
        if (getAutoUnlockScreenlockEnabled()
            != other.getAutoUnlockScreenlockEnabled()) return false;
      }
      if (hasBluetoothRadioSupported() != other.hasBluetoothRadioSupported()) return false;
      if (hasBluetoothRadioSupported()) {
        if (getBluetoothRadioSupported()
            != other.getBluetoothRadioSupported()) return false;
      }
      if (hasBluetoothRadioEnabled() != other.hasBluetoothRadioEnabled()) return false;
      if (hasBluetoothRadioEnabled()) {
        if (getBluetoothRadioEnabled()
            != other.getBluetoothRadioEnabled()) return false;
      }
      if (hasMobileDataSupported() != other.hasMobileDataSupported()) return false;
      if (hasMobileDataSupported()) {
        if (getMobileDataSupported()
            != other.getMobileDataSupported()) return false;
      }
      if (hasTetheringSupported() != other.hasTetheringSupported()) return false;
      if (hasTetheringSupported()) {
        if (getTetheringSupported()
            != other.getTetheringSupported()) return false;
      }
      if (hasBleRadioSupported() != other.hasBleRadioSupported()) return false;
      if (hasBleRadioSupported()) {
        if (getBleRadioSupported()
            != other.getBleRadioSupported()) return false;
      }
      if (hasPixelExperience() != other.hasPixelExperience()) return false;
      if (hasPixelExperience()) {
        if (getPixelExperience()
            != other.getPixelExperience()) return false;
      }
      if (hasArcPlusPlus() != other.hasArcPlusPlus()) return false;
      if (hasArcPlusPlus()) {
        if (getArcPlusPlus()
            != other.getArcPlusPlus()) return false;
      }
      if (hasIsScreenlockStateFlaky() != other.hasIsScreenlockStateFlaky()) return false;
      if (hasIsScreenlockStateFlaky()) {
        if (getIsScreenlockStateFlaky()
            != other.getIsScreenlockStateFlaky()) return false;
      }
      if (!supportedSoftwareFeatures_.equals(other.supportedSoftwareFeatures_)) return false;
      if (!enabledSoftwareFeatures_.equals(other.enabledSoftwareFeatures_)) return false;
      if (hasEnrollmentSessionId() != other.hasEnrollmentSessionId()) return false;
      if (hasEnrollmentSessionId()) {
        if (!getEnrollmentSessionId()
            .equals(other.getEnrollmentSessionId())) return false;
      }
      if (hasOauthToken() != other.hasOauthToken()) return false;
      if (hasOauthToken()) {
        if (!getOauthToken()
            .equals(other.getOauthToken())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasAndroidDeviceId()) {
        hash = (37 * hash) + ANDROID_DEVICE_ID_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getAndroidDeviceId());
      }
      if (hasGcmRegistrationId()) {
        hash = (37 * hash) + GCM_REGISTRATION_ID_FIELD_NUMBER;
        hash = (53 * hash) + getGcmRegistrationId().hashCode();
      }
      if (hasApnRegistrationId()) {
        hash = (37 * hash) + APN_REGISTRATION_ID_FIELD_NUMBER;
        hash = (53 * hash) + getApnRegistrationId().hashCode();
      }
      if (hasNotificationEnabled()) {
        hash = (37 * hash) + NOTIFICATION_ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getNotificationEnabled());
      }
      if (hasBluetoothMacAddress()) {
        hash = (37 * hash) + BLUETOOTH_MAC_ADDRESS_FIELD_NUMBER;
        hash = (53 * hash) + getBluetoothMacAddress().hashCode();
      }
      if (hasDeviceMasterKeyHash()) {
        hash = (37 * hash) + DEVICE_MASTER_KEY_HASH_FIELD_NUMBER;
        hash = (53 * hash) + getDeviceMasterKeyHash().hashCode();
      }
      if (hasUserPublicKey()) {
        hash = (37 * hash) + USER_PUBLIC_KEY_FIELD_NUMBER;
        hash = (53 * hash) + getUserPublicKey().hashCode();
      }
      if (hasDeviceModel()) {
        hash = (37 * hash) + DEVICE_MODEL_FIELD_NUMBER;
        hash = (53 * hash) + getDeviceModel().hashCode();
      }
      if (hasLocale()) {
        hash = (37 * hash) + LOCALE_FIELD_NUMBER;
        hash = (53 * hash) + getLocale().hashCode();
      }
      if (hasKeyHandle()) {
        hash = (37 * hash) + KEY_HANDLE_FIELD_NUMBER;
        hash = (53 * hash) + getKeyHandle().hashCode();
      }
      if (hasCounter()) {
        hash = (37 * hash) + COUNTER_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getCounter());
      }
      if (hasDeviceOsVersion()) {
        hash = (37 * hash) + DEVICE_OS_VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getDeviceOsVersion().hashCode();
      }
      if (hasDeviceOsVersionCode()) {
        hash = (37 * hash) + DEVICE_OS_VERSION_CODE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getDeviceOsVersionCode());
      }
      if (hasDeviceOsRelease()) {
        hash = (37 * hash) + DEVICE_OS_RELEASE_FIELD_NUMBER;
        hash = (53 * hash) + getDeviceOsRelease().hashCode();
      }
      if (hasDeviceOsCodename()) {
        hash = (37 * hash) + DEVICE_OS_CODENAME_FIELD_NUMBER;
        hash = (53 * hash) + getDeviceOsCodename().hashCode();
      }
      if (hasDeviceSoftwareVersion()) {
        hash = (37 * hash) + DEVICE_SOFTWARE_VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getDeviceSoftwareVersion().hashCode();
      }
      if (hasDeviceSoftwareVersionCode()) {
        hash = (37 * hash) + DEVICE_SOFTWARE_VERSION_CODE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getDeviceSoftwareVersionCode());
      }
      if (hasDeviceSoftwarePackage()) {
        hash = (37 * hash) + DEVICE_SOFTWARE_PACKAGE_FIELD_NUMBER;
        hash = (53 * hash) + getDeviceSoftwarePackage().hashCode();
      }
      if (hasDeviceDisplayDiagonalMils()) {
        hash = (37 * hash) + DEVICE_DISPLAY_DIAGONAL_MILS_FIELD_NUMBER;
        hash = (53 * hash) + getDeviceDisplayDiagonalMils();
      }
      if (hasDeviceAuthzenVersion()) {
        hash = (37 * hash) + DEVICE_AUTHZEN_VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getDeviceAuthzenVersion();
      }
      if (hasLongDeviceId()) {
        hash = (37 * hash) + LONG_DEVICE_ID_FIELD_NUMBER;
        hash = (53 * hash) + getLongDeviceId().hashCode();
      }
      if (hasDeviceManufacturer()) {
        hash = (37 * hash) + DEVICE_MANUFACTURER_FIELD_NUMBER;
        hash = (53 * hash) + getDeviceManufacturer().hashCode();
      }
      if (hasDeviceType()) {
        hash = (37 * hash) + DEVICE_TYPE_FIELD_NUMBER;
        hash = (53 * hash) + deviceType_;
      }
      if (hasUsingSecureScreenlock()) {
        hash = (37 * hash) + USING_SECURE_SCREENLOCK_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUsingSecureScreenlock());
      }
      if (hasAutoUnlockScreenlockSupported()) {
        hash = (37 * hash) + AUTO_UNLOCK_SCREENLOCK_SUPPORTED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getAutoUnlockScreenlockSupported());
      }
      if (hasAutoUnlockScreenlockEnabled()) {
        hash = (37 * hash) + AUTO_UNLOCK_SCREENLOCK_ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getAutoUnlockScreenlockEnabled());
      }
      if (hasBluetoothRadioSupported()) {
        hash = (37 * hash) + BLUETOOTH_RADIO_SUPPORTED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getBluetoothRadioSupported());
      }
      if (hasBluetoothRadioEnabled()) {
        hash = (37 * hash) + BLUETOOTH_RADIO_ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getBluetoothRadioEnabled());
      }
      if (hasMobileDataSupported()) {
        hash = (37 * hash) + MOBILE_DATA_SUPPORTED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getMobileDataSupported());
      }
      if (hasTetheringSupported()) {
        hash = (37 * hash) + TETHERING_SUPPORTED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getTetheringSupported());
      }
      if (hasBleRadioSupported()) {
        hash = (37 * hash) + BLE_RADIO_SUPPORTED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getBleRadioSupported());
      }
      if (hasPixelExperience()) {
        hash = (37 * hash) + PIXEL_EXPERIENCE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getPixelExperience());
      }
      if (hasArcPlusPlus()) {
        hash = (37 * hash) + ARC_PLUS_PLUS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getArcPlusPlus());
      }
      if (hasIsScreenlockStateFlaky()) {
        hash = (37 * hash) + IS_SCREENLOCK_STATE_FLAKY_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getIsScreenlockStateFlaky());
      }
      if (getSupportedSoftwareFeaturesCount() > 0) {
        hash = (37 * hash) + SUPPORTED_SOFTWARE_FEATURES_FIELD_NUMBER;
        hash = (53 * hash) + supportedSoftwareFeatures_.hashCode();
      }
      if (getEnabledSoftwareFeaturesCount() > 0) {
        hash = (37 * hash) + ENABLED_SOFTWARE_FEATURES_FIELD_NUMBER;
        hash = (53 * hash) + enabledSoftwareFeatures_.hashCode();
      }
      if (hasEnrollmentSessionId()) {
        hash = (37 * hash) + ENROLLMENT_SESSION_ID_FIELD_NUMBER;
        hash = (53 * hash) + getEnrollmentSessionId().hashCode();
      }
      if (hasOauthToken()) {
        hash = (37 * hash) + OAUTH_TOKEN_FIELD_NUMBER;
        hash = (53 * hash) + getOauthToken().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Message used only during enrollment
     * Field numbers should be kept in sync with DeviceInfo in:
     * java/com/google/security/cryptauth/backend/services/common/common.proto
     * </pre>
     *
     * Protobuf type {@code securegcm.GcmDeviceInfo}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:securegcm.GcmDeviceInfo)
        com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.internal_static_securegcm_GcmDeviceInfo_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.internal_static_securegcm_GcmDeviceInfo_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo.class, com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo.Builder.class);
      }

      // Construct using com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        bitField1_ = 0;
        androidDeviceId_ = 0L;
        gcmRegistrationId_ = com.google.protobuf.ByteString.EMPTY;
        apnRegistrationId_ = com.google.protobuf.ByteString.EMPTY;
        notificationEnabled_ = true;
        bluetoothMacAddress_ = "";
        deviceMasterKeyHash_ = com.google.protobuf.ByteString.EMPTY;
        userPublicKey_ = com.google.protobuf.ByteString.EMPTY;
        deviceModel_ = "";
        locale_ = "";
        keyHandle_ = com.google.protobuf.ByteString.EMPTY;
        counter_ = 0L;
        deviceOsVersion_ = "";
        deviceOsVersionCode_ = 0L;
        deviceOsRelease_ = "";
        deviceOsCodename_ = "";
        deviceSoftwareVersion_ = "";
        deviceSoftwareVersionCode_ = 0L;
        deviceSoftwarePackage_ = "";
        deviceDisplayDiagonalMils_ = 0;
        deviceAuthzenVersion_ = 0;
        longDeviceId_ = com.google.protobuf.ByteString.EMPTY;
        deviceManufacturer_ = "";
        deviceType_ = 1;
        usingSecureScreenlock_ = false;
        autoUnlockScreenlockSupported_ = false;
        autoUnlockScreenlockEnabled_ = false;
        bluetoothRadioSupported_ = false;
        bluetoothRadioEnabled_ = false;
        mobileDataSupported_ = false;
        tetheringSupported_ = false;
        bleRadioSupported_ = false;
        pixelExperience_ = false;
        arcPlusPlus_ = false;
        isScreenlockStateFlaky_ = false;
        supportedSoftwareFeatures_ = java.util.Collections.emptyList();
        bitField1_ = (bitField1_ & ~0x00000004);
        enabledSoftwareFeatures_ = java.util.Collections.emptyList();
        bitField1_ = (bitField1_ & ~0x00000008);
        enrollmentSessionId_ = com.google.protobuf.ByteString.EMPTY;
        oauthToken_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.internal_static_securegcm_GcmDeviceInfo_descriptor;
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo getDefaultInstanceForType() {
        return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo build() {
        com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo buildPartial() {
        com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo result = new com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        if (bitField1_ != 0) { buildPartial1(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo result) {
        if (((bitField1_ & 0x00000004) != 0)) {
          supportedSoftwareFeatures_ = java.util.Collections.unmodifiableList(supportedSoftwareFeatures_);
          bitField1_ = (bitField1_ & ~0x00000004);
        }
        result.supportedSoftwareFeatures_ = supportedSoftwareFeatures_;
        if (((bitField1_ & 0x00000008) != 0)) {
          enabledSoftwareFeatures_ = java.util.Collections.unmodifiableList(enabledSoftwareFeatures_);
          bitField1_ = (bitField1_ & ~0x00000008);
        }
        result.enabledSoftwareFeatures_ = enabledSoftwareFeatures_;
      }

      private void buildPartial0(com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.androidDeviceId_ = androidDeviceId_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.gcmRegistrationId_ = gcmRegistrationId_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.apnRegistrationId_ = apnRegistrationId_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.notificationEnabled_ = notificationEnabled_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.bluetoothMacAddress_ = bluetoothMacAddress_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.deviceMasterKeyHash_ = deviceMasterKeyHash_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.userPublicKey_ = userPublicKey_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.deviceModel_ = deviceModel_;
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.locale_ = locale_;
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.keyHandle_ = keyHandle_;
          to_bitField0_ |= 0x00000200;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.counter_ = counter_;
          to_bitField0_ |= 0x00000400;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.deviceOsVersion_ = deviceOsVersion_;
          to_bitField0_ |= 0x00000800;
        }
        if (((from_bitField0_ & 0x00001000) != 0)) {
          result.deviceOsVersionCode_ = deviceOsVersionCode_;
          to_bitField0_ |= 0x00001000;
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          result.deviceOsRelease_ = deviceOsRelease_;
          to_bitField0_ |= 0x00002000;
        }
        if (((from_bitField0_ & 0x00004000) != 0)) {
          result.deviceOsCodename_ = deviceOsCodename_;
          to_bitField0_ |= 0x00004000;
        }
        if (((from_bitField0_ & 0x00008000) != 0)) {
          result.deviceSoftwareVersion_ = deviceSoftwareVersion_;
          to_bitField0_ |= 0x00008000;
        }
        if (((from_bitField0_ & 0x00010000) != 0)) {
          result.deviceSoftwareVersionCode_ = deviceSoftwareVersionCode_;
          to_bitField0_ |= 0x00010000;
        }
        if (((from_bitField0_ & 0x00020000) != 0)) {
          result.deviceSoftwarePackage_ = deviceSoftwarePackage_;
          to_bitField0_ |= 0x00020000;
        }
        if (((from_bitField0_ & 0x00040000) != 0)) {
          result.deviceDisplayDiagonalMils_ = deviceDisplayDiagonalMils_;
          to_bitField0_ |= 0x00040000;
        }
        if (((from_bitField0_ & 0x00080000) != 0)) {
          result.deviceAuthzenVersion_ = deviceAuthzenVersion_;
          to_bitField0_ |= 0x00080000;
        }
        if (((from_bitField0_ & 0x00100000) != 0)) {
          result.longDeviceId_ = longDeviceId_;
          to_bitField0_ |= 0x00100000;
        }
        if (((from_bitField0_ & 0x00200000) != 0)) {
          result.deviceManufacturer_ = deviceManufacturer_;
          to_bitField0_ |= 0x00200000;
        }
        if (((from_bitField0_ & 0x00400000) != 0)) {
          result.deviceType_ = deviceType_;
          to_bitField0_ |= 0x00400000;
        }
        if (((from_bitField0_ & 0x00800000) != 0)) {
          result.usingSecureScreenlock_ = usingSecureScreenlock_;
          to_bitField0_ |= 0x00800000;
        }
        if (((from_bitField0_ & 0x01000000) != 0)) {
          result.autoUnlockScreenlockSupported_ = autoUnlockScreenlockSupported_;
          to_bitField0_ |= 0x01000000;
        }
        if (((from_bitField0_ & 0x02000000) != 0)) {
          result.autoUnlockScreenlockEnabled_ = autoUnlockScreenlockEnabled_;
          to_bitField0_ |= 0x02000000;
        }
        if (((from_bitField0_ & 0x04000000) != 0)) {
          result.bluetoothRadioSupported_ = bluetoothRadioSupported_;
          to_bitField0_ |= 0x04000000;
        }
        if (((from_bitField0_ & 0x08000000) != 0)) {
          result.bluetoothRadioEnabled_ = bluetoothRadioEnabled_;
          to_bitField0_ |= 0x08000000;
        }
        if (((from_bitField0_ & 0x10000000) != 0)) {
          result.mobileDataSupported_ = mobileDataSupported_;
          to_bitField0_ |= 0x10000000;
        }
        if (((from_bitField0_ & 0x20000000) != 0)) {
          result.tetheringSupported_ = tetheringSupported_;
          to_bitField0_ |= 0x20000000;
        }
        if (((from_bitField0_ & 0x40000000) != 0)) {
          result.bleRadioSupported_ = bleRadioSupported_;
          to_bitField0_ |= 0x40000000;
        }
        if (((from_bitField0_ & 0x80000000) != 0)) {
          result.pixelExperience_ = pixelExperience_;
          to_bitField0_ |= 0x80000000;
        }
        result.bitField0_ |= to_bitField0_;
      }

      private void buildPartial1(com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo result) {
        int from_bitField1_ = bitField1_;
        int to_bitField1_ = 0;
        if (((from_bitField1_ & 0x00000001) != 0)) {
          result.arcPlusPlus_ = arcPlusPlus_;
          to_bitField1_ |= 0x00000001;
        }
        if (((from_bitField1_ & 0x00000002) != 0)) {
          result.isScreenlockStateFlaky_ = isScreenlockStateFlaky_;
          to_bitField1_ |= 0x00000002;
        }
        if (((from_bitField1_ & 0x00000010) != 0)) {
          result.enrollmentSessionId_ = enrollmentSessionId_;
          to_bitField1_ |= 0x00000004;
        }
        if (((from_bitField1_ & 0x00000020) != 0)) {
          result.oauthToken_ = oauthToken_;
          to_bitField1_ |= 0x00000008;
        }
        result.bitField1_ |= to_bitField1_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo) {
          return mergeFrom((com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo other) {
        if (other == com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo.getDefaultInstance()) return this;
        if (other.hasAndroidDeviceId()) {
          setAndroidDeviceId(other.getAndroidDeviceId());
        }
        if (other.hasGcmRegistrationId()) {
          setGcmRegistrationId(other.getGcmRegistrationId());
        }
        if (other.hasApnRegistrationId()) {
          setApnRegistrationId(other.getApnRegistrationId());
        }
        if (other.hasNotificationEnabled()) {
          setNotificationEnabled(other.getNotificationEnabled());
        }
        if (other.hasBluetoothMacAddress()) {
          bluetoothMacAddress_ = other.bluetoothMacAddress_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        if (other.hasDeviceMasterKeyHash()) {
          setDeviceMasterKeyHash(other.getDeviceMasterKeyHash());
        }
        if (other.hasUserPublicKey()) {
          setUserPublicKey(other.getUserPublicKey());
        }
        if (other.hasDeviceModel()) {
          deviceModel_ = other.deviceModel_;
          bitField0_ |= 0x00000080;
          onChanged();
        }
        if (other.hasLocale()) {
          locale_ = other.locale_;
          bitField0_ |= 0x00000100;
          onChanged();
        }
        if (other.hasKeyHandle()) {
          setKeyHandle(other.getKeyHandle());
        }
        if (other.hasCounter()) {
          setCounter(other.getCounter());
        }
        if (other.hasDeviceOsVersion()) {
          deviceOsVersion_ = other.deviceOsVersion_;
          bitField0_ |= 0x00000800;
          onChanged();
        }
        if (other.hasDeviceOsVersionCode()) {
          setDeviceOsVersionCode(other.getDeviceOsVersionCode());
        }
        if (other.hasDeviceOsRelease()) {
          deviceOsRelease_ = other.deviceOsRelease_;
          bitField0_ |= 0x00002000;
          onChanged();
        }
        if (other.hasDeviceOsCodename()) {
          deviceOsCodename_ = other.deviceOsCodename_;
          bitField0_ |= 0x00004000;
          onChanged();
        }
        if (other.hasDeviceSoftwareVersion()) {
          deviceSoftwareVersion_ = other.deviceSoftwareVersion_;
          bitField0_ |= 0x00008000;
          onChanged();
        }
        if (other.hasDeviceSoftwareVersionCode()) {
          setDeviceSoftwareVersionCode(other.getDeviceSoftwareVersionCode());
        }
        if (other.hasDeviceSoftwarePackage()) {
          deviceSoftwarePackage_ = other.deviceSoftwarePackage_;
          bitField0_ |= 0x00020000;
          onChanged();
        }
        if (other.hasDeviceDisplayDiagonalMils()) {
          setDeviceDisplayDiagonalMils(other.getDeviceDisplayDiagonalMils());
        }
        if (other.hasDeviceAuthzenVersion()) {
          setDeviceAuthzenVersion(other.getDeviceAuthzenVersion());
        }
        if (other.hasLongDeviceId()) {
          setLongDeviceId(other.getLongDeviceId());
        }
        if (other.hasDeviceManufacturer()) {
          deviceManufacturer_ = other.deviceManufacturer_;
          bitField0_ |= 0x00200000;
          onChanged();
        }
        if (other.hasDeviceType()) {
          setDeviceType(other.getDeviceType());
        }
        if (other.hasUsingSecureScreenlock()) {
          setUsingSecureScreenlock(other.getUsingSecureScreenlock());
        }
        if (other.hasAutoUnlockScreenlockSupported()) {
          setAutoUnlockScreenlockSupported(other.getAutoUnlockScreenlockSupported());
        }
        if (other.hasAutoUnlockScreenlockEnabled()) {
          setAutoUnlockScreenlockEnabled(other.getAutoUnlockScreenlockEnabled());
        }
        if (other.hasBluetoothRadioSupported()) {
          setBluetoothRadioSupported(other.getBluetoothRadioSupported());
        }
        if (other.hasBluetoothRadioEnabled()) {
          setBluetoothRadioEnabled(other.getBluetoothRadioEnabled());
        }
        if (other.hasMobileDataSupported()) {
          setMobileDataSupported(other.getMobileDataSupported());
        }
        if (other.hasTetheringSupported()) {
          setTetheringSupported(other.getTetheringSupported());
        }
        if (other.hasBleRadioSupported()) {
          setBleRadioSupported(other.getBleRadioSupported());
        }
        if (other.hasPixelExperience()) {
          setPixelExperience(other.getPixelExperience());
        }
        if (other.hasArcPlusPlus()) {
          setArcPlusPlus(other.getArcPlusPlus());
        }
        if (other.hasIsScreenlockStateFlaky()) {
          setIsScreenlockStateFlaky(other.getIsScreenlockStateFlaky());
        }
        if (!other.supportedSoftwareFeatures_.isEmpty()) {
          if (supportedSoftwareFeatures_.isEmpty()) {
            supportedSoftwareFeatures_ = other.supportedSoftwareFeatures_;
            bitField1_ = (bitField1_ & ~0x00000004);
          } else {
            ensureSupportedSoftwareFeaturesIsMutable();
            supportedSoftwareFeatures_.addAll(other.supportedSoftwareFeatures_);
          }
          onChanged();
        }
        if (!other.enabledSoftwareFeatures_.isEmpty()) {
          if (enabledSoftwareFeatures_.isEmpty()) {
            enabledSoftwareFeatures_ = other.enabledSoftwareFeatures_;
            bitField1_ = (bitField1_ & ~0x00000008);
          } else {
            ensureEnabledSoftwareFeaturesIsMutable();
            enabledSoftwareFeatures_.addAll(other.enabledSoftwareFeatures_);
          }
          onChanged();
        }
        if (other.hasEnrollmentSessionId()) {
          setEnrollmentSessionId(other.getEnrollmentSessionId());
        }
        if (other.hasOauthToken()) {
          oauthToken_ = other.oauthToken_;
          bitField1_ |= 0x00000020;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasUserPublicKey()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 9: {
                androidDeviceId_ = input.readFixed64();
                bitField0_ |= 0x00000001;
                break;
              } // case 9
              case 34: {
                userPublicKey_ = input.readBytes();
                bitField0_ |= 0x00000040;
                break;
              } // case 34
              case 58: {
                deviceModel_ = input.readBytes();
                bitField0_ |= 0x00000080;
                break;
              } // case 58
              case 66: {
                locale_ = input.readBytes();
                bitField0_ |= 0x00000100;
                break;
              } // case 66
              case 74: {
                keyHandle_ = input.readBytes();
                bitField0_ |= 0x00000200;
                break;
              } // case 74
              case 96: {
                counter_ = input.readInt64();
                bitField0_ |= 0x00000400;
                break;
              } // case 96
              case 106: {
                deviceOsVersion_ = input.readBytes();
                bitField0_ |= 0x00000800;
                break;
              } // case 106
              case 112: {
                deviceOsVersionCode_ = input.readInt64();
                bitField0_ |= 0x00001000;
                break;
              } // case 112
              case 122: {
                deviceOsRelease_ = input.readBytes();
                bitField0_ |= 0x00002000;
                break;
              } // case 122
              case 130: {
                deviceOsCodename_ = input.readBytes();
                bitField0_ |= 0x00004000;
                break;
              } // case 130
              case 138: {
                deviceSoftwareVersion_ = input.readBytes();
                bitField0_ |= 0x00008000;
                break;
              } // case 138
              case 144: {
                deviceSoftwareVersionCode_ = input.readInt64();
                bitField0_ |= 0x00010000;
                break;
              } // case 144
              case 154: {
                deviceSoftwarePackage_ = input.readBytes();
                bitField0_ |= 0x00020000;
                break;
              } // case 154
              case 176: {
                deviceDisplayDiagonalMils_ = input.readInt32();
                bitField0_ |= 0x00040000;
                break;
              } // case 176
              case 192: {
                deviceAuthzenVersion_ = input.readInt32();
                bitField0_ |= 0x00080000;
                break;
              } // case 192
              case 234: {
                longDeviceId_ = input.readBytes();
                bitField0_ |= 0x00100000;
                break;
              } // case 234
              case 250: {
                deviceManufacturer_ = input.readBytes();
                bitField0_ |= 0x00200000;
                break;
              } // case 250
              case 256: {
                int tmpRaw = input.readEnum();
                com.google.security.cryptauth.lib.securegcm.SecureGcmProto.DeviceType tmpValue =
                    com.google.security.cryptauth.lib.securegcm.SecureGcmProto.DeviceType.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(32, tmpRaw);
                } else {
                  deviceType_ = tmpRaw;
                  bitField0_ |= 0x00400000;
                }
                break;
              } // case 256
              case 818: {
                gcmRegistrationId_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 818
              case 826: {
                deviceMasterKeyHash_ = input.readBytes();
                bitField0_ |= 0x00000020;
                break;
              } // case 826
              case 1618: {
                apnRegistrationId_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 1618
              case 1624: {
                notificationEnabled_ = input.readBool();
                bitField0_ |= 0x00000008;
                break;
              } // case 1624
              case 2418: {
                bluetoothMacAddress_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 2418
              case 3200: {
                usingSecureScreenlock_ = input.readBool();
                bitField0_ |= 0x00800000;
                break;
              } // case 3200
              case 3208: {
                autoUnlockScreenlockSupported_ = input.readBool();
                bitField0_ |= 0x01000000;
                break;
              } // case 3208
              case 3216: {
                autoUnlockScreenlockEnabled_ = input.readBool();
                bitField0_ |= 0x02000000;
                break;
              } // case 3216
              case 3224: {
                bluetoothRadioSupported_ = input.readBool();
                bitField0_ |= 0x04000000;
                break;
              } // case 3224
              case 3232: {
                bluetoothRadioEnabled_ = input.readBool();
                bitField0_ |= 0x08000000;
                break;
              } // case 3232
              case 3240: {
                mobileDataSupported_ = input.readBool();
                bitField0_ |= 0x10000000;
                break;
              } // case 3240
              case 3248: {
                tetheringSupported_ = input.readBool();
                bitField0_ |= 0x20000000;
                break;
              } // case 3248
              case 3256: {
                bleRadioSupported_ = input.readBool();
                bitField0_ |= 0x40000000;
                break;
              } // case 3256
              case 3264: {
                pixelExperience_ = input.readBool();
                bitField0_ |= 0x80000000;
                break;
              } // case 3264
              case 3272: {
                arcPlusPlus_ = input.readBool();
                bitField1_ |= 0x00000001;
                break;
              } // case 3272
              case 3280: {
                isScreenlockStateFlaky_ = input.readBool();
                bitField1_ |= 0x00000002;
                break;
              } // case 3280
              case 3288: {
                int tmpRaw = input.readEnum();
                com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature tmpValue =
                    com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(411, tmpRaw);
                } else {
                  ensureSupportedSoftwareFeaturesIsMutable();
                  supportedSoftwareFeatures_.add(tmpRaw);
                }
                break;
              } // case 3288
              case 3290: {
                int length = input.readRawVarint32();
                int oldLimit = input.pushLimit(length);
                while(input.getBytesUntilLimit() > 0) {
                  int tmpRaw = input.readEnum();
                  com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature tmpValue =
                      com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature.forNumber(tmpRaw);
                  if (tmpValue == null) {
                    mergeUnknownVarintField(411, tmpRaw);
                  } else {
                    ensureSupportedSoftwareFeaturesIsMutable();
                    supportedSoftwareFeatures_.add(tmpRaw);
                  }
                }
                input.popLimit(oldLimit);
                break;
              } // case 3290
              case 3296: {
                int tmpRaw = input.readEnum();
                com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature tmpValue =
                    com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(412, tmpRaw);
                } else {
                  ensureEnabledSoftwareFeaturesIsMutable();
                  enabledSoftwareFeatures_.add(tmpRaw);
                }
                break;
              } // case 3296
              case 3298: {
                int length = input.readRawVarint32();
                int oldLimit = input.pushLimit(length);
                while(input.getBytesUntilLimit() > 0) {
                  int tmpRaw = input.readEnum();
                  com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature tmpValue =
                      com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature.forNumber(tmpRaw);
                  if (tmpValue == null) {
                    mergeUnknownVarintField(412, tmpRaw);
                  } else {
                    ensureEnabledSoftwareFeaturesIsMutable();
                    enabledSoftwareFeatures_.add(tmpRaw);
                  }
                }
                input.popLimit(oldLimit);
                break;
              } // case 3298
              case 8002: {
                enrollmentSessionId_ = input.readBytes();
                bitField1_ |= 0x00000010;
                break;
              } // case 8002
              case 8010: {
                oauthToken_ = input.readBytes();
                bitField1_ |= 0x00000020;
                break;
              } // case 8010
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;
      private int bitField1_;

      private long androidDeviceId_ ;
      /**
       * <pre>
       * This field's name does not match the one in DeviceInfo for legacy reasons.
       * Consider using long_device_id and device_type instead when enrolling
       * non-android devices.
       * </pre>
       *
       * <code>optional fixed64 android_device_id = 1;</code>
       * @return Whether the androidDeviceId field is set.
       */
      @java.lang.Override
      public boolean hasAndroidDeviceId() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * This field's name does not match the one in DeviceInfo for legacy reasons.
       * Consider using long_device_id and device_type instead when enrolling
       * non-android devices.
       * </pre>
       *
       * <code>optional fixed64 android_device_id = 1;</code>
       * @return The androidDeviceId.
       */
      @java.lang.Override
      public long getAndroidDeviceId() {
        return androidDeviceId_;
      }
      /**
       * <pre>
       * This field's name does not match the one in DeviceInfo for legacy reasons.
       * Consider using long_device_id and device_type instead when enrolling
       * non-android devices.
       * </pre>
       *
       * <code>optional fixed64 android_device_id = 1;</code>
       * @param value The androidDeviceId to set.
       * @return This builder for chaining.
       */
      public Builder setAndroidDeviceId(long value) {

        androidDeviceId_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field's name does not match the one in DeviceInfo for legacy reasons.
       * Consider using long_device_id and device_type instead when enrolling
       * non-android devices.
       * </pre>
       *
       * <code>optional fixed64 android_device_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearAndroidDeviceId() {
        bitField0_ = (bitField0_ & ~0x00000001);
        androidDeviceId_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString gcmRegistrationId_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Used for device_address of DeviceInfo field 2, but for GCM capable devices.
       * </pre>
       *
       * <code>optional bytes gcm_registration_id = 102;</code>
       * @return Whether the gcmRegistrationId field is set.
       */
      @java.lang.Override
      public boolean hasGcmRegistrationId() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Used for device_address of DeviceInfo field 2, but for GCM capable devices.
       * </pre>
       *
       * <code>optional bytes gcm_registration_id = 102;</code>
       * @return The gcmRegistrationId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getGcmRegistrationId() {
        return gcmRegistrationId_;
      }
      /**
       * <pre>
       * Used for device_address of DeviceInfo field 2, but for GCM capable devices.
       * </pre>
       *
       * <code>optional bytes gcm_registration_id = 102;</code>
       * @param value The gcmRegistrationId to set.
       * @return This builder for chaining.
       */
      public Builder setGcmRegistrationId(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        gcmRegistrationId_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Used for device_address of DeviceInfo field 2, but for GCM capable devices.
       * </pre>
       *
       * <code>optional bytes gcm_registration_id = 102;</code>
       * @return This builder for chaining.
       */
      public Builder clearGcmRegistrationId() {
        bitField0_ = (bitField0_ & ~0x00000002);
        gcmRegistrationId_ = getDefaultInstance().getGcmRegistrationId();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString apnRegistrationId_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Used for device_address of DeviceInfo field 2, but for iOS devices.
       * </pre>
       *
       * <code>optional bytes apn_registration_id = 202;</code>
       * @return Whether the apnRegistrationId field is set.
       */
      @java.lang.Override
      public boolean hasApnRegistrationId() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Used for device_address of DeviceInfo field 2, but for iOS devices.
       * </pre>
       *
       * <code>optional bytes apn_registration_id = 202;</code>
       * @return The apnRegistrationId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getApnRegistrationId() {
        return apnRegistrationId_;
      }
      /**
       * <pre>
       * Used for device_address of DeviceInfo field 2, but for iOS devices.
       * </pre>
       *
       * <code>optional bytes apn_registration_id = 202;</code>
       * @param value The apnRegistrationId to set.
       * @return This builder for chaining.
       */
      public Builder setApnRegistrationId(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        apnRegistrationId_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Used for device_address of DeviceInfo field 2, but for iOS devices.
       * </pre>
       *
       * <code>optional bytes apn_registration_id = 202;</code>
       * @return This builder for chaining.
       */
      public Builder clearApnRegistrationId() {
        bitField0_ = (bitField0_ & ~0x00000004);
        apnRegistrationId_ = getDefaultInstance().getApnRegistrationId();
        onChanged();
        return this;
      }

      private boolean notificationEnabled_ = true;
      /**
       * <pre>
       * Does the user have notifications enabled for the given device address.
       * </pre>
       *
       * <code>optional bool notification_enabled = 203 [default = true];</code>
       * @return Whether the notificationEnabled field is set.
       */
      @java.lang.Override
      public boolean hasNotificationEnabled() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Does the user have notifications enabled for the given device address.
       * </pre>
       *
       * <code>optional bool notification_enabled = 203 [default = true];</code>
       * @return The notificationEnabled.
       */
      @java.lang.Override
      public boolean getNotificationEnabled() {
        return notificationEnabled_;
      }
      /**
       * <pre>
       * Does the user have notifications enabled for the given device address.
       * </pre>
       *
       * <code>optional bool notification_enabled = 203 [default = true];</code>
       * @param value The notificationEnabled to set.
       * @return This builder for chaining.
       */
      public Builder setNotificationEnabled(boolean value) {

        notificationEnabled_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Does the user have notifications enabled for the given device address.
       * </pre>
       *
       * <code>optional bool notification_enabled = 203 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearNotificationEnabled() {
        bitField0_ = (bitField0_ & ~0x00000008);
        notificationEnabled_ = true;
        onChanged();
        return this;
      }

      private java.lang.Object bluetoothMacAddress_ = "";
      /**
       * <pre>
       * Used for device_address of DeviceInfo field 2, a Bluetooth Mac address for
       * the device (e.g., to be used with EasyUnlock)
       * </pre>
       *
       * <code>optional string bluetooth_mac_address = 302;</code>
       * @return Whether the bluetoothMacAddress field is set.
       */
      public boolean hasBluetoothMacAddress() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Used for device_address of DeviceInfo field 2, a Bluetooth Mac address for
       * the device (e.g., to be used with EasyUnlock)
       * </pre>
       *
       * <code>optional string bluetooth_mac_address = 302;</code>
       * @return The bluetoothMacAddress.
       */
      public java.lang.String getBluetoothMacAddress() {
        java.lang.Object ref = bluetoothMacAddress_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            bluetoothMacAddress_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Used for device_address of DeviceInfo field 2, a Bluetooth Mac address for
       * the device (e.g., to be used with EasyUnlock)
       * </pre>
       *
       * <code>optional string bluetooth_mac_address = 302;</code>
       * @return The bytes for bluetoothMacAddress.
       */
      public com.google.protobuf.ByteString
          getBluetoothMacAddressBytes() {
        java.lang.Object ref = bluetoothMacAddress_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          bluetoothMacAddress_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Used for device_address of DeviceInfo field 2, a Bluetooth Mac address for
       * the device (e.g., to be used with EasyUnlock)
       * </pre>
       *
       * <code>optional string bluetooth_mac_address = 302;</code>
       * @param value The bluetoothMacAddress to set.
       * @return This builder for chaining.
       */
      public Builder setBluetoothMacAddress(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        bluetoothMacAddress_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Used for device_address of DeviceInfo field 2, a Bluetooth Mac address for
       * the device (e.g., to be used with EasyUnlock)
       * </pre>
       *
       * <code>optional string bluetooth_mac_address = 302;</code>
       * @return This builder for chaining.
       */
      public Builder clearBluetoothMacAddress() {
        bluetoothMacAddress_ = getDefaultInstance().getBluetoothMacAddress();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Used for device_address of DeviceInfo field 2, a Bluetooth Mac address for
       * the device (e.g., to be used with EasyUnlock)
       * </pre>
       *
       * <code>optional string bluetooth_mac_address = 302;</code>
       * @param value The bytes for bluetoothMacAddress to set.
       * @return This builder for chaining.
       */
      public Builder setBluetoothMacAddressBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        bluetoothMacAddress_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString deviceMasterKeyHash_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * SHA-256 hash of the device master key (from the key exchange).
       * Differs from DeviceInfo field 3, which contains the actual master key.
       * </pre>
       *
       * <code>optional bytes device_master_key_hash = 103;</code>
       * @return Whether the deviceMasterKeyHash field is set.
       */
      @java.lang.Override
      public boolean hasDeviceMasterKeyHash() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * SHA-256 hash of the device master key (from the key exchange).
       * Differs from DeviceInfo field 3, which contains the actual master key.
       * </pre>
       *
       * <code>optional bytes device_master_key_hash = 103;</code>
       * @return The deviceMasterKeyHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getDeviceMasterKeyHash() {
        return deviceMasterKeyHash_;
      }
      /**
       * <pre>
       * SHA-256 hash of the device master key (from the key exchange).
       * Differs from DeviceInfo field 3, which contains the actual master key.
       * </pre>
       *
       * <code>optional bytes device_master_key_hash = 103;</code>
       * @param value The deviceMasterKeyHash to set.
       * @return This builder for chaining.
       */
      public Builder setDeviceMasterKeyHash(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        deviceMasterKeyHash_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * SHA-256 hash of the device master key (from the key exchange).
       * Differs from DeviceInfo field 3, which contains the actual master key.
       * </pre>
       *
       * <code>optional bytes device_master_key_hash = 103;</code>
       * @return This builder for chaining.
       */
      public Builder clearDeviceMasterKeyHash() {
        bitField0_ = (bitField0_ & ~0x00000020);
        deviceMasterKeyHash_ = getDefaultInstance().getDeviceMasterKeyHash();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString userPublicKey_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * A SecureMessage.EcP256PublicKey
       * </pre>
       *
       * <code>required bytes user_public_key = 4;</code>
       * @return Whether the userPublicKey field is set.
       */
      @java.lang.Override
      public boolean hasUserPublicKey() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * A SecureMessage.EcP256PublicKey
       * </pre>
       *
       * <code>required bytes user_public_key = 4;</code>
       * @return The userPublicKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getUserPublicKey() {
        return userPublicKey_;
      }
      /**
       * <pre>
       * A SecureMessage.EcP256PublicKey
       * </pre>
       *
       * <code>required bytes user_public_key = 4;</code>
       * @param value The userPublicKey to set.
       * @return This builder for chaining.
       */
      public Builder setUserPublicKey(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        userPublicKey_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A SecureMessage.EcP256PublicKey
       * </pre>
       *
       * <code>required bytes user_public_key = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearUserPublicKey() {
        bitField0_ = (bitField0_ & ~0x00000040);
        userPublicKey_ = getDefaultInstance().getUserPublicKey();
        onChanged();
        return this;
      }

      private java.lang.Object deviceModel_ = "";
      /**
       * <pre>
       * device's model name
       * (e.g., an android.os.Build.MODEL or UIDevice.model)
       * </pre>
       *
       * <code>optional string device_model = 7;</code>
       * @return Whether the deviceModel field is set.
       */
      public boolean hasDeviceModel() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * device's model name
       * (e.g., an android.os.Build.MODEL or UIDevice.model)
       * </pre>
       *
       * <code>optional string device_model = 7;</code>
       * @return The deviceModel.
       */
      public java.lang.String getDeviceModel() {
        java.lang.Object ref = deviceModel_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            deviceModel_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * device's model name
       * (e.g., an android.os.Build.MODEL or UIDevice.model)
       * </pre>
       *
       * <code>optional string device_model = 7;</code>
       * @return The bytes for deviceModel.
       */
      public com.google.protobuf.ByteString
          getDeviceModelBytes() {
        java.lang.Object ref = deviceModel_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          deviceModel_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * device's model name
       * (e.g., an android.os.Build.MODEL or UIDevice.model)
       * </pre>
       *
       * <code>optional string device_model = 7;</code>
       * @param value The deviceModel to set.
       * @return This builder for chaining.
       */
      public Builder setDeviceModel(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        deviceModel_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * device's model name
       * (e.g., an android.os.Build.MODEL or UIDevice.model)
       * </pre>
       *
       * <code>optional string device_model = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearDeviceModel() {
        deviceModel_ = getDefaultInstance().getDeviceModel();
        bitField0_ = (bitField0_ & ~0x00000080);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * device's model name
       * (e.g., an android.os.Build.MODEL or UIDevice.model)
       * </pre>
       *
       * <code>optional string device_model = 7;</code>
       * @param value The bytes for deviceModel to set.
       * @return This builder for chaining.
       */
      public Builder setDeviceModelBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        deviceModel_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }

      private java.lang.Object locale_ = "";
      /**
       * <pre>
       * device's locale
       * </pre>
       *
       * <code>optional string locale = 8;</code>
       * @return Whether the locale field is set.
       */
      public boolean hasLocale() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * device's locale
       * </pre>
       *
       * <code>optional string locale = 8;</code>
       * @return The locale.
       */
      public java.lang.String getLocale() {
        java.lang.Object ref = locale_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            locale_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * device's locale
       * </pre>
       *
       * <code>optional string locale = 8;</code>
       * @return The bytes for locale.
       */
      public com.google.protobuf.ByteString
          getLocaleBytes() {
        java.lang.Object ref = locale_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          locale_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * device's locale
       * </pre>
       *
       * <code>optional string locale = 8;</code>
       * @param value The locale to set.
       * @return This builder for chaining.
       */
      public Builder setLocale(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        locale_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * device's locale
       * </pre>
       *
       * <code>optional string locale = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearLocale() {
        locale_ = getDefaultInstance().getLocale();
        bitField0_ = (bitField0_ & ~0x00000100);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * device's locale
       * </pre>
       *
       * <code>optional string locale = 8;</code>
       * @param value The bytes for locale to set.
       * @return This builder for chaining.
       */
      public Builder setLocaleBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        locale_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString keyHandle_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * The handle for user_public_key (and implicitly, a master key)
       * </pre>
       *
       * <code>optional bytes key_handle = 9;</code>
       * @return Whether the keyHandle field is set.
       */
      @java.lang.Override
      public boolean hasKeyHandle() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * The handle for user_public_key (and implicitly, a master key)
       * </pre>
       *
       * <code>optional bytes key_handle = 9;</code>
       * @return The keyHandle.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getKeyHandle() {
        return keyHandle_;
      }
      /**
       * <pre>
       * The handle for user_public_key (and implicitly, a master key)
       * </pre>
       *
       * <code>optional bytes key_handle = 9;</code>
       * @param value The keyHandle to set.
       * @return This builder for chaining.
       */
      public Builder setKeyHandle(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        keyHandle_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The handle for user_public_key (and implicitly, a master key)
       * </pre>
       *
       * <code>optional bytes key_handle = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearKeyHandle() {
        bitField0_ = (bitField0_ & ~0x00000200);
        keyHandle_ = getDefaultInstance().getKeyHandle();
        onChanged();
        return this;
      }

      private long counter_ ;
      /**
       * <pre>
       * The initial counter value for the device, sent by the device
       * </pre>
       *
       * <code>optional int64 counter = 12 [default = 0];</code>
       * @return Whether the counter field is set.
       */
      @java.lang.Override
      public boolean hasCounter() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <pre>
       * The initial counter value for the device, sent by the device
       * </pre>
       *
       * <code>optional int64 counter = 12 [default = 0];</code>
       * @return The counter.
       */
      @java.lang.Override
      public long getCounter() {
        return counter_;
      }
      /**
       * <pre>
       * The initial counter value for the device, sent by the device
       * </pre>
       *
       * <code>optional int64 counter = 12 [default = 0];</code>
       * @param value The counter to set.
       * @return This builder for chaining.
       */
      public Builder setCounter(long value) {

        counter_ = value;
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The initial counter value for the device, sent by the device
       * </pre>
       *
       * <code>optional int64 counter = 12 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearCounter() {
        bitField0_ = (bitField0_ & ~0x00000400);
        counter_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object deviceOsVersion_ = "";
      /**
       * <pre>
       * The Operating System version on the device
       * (e.g., an android.os.Build.DISPLAY or UIDevice.systemVersion)
       * </pre>
       *
       * <code>optional string device_os_version = 13;</code>
       * @return Whether the deviceOsVersion field is set.
       */
      public boolean hasDeviceOsVersion() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <pre>
       * The Operating System version on the device
       * (e.g., an android.os.Build.DISPLAY or UIDevice.systemVersion)
       * </pre>
       *
       * <code>optional string device_os_version = 13;</code>
       * @return The deviceOsVersion.
       */
      public java.lang.String getDeviceOsVersion() {
        java.lang.Object ref = deviceOsVersion_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            deviceOsVersion_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The Operating System version on the device
       * (e.g., an android.os.Build.DISPLAY or UIDevice.systemVersion)
       * </pre>
       *
       * <code>optional string device_os_version = 13;</code>
       * @return The bytes for deviceOsVersion.
       */
      public com.google.protobuf.ByteString
          getDeviceOsVersionBytes() {
        java.lang.Object ref = deviceOsVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          deviceOsVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The Operating System version on the device
       * (e.g., an android.os.Build.DISPLAY or UIDevice.systemVersion)
       * </pre>
       *
       * <code>optional string device_os_version = 13;</code>
       * @param value The deviceOsVersion to set.
       * @return This builder for chaining.
       */
      public Builder setDeviceOsVersion(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        deviceOsVersion_ = value;
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The Operating System version on the device
       * (e.g., an android.os.Build.DISPLAY or UIDevice.systemVersion)
       * </pre>
       *
       * <code>optional string device_os_version = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearDeviceOsVersion() {
        deviceOsVersion_ = getDefaultInstance().getDeviceOsVersion();
        bitField0_ = (bitField0_ & ~0x00000800);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The Operating System version on the device
       * (e.g., an android.os.Build.DISPLAY or UIDevice.systemVersion)
       * </pre>
       *
       * <code>optional string device_os_version = 13;</code>
       * @param value The bytes for deviceOsVersion to set.
       * @return This builder for chaining.
       */
      public Builder setDeviceOsVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        deviceOsVersion_ = value;
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }

      private long deviceOsVersionCode_ ;
      /**
       * <pre>
       * The Operating System version number on the device
       * (e.g., an android.os.Build.VERSION.SDK_INT)
       * </pre>
       *
       * <code>optional int64 device_os_version_code = 14;</code>
       * @return Whether the deviceOsVersionCode field is set.
       */
      @java.lang.Override
      public boolean hasDeviceOsVersionCode() {
        return ((bitField0_ & 0x00001000) != 0);
      }
      /**
       * <pre>
       * The Operating System version number on the device
       * (e.g., an android.os.Build.VERSION.SDK_INT)
       * </pre>
       *
       * <code>optional int64 device_os_version_code = 14;</code>
       * @return The deviceOsVersionCode.
       */
      @java.lang.Override
      public long getDeviceOsVersionCode() {
        return deviceOsVersionCode_;
      }
      /**
       * <pre>
       * The Operating System version number on the device
       * (e.g., an android.os.Build.VERSION.SDK_INT)
       * </pre>
       *
       * <code>optional int64 device_os_version_code = 14;</code>
       * @param value The deviceOsVersionCode to set.
       * @return This builder for chaining.
       */
      public Builder setDeviceOsVersionCode(long value) {

        deviceOsVersionCode_ = value;
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The Operating System version number on the device
       * (e.g., an android.os.Build.VERSION.SDK_INT)
       * </pre>
       *
       * <code>optional int64 device_os_version_code = 14;</code>
       * @return This builder for chaining.
       */
      public Builder clearDeviceOsVersionCode() {
        bitField0_ = (bitField0_ & ~0x00001000);
        deviceOsVersionCode_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object deviceOsRelease_ = "";
      /**
       * <pre>
       * The Operating System release on the device
       * (e.g., an android.os.Build.VERSION.RELEASE)
       * </pre>
       *
       * <code>optional string device_os_release = 15;</code>
       * @return Whether the deviceOsRelease field is set.
       */
      public boolean hasDeviceOsRelease() {
        return ((bitField0_ & 0x00002000) != 0);
      }
      /**
       * <pre>
       * The Operating System release on the device
       * (e.g., an android.os.Build.VERSION.RELEASE)
       * </pre>
       *
       * <code>optional string device_os_release = 15;</code>
       * @return The deviceOsRelease.
       */
      public java.lang.String getDeviceOsRelease() {
        java.lang.Object ref = deviceOsRelease_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            deviceOsRelease_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The Operating System release on the device
       * (e.g., an android.os.Build.VERSION.RELEASE)
       * </pre>
       *
       * <code>optional string device_os_release = 15;</code>
       * @return The bytes for deviceOsRelease.
       */
      public com.google.protobuf.ByteString
          getDeviceOsReleaseBytes() {
        java.lang.Object ref = deviceOsRelease_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          deviceOsRelease_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The Operating System release on the device
       * (e.g., an android.os.Build.VERSION.RELEASE)
       * </pre>
       *
       * <code>optional string device_os_release = 15;</code>
       * @param value The deviceOsRelease to set.
       * @return This builder for chaining.
       */
      public Builder setDeviceOsRelease(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        deviceOsRelease_ = value;
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The Operating System release on the device
       * (e.g., an android.os.Build.VERSION.RELEASE)
       * </pre>
       *
       * <code>optional string device_os_release = 15;</code>
       * @return This builder for chaining.
       */
      public Builder clearDeviceOsRelease() {
        deviceOsRelease_ = getDefaultInstance().getDeviceOsRelease();
        bitField0_ = (bitField0_ & ~0x00002000);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The Operating System release on the device
       * (e.g., an android.os.Build.VERSION.RELEASE)
       * </pre>
       *
       * <code>optional string device_os_release = 15;</code>
       * @param value The bytes for deviceOsRelease to set.
       * @return This builder for chaining.
       */
      public Builder setDeviceOsReleaseBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        deviceOsRelease_ = value;
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }

      private java.lang.Object deviceOsCodename_ = "";
      /**
       * <pre>
       * The Operating System codename on the device
       * (e.g., an android.os.Build.VERSION.CODENAME or UIDevice.systemName)
       * </pre>
       *
       * <code>optional string device_os_codename = 16;</code>
       * @return Whether the deviceOsCodename field is set.
       */
      public boolean hasDeviceOsCodename() {
        return ((bitField0_ & 0x00004000) != 0);
      }
      /**
       * <pre>
       * The Operating System codename on the device
       * (e.g., an android.os.Build.VERSION.CODENAME or UIDevice.systemName)
       * </pre>
       *
       * <code>optional string device_os_codename = 16;</code>
       * @return The deviceOsCodename.
       */
      public java.lang.String getDeviceOsCodename() {
        java.lang.Object ref = deviceOsCodename_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            deviceOsCodename_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The Operating System codename on the device
       * (e.g., an android.os.Build.VERSION.CODENAME or UIDevice.systemName)
       * </pre>
       *
       * <code>optional string device_os_codename = 16;</code>
       * @return The bytes for deviceOsCodename.
       */
      public com.google.protobuf.ByteString
          getDeviceOsCodenameBytes() {
        java.lang.Object ref = deviceOsCodename_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          deviceOsCodename_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The Operating System codename on the device
       * (e.g., an android.os.Build.VERSION.CODENAME or UIDevice.systemName)
       * </pre>
       *
       * <code>optional string device_os_codename = 16;</code>
       * @param value The deviceOsCodename to set.
       * @return This builder for chaining.
       */
      public Builder setDeviceOsCodename(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        deviceOsCodename_ = value;
        bitField0_ |= 0x00004000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The Operating System codename on the device
       * (e.g., an android.os.Build.VERSION.CODENAME or UIDevice.systemName)
       * </pre>
       *
       * <code>optional string device_os_codename = 16;</code>
       * @return This builder for chaining.
       */
      public Builder clearDeviceOsCodename() {
        deviceOsCodename_ = getDefaultInstance().getDeviceOsCodename();
        bitField0_ = (bitField0_ & ~0x00004000);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The Operating System codename on the device
       * (e.g., an android.os.Build.VERSION.CODENAME or UIDevice.systemName)
       * </pre>
       *
       * <code>optional string device_os_codename = 16;</code>
       * @param value The bytes for deviceOsCodename to set.
       * @return This builder for chaining.
       */
      public Builder setDeviceOsCodenameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        deviceOsCodename_ = value;
        bitField0_ |= 0x00004000;
        onChanged();
        return this;
      }

      private java.lang.Object deviceSoftwareVersion_ = "";
      /**
       * <pre>
       * The software version running on the device
       * (e.g., Authenticator app version string)
       * </pre>
       *
       * <code>optional string device_software_version = 17;</code>
       * @return Whether the deviceSoftwareVersion field is set.
       */
      public boolean hasDeviceSoftwareVersion() {
        return ((bitField0_ & 0x00008000) != 0);
      }
      /**
       * <pre>
       * The software version running on the device
       * (e.g., Authenticator app version string)
       * </pre>
       *
       * <code>optional string device_software_version = 17;</code>
       * @return The deviceSoftwareVersion.
       */
      public java.lang.String getDeviceSoftwareVersion() {
        java.lang.Object ref = deviceSoftwareVersion_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            deviceSoftwareVersion_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The software version running on the device
       * (e.g., Authenticator app version string)
       * </pre>
       *
       * <code>optional string device_software_version = 17;</code>
       * @return The bytes for deviceSoftwareVersion.
       */
      public com.google.protobuf.ByteString
          getDeviceSoftwareVersionBytes() {
        java.lang.Object ref = deviceSoftwareVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          deviceSoftwareVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The software version running on the device
       * (e.g., Authenticator app version string)
       * </pre>
       *
       * <code>optional string device_software_version = 17;</code>
       * @param value The deviceSoftwareVersion to set.
       * @return This builder for chaining.
       */
      public Builder setDeviceSoftwareVersion(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        deviceSoftwareVersion_ = value;
        bitField0_ |= 0x00008000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The software version running on the device
       * (e.g., Authenticator app version string)
       * </pre>
       *
       * <code>optional string device_software_version = 17;</code>
       * @return This builder for chaining.
       */
      public Builder clearDeviceSoftwareVersion() {
        deviceSoftwareVersion_ = getDefaultInstance().getDeviceSoftwareVersion();
        bitField0_ = (bitField0_ & ~0x00008000);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The software version running on the device
       * (e.g., Authenticator app version string)
       * </pre>
       *
       * <code>optional string device_software_version = 17;</code>
       * @param value The bytes for deviceSoftwareVersion to set.
       * @return This builder for chaining.
       */
      public Builder setDeviceSoftwareVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        deviceSoftwareVersion_ = value;
        bitField0_ |= 0x00008000;
        onChanged();
        return this;
      }

      private long deviceSoftwareVersionCode_ ;
      /**
       * <pre>
       * The software version number running on the device
       * (e.g., Authenticator app version code)
       * </pre>
       *
       * <code>optional int64 device_software_version_code = 18;</code>
       * @return Whether the deviceSoftwareVersionCode field is set.
       */
      @java.lang.Override
      public boolean hasDeviceSoftwareVersionCode() {
        return ((bitField0_ & 0x00010000) != 0);
      }
      /**
       * <pre>
       * The software version number running on the device
       * (e.g., Authenticator app version code)
       * </pre>
       *
       * <code>optional int64 device_software_version_code = 18;</code>
       * @return The deviceSoftwareVersionCode.
       */
      @java.lang.Override
      public long getDeviceSoftwareVersionCode() {
        return deviceSoftwareVersionCode_;
      }
      /**
       * <pre>
       * The software version number running on the device
       * (e.g., Authenticator app version code)
       * </pre>
       *
       * <code>optional int64 device_software_version_code = 18;</code>
       * @param value The deviceSoftwareVersionCode to set.
       * @return This builder for chaining.
       */
      public Builder setDeviceSoftwareVersionCode(long value) {

        deviceSoftwareVersionCode_ = value;
        bitField0_ |= 0x00010000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The software version number running on the device
       * (e.g., Authenticator app version code)
       * </pre>
       *
       * <code>optional int64 device_software_version_code = 18;</code>
       * @return This builder for chaining.
       */
      public Builder clearDeviceSoftwareVersionCode() {
        bitField0_ = (bitField0_ & ~0x00010000);
        deviceSoftwareVersionCode_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object deviceSoftwarePackage_ = "";
      /**
       * <pre>
       * Software package information if applicable
       * (e.g., com.google.android.apps.authenticator2)
       * </pre>
       *
       * <code>optional string device_software_package = 19;</code>
       * @return Whether the deviceSoftwarePackage field is set.
       */
      public boolean hasDeviceSoftwarePackage() {
        return ((bitField0_ & 0x00020000) != 0);
      }
      /**
       * <pre>
       * Software package information if applicable
       * (e.g., com.google.android.apps.authenticator2)
       * </pre>
       *
       * <code>optional string device_software_package = 19;</code>
       * @return The deviceSoftwarePackage.
       */
      public java.lang.String getDeviceSoftwarePackage() {
        java.lang.Object ref = deviceSoftwarePackage_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            deviceSoftwarePackage_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Software package information if applicable
       * (e.g., com.google.android.apps.authenticator2)
       * </pre>
       *
       * <code>optional string device_software_package = 19;</code>
       * @return The bytes for deviceSoftwarePackage.
       */
      public com.google.protobuf.ByteString
          getDeviceSoftwarePackageBytes() {
        java.lang.Object ref = deviceSoftwarePackage_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          deviceSoftwarePackage_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Software package information if applicable
       * (e.g., com.google.android.apps.authenticator2)
       * </pre>
       *
       * <code>optional string device_software_package = 19;</code>
       * @param value The deviceSoftwarePackage to set.
       * @return This builder for chaining.
       */
      public Builder setDeviceSoftwarePackage(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        deviceSoftwarePackage_ = value;
        bitField0_ |= 0x00020000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Software package information if applicable
       * (e.g., com.google.android.apps.authenticator2)
       * </pre>
       *
       * <code>optional string device_software_package = 19;</code>
       * @return This builder for chaining.
       */
      public Builder clearDeviceSoftwarePackage() {
        deviceSoftwarePackage_ = getDefaultInstance().getDeviceSoftwarePackage();
        bitField0_ = (bitField0_ & ~0x00020000);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Software package information if applicable
       * (e.g., com.google.android.apps.authenticator2)
       * </pre>
       *
       * <code>optional string device_software_package = 19;</code>
       * @param value The bytes for deviceSoftwarePackage to set.
       * @return This builder for chaining.
       */
      public Builder setDeviceSoftwarePackageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        deviceSoftwarePackage_ = value;
        bitField0_ |= 0x00020000;
        onChanged();
        return this;
      }

      private int deviceDisplayDiagonalMils_ ;
      /**
       * <pre>
       * Size of the display in thousandths of an inch (e.g., 7000 mils = 7 in)
       * </pre>
       *
       * <code>optional int32 device_display_diagonal_mils = 22;</code>
       * @return Whether the deviceDisplayDiagonalMils field is set.
       */
      @java.lang.Override
      public boolean hasDeviceDisplayDiagonalMils() {
        return ((bitField0_ & 0x00040000) != 0);
      }
      /**
       * <pre>
       * Size of the display in thousandths of an inch (e.g., 7000 mils = 7 in)
       * </pre>
       *
       * <code>optional int32 device_display_diagonal_mils = 22;</code>
       * @return The deviceDisplayDiagonalMils.
       */
      @java.lang.Override
      public int getDeviceDisplayDiagonalMils() {
        return deviceDisplayDiagonalMils_;
      }
      /**
       * <pre>
       * Size of the display in thousandths of an inch (e.g., 7000 mils = 7 in)
       * </pre>
       *
       * <code>optional int32 device_display_diagonal_mils = 22;</code>
       * @param value The deviceDisplayDiagonalMils to set.
       * @return This builder for chaining.
       */
      public Builder setDeviceDisplayDiagonalMils(int value) {

        deviceDisplayDiagonalMils_ = value;
        bitField0_ |= 0x00040000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Size of the display in thousandths of an inch (e.g., 7000 mils = 7 in)
       * </pre>
       *
       * <code>optional int32 device_display_diagonal_mils = 22;</code>
       * @return This builder for chaining.
       */
      public Builder clearDeviceDisplayDiagonalMils() {
        bitField0_ = (bitField0_ & ~0x00040000);
        deviceDisplayDiagonalMils_ = 0;
        onChanged();
        return this;
      }

      private int deviceAuthzenVersion_ ;
      /**
       * <pre>
       * For Authzen capable devices, their Authzen protocol version
       * </pre>
       *
       * <code>optional int32 device_authzen_version = 24;</code>
       * @return Whether the deviceAuthzenVersion field is set.
       */
      @java.lang.Override
      public boolean hasDeviceAuthzenVersion() {
        return ((bitField0_ & 0x00080000) != 0);
      }
      /**
       * <pre>
       * For Authzen capable devices, their Authzen protocol version
       * </pre>
       *
       * <code>optional int32 device_authzen_version = 24;</code>
       * @return The deviceAuthzenVersion.
       */
      @java.lang.Override
      public int getDeviceAuthzenVersion() {
        return deviceAuthzenVersion_;
      }
      /**
       * <pre>
       * For Authzen capable devices, their Authzen protocol version
       * </pre>
       *
       * <code>optional int32 device_authzen_version = 24;</code>
       * @param value The deviceAuthzenVersion to set.
       * @return This builder for chaining.
       */
      public Builder setDeviceAuthzenVersion(int value) {

        deviceAuthzenVersion_ = value;
        bitField0_ |= 0x00080000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For Authzen capable devices, their Authzen protocol version
       * </pre>
       *
       * <code>optional int32 device_authzen_version = 24;</code>
       * @return This builder for chaining.
       */
      public Builder clearDeviceAuthzenVersion() {
        bitField0_ = (bitField0_ & ~0x00080000);
        deviceAuthzenVersion_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString longDeviceId_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Not all devices have device identifiers that fit in 64 bits.
       * </pre>
       *
       * <code>optional bytes long_device_id = 29;</code>
       * @return Whether the longDeviceId field is set.
       */
      @java.lang.Override
      public boolean hasLongDeviceId() {
        return ((bitField0_ & 0x00100000) != 0);
      }
      /**
       * <pre>
       * Not all devices have device identifiers that fit in 64 bits.
       * </pre>
       *
       * <code>optional bytes long_device_id = 29;</code>
       * @return The longDeviceId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getLongDeviceId() {
        return longDeviceId_;
      }
      /**
       * <pre>
       * Not all devices have device identifiers that fit in 64 bits.
       * </pre>
       *
       * <code>optional bytes long_device_id = 29;</code>
       * @param value The longDeviceId to set.
       * @return This builder for chaining.
       */
      public Builder setLongDeviceId(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        longDeviceId_ = value;
        bitField0_ |= 0x00100000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Not all devices have device identifiers that fit in 64 bits.
       * </pre>
       *
       * <code>optional bytes long_device_id = 29;</code>
       * @return This builder for chaining.
       */
      public Builder clearLongDeviceId() {
        bitField0_ = (bitField0_ & ~0x00100000);
        longDeviceId_ = getDefaultInstance().getLongDeviceId();
        onChanged();
        return this;
      }

      private java.lang.Object deviceManufacturer_ = "";
      /**
       * <pre>
       * The device manufacturer name
       * (e.g., android.os.Build.MANUFACTURER)
       * </pre>
       *
       * <code>optional string device_manufacturer = 31;</code>
       * @return Whether the deviceManufacturer field is set.
       */
      public boolean hasDeviceManufacturer() {
        return ((bitField0_ & 0x00200000) != 0);
      }
      /**
       * <pre>
       * The device manufacturer name
       * (e.g., android.os.Build.MANUFACTURER)
       * </pre>
       *
       * <code>optional string device_manufacturer = 31;</code>
       * @return The deviceManufacturer.
       */
      public java.lang.String getDeviceManufacturer() {
        java.lang.Object ref = deviceManufacturer_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            deviceManufacturer_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The device manufacturer name
       * (e.g., android.os.Build.MANUFACTURER)
       * </pre>
       *
       * <code>optional string device_manufacturer = 31;</code>
       * @return The bytes for deviceManufacturer.
       */
      public com.google.protobuf.ByteString
          getDeviceManufacturerBytes() {
        java.lang.Object ref = deviceManufacturer_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          deviceManufacturer_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The device manufacturer name
       * (e.g., android.os.Build.MANUFACTURER)
       * </pre>
       *
       * <code>optional string device_manufacturer = 31;</code>
       * @param value The deviceManufacturer to set.
       * @return This builder for chaining.
       */
      public Builder setDeviceManufacturer(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        deviceManufacturer_ = value;
        bitField0_ |= 0x00200000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The device manufacturer name
       * (e.g., android.os.Build.MANUFACTURER)
       * </pre>
       *
       * <code>optional string device_manufacturer = 31;</code>
       * @return This builder for chaining.
       */
      public Builder clearDeviceManufacturer() {
        deviceManufacturer_ = getDefaultInstance().getDeviceManufacturer();
        bitField0_ = (bitField0_ & ~0x00200000);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The device manufacturer name
       * (e.g., android.os.Build.MANUFACTURER)
       * </pre>
       *
       * <code>optional string device_manufacturer = 31;</code>
       * @param value The bytes for deviceManufacturer to set.
       * @return This builder for chaining.
       */
      public Builder setDeviceManufacturerBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        deviceManufacturer_ = value;
        bitField0_ |= 0x00200000;
        onChanged();
        return this;
      }

      private int deviceType_ = 1;
      /**
       * <pre>
       * Used to indicate which type of device this is.
       * </pre>
       *
       * <code>optional .securegcm.DeviceType device_type = 32 [default = ANDROID];</code>
       * @return Whether the deviceType field is set.
       */
      @java.lang.Override public boolean hasDeviceType() {
        return ((bitField0_ & 0x00400000) != 0);
      }
      /**
       * <pre>
       * Used to indicate which type of device this is.
       * </pre>
       *
       * <code>optional .securegcm.DeviceType device_type = 32 [default = ANDROID];</code>
       * @return The deviceType.
       */
      @java.lang.Override
      public com.google.security.cryptauth.lib.securegcm.SecureGcmProto.DeviceType getDeviceType() {
        com.google.security.cryptauth.lib.securegcm.SecureGcmProto.DeviceType result = com.google.security.cryptauth.lib.securegcm.SecureGcmProto.DeviceType.forNumber(deviceType_);
        return result == null ? com.google.security.cryptauth.lib.securegcm.SecureGcmProto.DeviceType.ANDROID : result;
      }
      /**
       * <pre>
       * Used to indicate which type of device this is.
       * </pre>
       *
       * <code>optional .securegcm.DeviceType device_type = 32 [default = ANDROID];</code>
       * @param value The deviceType to set.
       * @return This builder for chaining.
       */
      public Builder setDeviceType(com.google.security.cryptauth.lib.securegcm.SecureGcmProto.DeviceType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00400000;
        deviceType_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Used to indicate which type of device this is.
       * </pre>
       *
       * <code>optional .securegcm.DeviceType device_type = 32 [default = ANDROID];</code>
       * @return This builder for chaining.
       */
      public Builder clearDeviceType() {
        bitField0_ = (bitField0_ & ~0x00400000);
        deviceType_ = 1;
        onChanged();
        return this;
      }

      private boolean usingSecureScreenlock_ ;
      /**
       * <pre>
       * Is this device using  a secure screenlock (e.g., pattern or pin unlock)
       * </pre>
       *
       * <code>optional bool using_secure_screenlock = 400 [default = false];</code>
       * @return Whether the usingSecureScreenlock field is set.
       */
      @java.lang.Override
      public boolean hasUsingSecureScreenlock() {
        return ((bitField0_ & 0x00800000) != 0);
      }
      /**
       * <pre>
       * Is this device using  a secure screenlock (e.g., pattern or pin unlock)
       * </pre>
       *
       * <code>optional bool using_secure_screenlock = 400 [default = false];</code>
       * @return The usingSecureScreenlock.
       */
      @java.lang.Override
      public boolean getUsingSecureScreenlock() {
        return usingSecureScreenlock_;
      }
      /**
       * <pre>
       * Is this device using  a secure screenlock (e.g., pattern or pin unlock)
       * </pre>
       *
       * <code>optional bool using_secure_screenlock = 400 [default = false];</code>
       * @param value The usingSecureScreenlock to set.
       * @return This builder for chaining.
       */
      public Builder setUsingSecureScreenlock(boolean value) {

        usingSecureScreenlock_ = value;
        bitField0_ |= 0x00800000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Is this device using  a secure screenlock (e.g., pattern or pin unlock)
       * </pre>
       *
       * <code>optional bool using_secure_screenlock = 400 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUsingSecureScreenlock() {
        bitField0_ = (bitField0_ & ~0x00800000);
        usingSecureScreenlock_ = false;
        onChanged();
        return this;
      }

      private boolean autoUnlockScreenlockSupported_ ;
      /**
       * <pre>
       * Is auto-unlocking the screenlock (e.g., when at "home") supported?
       * </pre>
       *
       * <code>optional bool auto_unlock_screenlock_supported = 401 [default = false];</code>
       * @return Whether the autoUnlockScreenlockSupported field is set.
       */
      @java.lang.Override
      public boolean hasAutoUnlockScreenlockSupported() {
        return ((bitField0_ & 0x01000000) != 0);
      }
      /**
       * <pre>
       * Is auto-unlocking the screenlock (e.g., when at "home") supported?
       * </pre>
       *
       * <code>optional bool auto_unlock_screenlock_supported = 401 [default = false];</code>
       * @return The autoUnlockScreenlockSupported.
       */
      @java.lang.Override
      public boolean getAutoUnlockScreenlockSupported() {
        return autoUnlockScreenlockSupported_;
      }
      /**
       * <pre>
       * Is auto-unlocking the screenlock (e.g., when at "home") supported?
       * </pre>
       *
       * <code>optional bool auto_unlock_screenlock_supported = 401 [default = false];</code>
       * @param value The autoUnlockScreenlockSupported to set.
       * @return This builder for chaining.
       */
      public Builder setAutoUnlockScreenlockSupported(boolean value) {

        autoUnlockScreenlockSupported_ = value;
        bitField0_ |= 0x01000000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Is auto-unlocking the screenlock (e.g., when at "home") supported?
       * </pre>
       *
       * <code>optional bool auto_unlock_screenlock_supported = 401 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearAutoUnlockScreenlockSupported() {
        bitField0_ = (bitField0_ & ~0x01000000);
        autoUnlockScreenlockSupported_ = false;
        onChanged();
        return this;
      }

      private boolean autoUnlockScreenlockEnabled_ ;
      /**
       * <pre>
       * Is auto-unlocking the screenlock (e.g., when at "home") enabled?
       * </pre>
       *
       * <code>optional bool auto_unlock_screenlock_enabled = 402 [default = false];</code>
       * @return Whether the autoUnlockScreenlockEnabled field is set.
       */
      @java.lang.Override
      public boolean hasAutoUnlockScreenlockEnabled() {
        return ((bitField0_ & 0x02000000) != 0);
      }
      /**
       * <pre>
       * Is auto-unlocking the screenlock (e.g., when at "home") enabled?
       * </pre>
       *
       * <code>optional bool auto_unlock_screenlock_enabled = 402 [default = false];</code>
       * @return The autoUnlockScreenlockEnabled.
       */
      @java.lang.Override
      public boolean getAutoUnlockScreenlockEnabled() {
        return autoUnlockScreenlockEnabled_;
      }
      /**
       * <pre>
       * Is auto-unlocking the screenlock (e.g., when at "home") enabled?
       * </pre>
       *
       * <code>optional bool auto_unlock_screenlock_enabled = 402 [default = false];</code>
       * @param value The autoUnlockScreenlockEnabled to set.
       * @return This builder for chaining.
       */
      public Builder setAutoUnlockScreenlockEnabled(boolean value) {

        autoUnlockScreenlockEnabled_ = value;
        bitField0_ |= 0x02000000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Is auto-unlocking the screenlock (e.g., when at "home") enabled?
       * </pre>
       *
       * <code>optional bool auto_unlock_screenlock_enabled = 402 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearAutoUnlockScreenlockEnabled() {
        bitField0_ = (bitField0_ & ~0x02000000);
        autoUnlockScreenlockEnabled_ = false;
        onChanged();
        return this;
      }

      private boolean bluetoothRadioSupported_ ;
      /**
       * <pre>
       * Does the device have a Bluetooth (classic) radio?
       * </pre>
       *
       * <code>optional bool bluetooth_radio_supported = 403 [default = false];</code>
       * @return Whether the bluetoothRadioSupported field is set.
       */
      @java.lang.Override
      public boolean hasBluetoothRadioSupported() {
        return ((bitField0_ & 0x04000000) != 0);
      }
      /**
       * <pre>
       * Does the device have a Bluetooth (classic) radio?
       * </pre>
       *
       * <code>optional bool bluetooth_radio_supported = 403 [default = false];</code>
       * @return The bluetoothRadioSupported.
       */
      @java.lang.Override
      public boolean getBluetoothRadioSupported() {
        return bluetoothRadioSupported_;
      }
      /**
       * <pre>
       * Does the device have a Bluetooth (classic) radio?
       * </pre>
       *
       * <code>optional bool bluetooth_radio_supported = 403 [default = false];</code>
       * @param value The bluetoothRadioSupported to set.
       * @return This builder for chaining.
       */
      public Builder setBluetoothRadioSupported(boolean value) {

        bluetoothRadioSupported_ = value;
        bitField0_ |= 0x04000000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Does the device have a Bluetooth (classic) radio?
       * </pre>
       *
       * <code>optional bool bluetooth_radio_supported = 403 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearBluetoothRadioSupported() {
        bitField0_ = (bitField0_ & ~0x04000000);
        bluetoothRadioSupported_ = false;
        onChanged();
        return this;
      }

      private boolean bluetoothRadioEnabled_ ;
      /**
       * <pre>
       * Is the Bluetooth (classic) radio on?
       * </pre>
       *
       * <code>optional bool bluetooth_radio_enabled = 404 [default = false];</code>
       * @return Whether the bluetoothRadioEnabled field is set.
       */
      @java.lang.Override
      public boolean hasBluetoothRadioEnabled() {
        return ((bitField0_ & 0x08000000) != 0);
      }
      /**
       * <pre>
       * Is the Bluetooth (classic) radio on?
       * </pre>
       *
       * <code>optional bool bluetooth_radio_enabled = 404 [default = false];</code>
       * @return The bluetoothRadioEnabled.
       */
      @java.lang.Override
      public boolean getBluetoothRadioEnabled() {
        return bluetoothRadioEnabled_;
      }
      /**
       * <pre>
       * Is the Bluetooth (classic) radio on?
       * </pre>
       *
       * <code>optional bool bluetooth_radio_enabled = 404 [default = false];</code>
       * @param value The bluetoothRadioEnabled to set.
       * @return This builder for chaining.
       */
      public Builder setBluetoothRadioEnabled(boolean value) {

        bluetoothRadioEnabled_ = value;
        bitField0_ |= 0x08000000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Is the Bluetooth (classic) radio on?
       * </pre>
       *
       * <code>optional bool bluetooth_radio_enabled = 404 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearBluetoothRadioEnabled() {
        bitField0_ = (bitField0_ & ~0x08000000);
        bluetoothRadioEnabled_ = false;
        onChanged();
        return this;
      }

      private boolean mobileDataSupported_ ;
      /**
       * <pre>
       * Does the device hardware support a mobile data connection?
       * </pre>
       *
       * <code>optional bool mobile_data_supported = 405 [default = false];</code>
       * @return Whether the mobileDataSupported field is set.
       */
      @java.lang.Override
      public boolean hasMobileDataSupported() {
        return ((bitField0_ & 0x10000000) != 0);
      }
      /**
       * <pre>
       * Does the device hardware support a mobile data connection?
       * </pre>
       *
       * <code>optional bool mobile_data_supported = 405 [default = false];</code>
       * @return The mobileDataSupported.
       */
      @java.lang.Override
      public boolean getMobileDataSupported() {
        return mobileDataSupported_;
      }
      /**
       * <pre>
       * Does the device hardware support a mobile data connection?
       * </pre>
       *
       * <code>optional bool mobile_data_supported = 405 [default = false];</code>
       * @param value The mobileDataSupported to set.
       * @return This builder for chaining.
       */
      public Builder setMobileDataSupported(boolean value) {

        mobileDataSupported_ = value;
        bitField0_ |= 0x10000000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Does the device hardware support a mobile data connection?
       * </pre>
       *
       * <code>optional bool mobile_data_supported = 405 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearMobileDataSupported() {
        bitField0_ = (bitField0_ & ~0x10000000);
        mobileDataSupported_ = false;
        onChanged();
        return this;
      }

      private boolean tetheringSupported_ ;
      /**
       * <pre>
       * Does the device support tethering?
       * </pre>
       *
       * <code>optional bool tethering_supported = 406 [default = false];</code>
       * @return Whether the tetheringSupported field is set.
       */
      @java.lang.Override
      public boolean hasTetheringSupported() {
        return ((bitField0_ & 0x20000000) != 0);
      }
      /**
       * <pre>
       * Does the device support tethering?
       * </pre>
       *
       * <code>optional bool tethering_supported = 406 [default = false];</code>
       * @return The tetheringSupported.
       */
      @java.lang.Override
      public boolean getTetheringSupported() {
        return tetheringSupported_;
      }
      /**
       * <pre>
       * Does the device support tethering?
       * </pre>
       *
       * <code>optional bool tethering_supported = 406 [default = false];</code>
       * @param value The tetheringSupported to set.
       * @return This builder for chaining.
       */
      public Builder setTetheringSupported(boolean value) {

        tetheringSupported_ = value;
        bitField0_ |= 0x20000000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Does the device support tethering?
       * </pre>
       *
       * <code>optional bool tethering_supported = 406 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearTetheringSupported() {
        bitField0_ = (bitField0_ & ~0x20000000);
        tetheringSupported_ = false;
        onChanged();
        return this;
      }

      private boolean bleRadioSupported_ ;
      /**
       * <pre>
       * Does the device have a BLE radio?
       * </pre>
       *
       * <code>optional bool ble_radio_supported = 407 [default = false];</code>
       * @return Whether the bleRadioSupported field is set.
       */
      @java.lang.Override
      public boolean hasBleRadioSupported() {
        return ((bitField0_ & 0x40000000) != 0);
      }
      /**
       * <pre>
       * Does the device have a BLE radio?
       * </pre>
       *
       * <code>optional bool ble_radio_supported = 407 [default = false];</code>
       * @return The bleRadioSupported.
       */
      @java.lang.Override
      public boolean getBleRadioSupported() {
        return bleRadioSupported_;
      }
      /**
       * <pre>
       * Does the device have a BLE radio?
       * </pre>
       *
       * <code>optional bool ble_radio_supported = 407 [default = false];</code>
       * @param value The bleRadioSupported to set.
       * @return This builder for chaining.
       */
      public Builder setBleRadioSupported(boolean value) {

        bleRadioSupported_ = value;
        bitField0_ |= 0x40000000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Does the device have a BLE radio?
       * </pre>
       *
       * <code>optional bool ble_radio_supported = 407 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearBleRadioSupported() {
        bitField0_ = (bitField0_ & ~0x40000000);
        bleRadioSupported_ = false;
        onChanged();
        return this;
      }

      private boolean pixelExperience_ ;
      /**
       * <pre>
       * Is the device a "Pixel Experience" Android device?
       * </pre>
       *
       * <code>optional bool pixel_experience = 408 [default = false];</code>
       * @return Whether the pixelExperience field is set.
       */
      @java.lang.Override
      public boolean hasPixelExperience() {
        return ((bitField0_ & 0x80000000) != 0);
      }
      /**
       * <pre>
       * Is the device a "Pixel Experience" Android device?
       * </pre>
       *
       * <code>optional bool pixel_experience = 408 [default = false];</code>
       * @return The pixelExperience.
       */
      @java.lang.Override
      public boolean getPixelExperience() {
        return pixelExperience_;
      }
      /**
       * <pre>
       * Is the device a "Pixel Experience" Android device?
       * </pre>
       *
       * <code>optional bool pixel_experience = 408 [default = false];</code>
       * @param value The pixelExperience to set.
       * @return This builder for chaining.
       */
      public Builder setPixelExperience(boolean value) {

        pixelExperience_ = value;
        bitField0_ |= 0x80000000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Is the device a "Pixel Experience" Android device?
       * </pre>
       *
       * <code>optional bool pixel_experience = 408 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearPixelExperience() {
        bitField0_ = (bitField0_ & ~0x80000000);
        pixelExperience_ = false;
        onChanged();
        return this;
      }

      private boolean arcPlusPlus_ ;
      /**
       * <pre>
       * Is the device running in the ARC++ container on a chromebook?
       * </pre>
       *
       * <code>optional bool arc_plus_plus = 409 [default = false];</code>
       * @return Whether the arcPlusPlus field is set.
       */
      @java.lang.Override
      public boolean hasArcPlusPlus() {
        return ((bitField1_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Is the device running in the ARC++ container on a chromebook?
       * </pre>
       *
       * <code>optional bool arc_plus_plus = 409 [default = false];</code>
       * @return The arcPlusPlus.
       */
      @java.lang.Override
      public boolean getArcPlusPlus() {
        return arcPlusPlus_;
      }
      /**
       * <pre>
       * Is the device running in the ARC++ container on a chromebook?
       * </pre>
       *
       * <code>optional bool arc_plus_plus = 409 [default = false];</code>
       * @param value The arcPlusPlus to set.
       * @return This builder for chaining.
       */
      public Builder setArcPlusPlus(boolean value) {

        arcPlusPlus_ = value;
        bitField1_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Is the device running in the ARC++ container on a chromebook?
       * </pre>
       *
       * <code>optional bool arc_plus_plus = 409 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearArcPlusPlus() {
        bitField1_ = (bitField1_ & ~0x00000001);
        arcPlusPlus_ = false;
        onChanged();
        return this;
      }

      private boolean isScreenlockStateFlaky_ ;
      /**
       * <pre>
       * Is the value set in |using_secure_screenlock| reliable? On some Android
       * devices, the platform API to get the screenlock state is not trustworthy.
       * See b/32212161.
       * </pre>
       *
       * <code>optional bool is_screenlock_state_flaky = 410 [default = false];</code>
       * @return Whether the isScreenlockStateFlaky field is set.
       */
      @java.lang.Override
      public boolean hasIsScreenlockStateFlaky() {
        return ((bitField1_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Is the value set in |using_secure_screenlock| reliable? On some Android
       * devices, the platform API to get the screenlock state is not trustworthy.
       * See b/32212161.
       * </pre>
       *
       * <code>optional bool is_screenlock_state_flaky = 410 [default = false];</code>
       * @return The isScreenlockStateFlaky.
       */
      @java.lang.Override
      public boolean getIsScreenlockStateFlaky() {
        return isScreenlockStateFlaky_;
      }
      /**
       * <pre>
       * Is the value set in |using_secure_screenlock| reliable? On some Android
       * devices, the platform API to get the screenlock state is not trustworthy.
       * See b/32212161.
       * </pre>
       *
       * <code>optional bool is_screenlock_state_flaky = 410 [default = false];</code>
       * @param value The isScreenlockStateFlaky to set.
       * @return This builder for chaining.
       */
      public Builder setIsScreenlockStateFlaky(boolean value) {

        isScreenlockStateFlaky_ = value;
        bitField1_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Is the value set in |using_secure_screenlock| reliable? On some Android
       * devices, the platform API to get the screenlock state is not trustworthy.
       * See b/32212161.
       * </pre>
       *
       * <code>optional bool is_screenlock_state_flaky = 410 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearIsScreenlockStateFlaky() {
        bitField1_ = (bitField1_ & ~0x00000002);
        isScreenlockStateFlaky_ = false;
        onChanged();
        return this;
      }

      private java.util.List<java.lang.Integer> supportedSoftwareFeatures_ =
        java.util.Collections.emptyList();
      private void ensureSupportedSoftwareFeaturesIsMutable() {
        if (!((bitField1_ & 0x00000004) != 0)) {
          supportedSoftwareFeatures_ = new java.util.ArrayList<java.lang.Integer>(supportedSoftwareFeatures_);
          bitField1_ |= 0x00000004;
        }
      }
      /**
       * <pre>
       * A list of multi-device software features supported by the device.
       * </pre>
       *
       * <code>repeated .securegcm.SoftwareFeature supported_software_features = 411;</code>
       * @return A list containing the supportedSoftwareFeatures.
       */
      public java.util.List<com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature> getSupportedSoftwareFeaturesList() {
        return new com.google.protobuf.Internal.ListAdapter<
            java.lang.Integer, com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature>(supportedSoftwareFeatures_, supportedSoftwareFeatures_converter_);
      }
      /**
       * <pre>
       * A list of multi-device software features supported by the device.
       * </pre>
       *
       * <code>repeated .securegcm.SoftwareFeature supported_software_features = 411;</code>
       * @return The count of supportedSoftwareFeatures.
       */
      public int getSupportedSoftwareFeaturesCount() {
        return supportedSoftwareFeatures_.size();
      }
      /**
       * <pre>
       * A list of multi-device software features supported by the device.
       * </pre>
       *
       * <code>repeated .securegcm.SoftwareFeature supported_software_features = 411;</code>
       * @param index The index of the element to return.
       * @return The supportedSoftwareFeatures at the given index.
       */
      public com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature getSupportedSoftwareFeatures(int index) {
        return supportedSoftwareFeatures_converter_.convert(supportedSoftwareFeatures_.get(index));
      }
      /**
       * <pre>
       * A list of multi-device software features supported by the device.
       * </pre>
       *
       * <code>repeated .securegcm.SoftwareFeature supported_software_features = 411;</code>
       * @param index The index to set the value at.
       * @param value The supportedSoftwareFeatures to set.
       * @return This builder for chaining.
       */
      public Builder setSupportedSoftwareFeatures(
          int index, com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureSupportedSoftwareFeaturesIsMutable();
        supportedSoftwareFeatures_.set(index, value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of multi-device software features supported by the device.
       * </pre>
       *
       * <code>repeated .securegcm.SoftwareFeature supported_software_features = 411;</code>
       * @param value The supportedSoftwareFeatures to add.
       * @return This builder for chaining.
       */
      public Builder addSupportedSoftwareFeatures(com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureSupportedSoftwareFeaturesIsMutable();
        supportedSoftwareFeatures_.add(value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of multi-device software features supported by the device.
       * </pre>
       *
       * <code>repeated .securegcm.SoftwareFeature supported_software_features = 411;</code>
       * @param values The supportedSoftwareFeatures to add.
       * @return This builder for chaining.
       */
      public Builder addAllSupportedSoftwareFeatures(
          java.lang.Iterable<? extends com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature> values) {
        ensureSupportedSoftwareFeaturesIsMutable();
        for (com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature value : values) {
          supportedSoftwareFeatures_.add(value.getNumber());
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of multi-device software features supported by the device.
       * </pre>
       *
       * <code>repeated .securegcm.SoftwareFeature supported_software_features = 411;</code>
       * @return This builder for chaining.
       */
      public Builder clearSupportedSoftwareFeatures() {
        supportedSoftwareFeatures_ = java.util.Collections.emptyList();
        bitField1_ = (bitField1_ & ~0x00000004);
        onChanged();
        return this;
      }

      private java.util.List<java.lang.Integer> enabledSoftwareFeatures_ =
        java.util.Collections.emptyList();
      private void ensureEnabledSoftwareFeaturesIsMutable() {
        if (!((bitField1_ & 0x00000008) != 0)) {
          enabledSoftwareFeatures_ = new java.util.ArrayList<java.lang.Integer>(enabledSoftwareFeatures_);
          bitField1_ |= 0x00000008;
        }
      }
      /**
       * <pre>
       * A list of multi-device software features currently enabled (active) on the
       * device.
       * </pre>
       *
       * <code>repeated .securegcm.SoftwareFeature enabled_software_features = 412;</code>
       * @return A list containing the enabledSoftwareFeatures.
       */
      public java.util.List<com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature> getEnabledSoftwareFeaturesList() {
        return new com.google.protobuf.Internal.ListAdapter<
            java.lang.Integer, com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature>(enabledSoftwareFeatures_, enabledSoftwareFeatures_converter_);
      }
      /**
       * <pre>
       * A list of multi-device software features currently enabled (active) on the
       * device.
       * </pre>
       *
       * <code>repeated .securegcm.SoftwareFeature enabled_software_features = 412;</code>
       * @return The count of enabledSoftwareFeatures.
       */
      public int getEnabledSoftwareFeaturesCount() {
        return enabledSoftwareFeatures_.size();
      }
      /**
       * <pre>
       * A list of multi-device software features currently enabled (active) on the
       * device.
       * </pre>
       *
       * <code>repeated .securegcm.SoftwareFeature enabled_software_features = 412;</code>
       * @param index The index of the element to return.
       * @return The enabledSoftwareFeatures at the given index.
       */
      public com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature getEnabledSoftwareFeatures(int index) {
        return enabledSoftwareFeatures_converter_.convert(enabledSoftwareFeatures_.get(index));
      }
      /**
       * <pre>
       * A list of multi-device software features currently enabled (active) on the
       * device.
       * </pre>
       *
       * <code>repeated .securegcm.SoftwareFeature enabled_software_features = 412;</code>
       * @param index The index to set the value at.
       * @param value The enabledSoftwareFeatures to set.
       * @return This builder for chaining.
       */
      public Builder setEnabledSoftwareFeatures(
          int index, com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureEnabledSoftwareFeaturesIsMutable();
        enabledSoftwareFeatures_.set(index, value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of multi-device software features currently enabled (active) on the
       * device.
       * </pre>
       *
       * <code>repeated .securegcm.SoftwareFeature enabled_software_features = 412;</code>
       * @param value The enabledSoftwareFeatures to add.
       * @return This builder for chaining.
       */
      public Builder addEnabledSoftwareFeatures(com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureEnabledSoftwareFeaturesIsMutable();
        enabledSoftwareFeatures_.add(value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of multi-device software features currently enabled (active) on the
       * device.
       * </pre>
       *
       * <code>repeated .securegcm.SoftwareFeature enabled_software_features = 412;</code>
       * @param values The enabledSoftwareFeatures to add.
       * @return This builder for chaining.
       */
      public Builder addAllEnabledSoftwareFeatures(
          java.lang.Iterable<? extends com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature> values) {
        ensureEnabledSoftwareFeaturesIsMutable();
        for (com.google.security.cryptauth.lib.securegcm.SecureGcmProto.SoftwareFeature value : values) {
          enabledSoftwareFeatures_.add(value.getNumber());
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of multi-device software features currently enabled (active) on the
       * device.
       * </pre>
       *
       * <code>repeated .securegcm.SoftwareFeature enabled_software_features = 412;</code>
       * @return This builder for chaining.
       */
      public Builder clearEnabledSoftwareFeatures() {
        enabledSoftwareFeatures_ = java.util.Collections.emptyList();
        bitField1_ = (bitField1_ & ~0x00000008);
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString enrollmentSessionId_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * The enrollment session id this is sent with
       * </pre>
       *
       * <code>optional bytes enrollment_session_id = 1000;</code>
       * @return Whether the enrollmentSessionId field is set.
       */
      @java.lang.Override
      public boolean hasEnrollmentSessionId() {
        return ((bitField1_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * The enrollment session id this is sent with
       * </pre>
       *
       * <code>optional bytes enrollment_session_id = 1000;</code>
       * @return The enrollmentSessionId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getEnrollmentSessionId() {
        return enrollmentSessionId_;
      }
      /**
       * <pre>
       * The enrollment session id this is sent with
       * </pre>
       *
       * <code>optional bytes enrollment_session_id = 1000;</code>
       * @param value The enrollmentSessionId to set.
       * @return This builder for chaining.
       */
      public Builder setEnrollmentSessionId(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        enrollmentSessionId_ = value;
        bitField1_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The enrollment session id this is sent with
       * </pre>
       *
       * <code>optional bytes enrollment_session_id = 1000;</code>
       * @return This builder for chaining.
       */
      public Builder clearEnrollmentSessionId() {
        bitField1_ = (bitField1_ & ~0x00000010);
        enrollmentSessionId_ = getDefaultInstance().getEnrollmentSessionId();
        onChanged();
        return this;
      }

      private java.lang.Object oauthToken_ = "";
      /**
       * <pre>
       * A copy of the user's OAuth token
       * </pre>
       *
       * <code>optional string oauth_token = 1001;</code>
       * @return Whether the oauthToken field is set.
       */
      public boolean hasOauthToken() {
        return ((bitField1_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * A copy of the user's OAuth token
       * </pre>
       *
       * <code>optional string oauth_token = 1001;</code>
       * @return The oauthToken.
       */
      public java.lang.String getOauthToken() {
        java.lang.Object ref = oauthToken_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            oauthToken_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A copy of the user's OAuth token
       * </pre>
       *
       * <code>optional string oauth_token = 1001;</code>
       * @return The bytes for oauthToken.
       */
      public com.google.protobuf.ByteString
          getOauthTokenBytes() {
        java.lang.Object ref = oauthToken_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          oauthToken_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A copy of the user's OAuth token
       * </pre>
       *
       * <code>optional string oauth_token = 1001;</code>
       * @param value The oauthToken to set.
       * @return This builder for chaining.
       */
      public Builder setOauthToken(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        oauthToken_ = value;
        bitField1_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A copy of the user's OAuth token
       * </pre>
       *
       * <code>optional string oauth_token = 1001;</code>
       * @return This builder for chaining.
       */
      public Builder clearOauthToken() {
        oauthToken_ = getDefaultInstance().getOauthToken();
        bitField1_ = (bitField1_ & ~0x00000020);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A copy of the user's OAuth token
       * </pre>
       *
       * <code>optional string oauth_token = 1001;</code>
       * @param value The bytes for oauthToken to set.
       * @return This builder for chaining.
       */
      public Builder setOauthTokenBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        oauthToken_ = value;
        bitField1_ |= 0x00000020;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:securegcm.GcmDeviceInfo)
    }

    // @@protoc_insertion_point(class_scope:securegcm.GcmDeviceInfo)
    private static final com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo();
    }

    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GcmDeviceInfo>
        PARSER = new com.google.protobuf.AbstractParser<GcmDeviceInfo>() {
      @java.lang.Override
      public GcmDeviceInfo parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<GcmDeviceInfo> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GcmDeviceInfo> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmDeviceInfo getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface GcmMetadataOrBuilder extends
      // @@protoc_insertion_point(interface_extends:securegcm.GcmMetadata)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>required .securegcm.Type type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <code>required .securegcm.Type type = 1;</code>
     * @return The type.
     */
    com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Type getType();

    /**
     * <code>optional int32 version = 2 [default = 0];</code>
     * @return Whether the version field is set.
     */
    boolean hasVersion();
    /**
     * <code>optional int32 version = 2 [default = 0];</code>
     * @return The version.
     */
    int getVersion();
  }
  /**
   * Protobuf type {@code securegcm.GcmMetadata}
   */
  public static final class GcmMetadata extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:securegcm.GcmMetadata)
      GcmMetadataOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        GcmMetadata.class.getName());
    }
    // Use GcmMetadata.newBuilder() to construct.
    private GcmMetadata(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private GcmMetadata() {
      type_ = 0;
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.internal_static_securegcm_GcmMetadata_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.internal_static_securegcm_GcmMetadata_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata.class, com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata.Builder.class);
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private int type_ = 0;
    /**
     * <code>required .securegcm.Type type = 1;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>required .securegcm.Type type = 1;</code>
     * @return The type.
     */
    @java.lang.Override public com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Type getType() {
      com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Type result = com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Type.forNumber(type_);
      return result == null ? com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Type.ENROLLMENT : result;
    }

    public static final int VERSION_FIELD_NUMBER = 2;
    private int version_ = 0;
    /**
     * <code>optional int32 version = 2 [default = 0];</code>
     * @return Whether the version field is set.
     */
    @java.lang.Override
    public boolean hasVersion() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional int32 version = 2 [default = 0];</code>
     * @return The version.
     */
    @java.lang.Override
    public int getVersion() {
      return version_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasType()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeEnum(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt32(2, version_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, version_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata)) {
        return super.equals(obj);
      }
      com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata other = (com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata) obj;

      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (type_ != other.type_) return false;
      }
      if (hasVersion() != other.hasVersion()) return false;
      if (hasVersion()) {
        if (getVersion()
            != other.getVersion()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + type_;
      }
      if (hasVersion()) {
        hash = (37 * hash) + VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getVersion();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code securegcm.GcmMetadata}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:securegcm.GcmMetadata)
        com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadataOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.internal_static_securegcm_GcmMetadata_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.internal_static_securegcm_GcmMetadata_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata.class, com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata.Builder.class);
      }

      // Construct using com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        type_ = 0;
        version_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.internal_static_securegcm_GcmMetadata_descriptor;
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata getDefaultInstanceForType() {
        return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata build() {
        com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata buildPartial() {
        com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata result = new com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.type_ = type_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.version_ = version_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata) {
          return mergeFrom((com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata other) {
        if (other == com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata.getDefaultInstance()) return this;
        if (other.hasType()) {
          setType(other.getType());
        }
        if (other.hasVersion()) {
          setVersion(other.getVersion());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasType()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                int tmpRaw = input.readEnum();
                com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Type tmpValue =
                    com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Type.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(1, tmpRaw);
                } else {
                  type_ = tmpRaw;
                  bitField0_ |= 0x00000001;
                }
                break;
              } // case 8
              case 16: {
                version_ = input.readInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int type_ = 0;
      /**
       * <code>required .securegcm.Type type = 1;</code>
       * @return Whether the type field is set.
       */
      @java.lang.Override public boolean hasType() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>required .securegcm.Type type = 1;</code>
       * @return The type.
       */
      @java.lang.Override
      public com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Type getType() {
        com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Type result = com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Type.forNumber(type_);
        return result == null ? com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Type.ENROLLMENT : result;
      }
      /**
       * <code>required .securegcm.Type type = 1;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Type value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        type_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>required .securegcm.Type type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000001);
        type_ = 0;
        onChanged();
        return this;
      }

      private int version_ ;
      /**
       * <code>optional int32 version = 2 [default = 0];</code>
       * @return Whether the version field is set.
       */
      @java.lang.Override
      public boolean hasVersion() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional int32 version = 2 [default = 0];</code>
       * @return The version.
       */
      @java.lang.Override
      public int getVersion() {
        return version_;
      }
      /**
       * <code>optional int32 version = 2 [default = 0];</code>
       * @param value The version to set.
       * @return This builder for chaining.
       */
      public Builder setVersion(int value) {

        version_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 version = 2 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearVersion() {
        bitField0_ = (bitField0_ & ~0x00000002);
        version_ = 0;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:securegcm.GcmMetadata)
    }

    // @@protoc_insertion_point(class_scope:securegcm.GcmMetadata)
    private static final com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata();
    }

    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GcmMetadata>
        PARSER = new com.google.protobuf.AbstractParser<GcmMetadata>() {
      @java.lang.Override
      public GcmMetadata parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<GcmMetadata> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GcmMetadata> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.security.cryptauth.lib.securegcm.SecureGcmProto.GcmMetadata getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TickleOrBuilder extends
      // @@protoc_insertion_point(interface_extends:securegcm.Tickle)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Time after which this tickle should expire
     * </pre>
     *
     * <code>optional fixed64 expiry_time = 1;</code>
     * @return Whether the expiryTime field is set.
     */
    boolean hasExpiryTime();
    /**
     * <pre>
     * Time after which this tickle should expire
     * </pre>
     *
     * <code>optional fixed64 expiry_time = 1;</code>
     * @return The expiryTime.
     */
    long getExpiryTime();
  }
  /**
   * Protobuf type {@code securegcm.Tickle}
   */
  public static final class Tickle extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:securegcm.Tickle)
      TickleOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        Tickle.class.getName());
    }
    // Use Tickle.newBuilder() to construct.
    private Tickle(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private Tickle() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.internal_static_securegcm_Tickle_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.internal_static_securegcm_Tickle_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle.class, com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle.Builder.class);
    }

    private int bitField0_;
    public static final int EXPIRY_TIME_FIELD_NUMBER = 1;
    private long expiryTime_ = 0L;
    /**
     * <pre>
     * Time after which this tickle should expire
     * </pre>
     *
     * <code>optional fixed64 expiry_time = 1;</code>
     * @return Whether the expiryTime field is set.
     */
    @java.lang.Override
    public boolean hasExpiryTime() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Time after which this tickle should expire
     * </pre>
     *
     * <code>optional fixed64 expiry_time = 1;</code>
     * @return The expiryTime.
     */
    @java.lang.Override
    public long getExpiryTime() {
      return expiryTime_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeFixed64(1, expiryTime_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFixed64Size(1, expiryTime_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle)) {
        return super.equals(obj);
      }
      com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle other = (com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle) obj;

      if (hasExpiryTime() != other.hasExpiryTime()) return false;
      if (hasExpiryTime()) {
        if (getExpiryTime()
            != other.getExpiryTime()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasExpiryTime()) {
        hash = (37 * hash) + EXPIRY_TIME_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getExpiryTime());
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code securegcm.Tickle}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:securegcm.Tickle)
        com.google.security.cryptauth.lib.securegcm.SecureGcmProto.TickleOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.internal_static_securegcm_Tickle_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.internal_static_securegcm_Tickle_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle.class, com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle.Builder.class);
      }

      // Construct using com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        expiryTime_ = 0L;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.internal_static_securegcm_Tickle_descriptor;
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle getDefaultInstanceForType() {
        return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle build() {
        com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle buildPartial() {
        com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle result = new com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.expiryTime_ = expiryTime_;
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle) {
          return mergeFrom((com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle other) {
        if (other == com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle.getDefaultInstance()) return this;
        if (other.hasExpiryTime()) {
          setExpiryTime(other.getExpiryTime());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 9: {
                expiryTime_ = input.readFixed64();
                bitField0_ |= 0x00000001;
                break;
              } // case 9
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long expiryTime_ ;
      /**
       * <pre>
       * Time after which this tickle should expire
       * </pre>
       *
       * <code>optional fixed64 expiry_time = 1;</code>
       * @return Whether the expiryTime field is set.
       */
      @java.lang.Override
      public boolean hasExpiryTime() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Time after which this tickle should expire
       * </pre>
       *
       * <code>optional fixed64 expiry_time = 1;</code>
       * @return The expiryTime.
       */
      @java.lang.Override
      public long getExpiryTime() {
        return expiryTime_;
      }
      /**
       * <pre>
       * Time after which this tickle should expire
       * </pre>
       *
       * <code>optional fixed64 expiry_time = 1;</code>
       * @param value The expiryTime to set.
       * @return This builder for chaining.
       */
      public Builder setExpiryTime(long value) {

        expiryTime_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Time after which this tickle should expire
       * </pre>
       *
       * <code>optional fixed64 expiry_time = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearExpiryTime() {
        bitField0_ = (bitField0_ & ~0x00000001);
        expiryTime_ = 0L;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:securegcm.Tickle)
    }

    // @@protoc_insertion_point(class_scope:securegcm.Tickle)
    private static final com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle();
    }

    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Tickle>
        PARSER = new com.google.protobuf.AbstractParser<Tickle>() {
      @java.lang.Override
      public Tickle parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Tickle> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Tickle> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.security.cryptauth.lib.securegcm.SecureGcmProto.Tickle getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface LoginNotificationInfoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:securegcm.LoginNotificationInfo)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Time at which the server received the login notification request.
     * </pre>
     *
     * <code>optional fixed64 creation_time = 2;</code>
     * @return Whether the creationTime field is set.
     */
    boolean hasCreationTime();
    /**
     * <pre>
     * Time at which the server received the login notification request.
     * </pre>
     *
     * <code>optional fixed64 creation_time = 2;</code>
     * @return The creationTime.
     */
    long getCreationTime();

    /**
     * <pre>
     * Must correspond to user_id in LoginNotificationRequest, if set.
     * </pre>
     *
     * <code>optional string email = 3;</code>
     * @return Whether the email field is set.
     */
    boolean hasEmail();
    /**
     * <pre>
     * Must correspond to user_id in LoginNotificationRequest, if set.
     * </pre>
     *
     * <code>optional string email = 3;</code>
     * @return The email.
     */
    java.lang.String getEmail();
    /**
     * <pre>
     * Must correspond to user_id in LoginNotificationRequest, if set.
     * </pre>
     *
     * <code>optional string email = 3;</code>
     * @return The bytes for email.
     */
    com.google.protobuf.ByteString
        getEmailBytes();

    /**
     * <pre>
     * Host where the user's credentials were used to login, if meaningful.
     * </pre>
     *
     * <code>optional string host = 4;</code>
     * @return Whether the host field is set.
     */
    boolean hasHost();
    /**
     * <pre>
     * Host where the user's credentials were used to login, if meaningful.
     * </pre>
     *
     * <code>optional string host = 4;</code>
     * @return The host.
     */
    java.lang.String getHost();
    /**
     * <pre>
     * Host where the user's credentials were used to login, if meaningful.
     * </pre>
     *
     * <code>optional string host = 4;</code>
     * @return The bytes for host.
     */
    com.google.protobuf.ByteString
        getHostBytes();

    /**
     * <pre>
     * Location from where the user's credentials were used, if meaningful.
     * </pre>
     *
     * <code>optional string source = 5;</code>
     * @return Whether the source field is set.
     */
    boolean hasSource();
    /**
     * <pre>
     * Location from where the user's credentials were used, if meaningful.
     * </pre>
     *
     * <code>optional string source = 5;</code>
     * @return The source.
     */
    java.lang.String getSource();
    /**
     * <pre>
     * Location from where the user's credentials were used, if meaningful.
     * </pre>
     *
     * <code>optional string source = 5;</code>
     * @return The bytes for source.
     */
    com.google.protobuf.ByteString
        getSourceBytes();

    /**
     * <pre>
     * Type of login, e.g. ssh, gnome-screensaver, or web.
     * </pre>
     *
     * <code>optional string event_type = 6;</code>
     * @return Whether the eventType field is set.
     */
    boolean hasEventType();
    /**
     * <pre>
     * Type of login, e.g. ssh, gnome-screensaver, or web.
     * </pre>
     *
     * <code>optional string event_type = 6;</code>
     * @return The eventType.
     */
    java.lang.String getEventType();
    /**
     * <pre>
     * Type of login, e.g. ssh, gnome-screensaver, or web.
     * </pre>
     *
     * <code>optional string event_type = 6;</code>
     * @return The bytes for eventType.
     */
    com.google.protobuf.ByteString
        getEventTypeBytes();
  }
  /**
   * Protobuf type {@code securegcm.LoginNotificationInfo}
   */
  public static final class LoginNotificationInfo extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:securegcm.LoginNotificationInfo)
      LoginNotificationInfoOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        LoginNotificationInfo.class.getName());
    }
    // Use LoginNotificationInfo.newBuilder() to construct.
    private LoginNotificationInfo(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private LoginNotificationInfo() {
      email_ = "";
      host_ = "";
      source_ = "";
      eventType_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.internal_static_securegcm_LoginNotificationInfo_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.internal_static_securegcm_LoginNotificationInfo_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo.class, com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo.Builder.class);
    }

    private int bitField0_;
    public static final int CREATION_TIME_FIELD_NUMBER = 2;
    private long creationTime_ = 0L;
    /**
     * <pre>
     * Time at which the server received the login notification request.
     * </pre>
     *
     * <code>optional fixed64 creation_time = 2;</code>
     * @return Whether the creationTime field is set.
     */
    @java.lang.Override
    public boolean hasCreationTime() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Time at which the server received the login notification request.
     * </pre>
     *
     * <code>optional fixed64 creation_time = 2;</code>
     * @return The creationTime.
     */
    @java.lang.Override
    public long getCreationTime() {
      return creationTime_;
    }

    public static final int EMAIL_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object email_ = "";
    /**
     * <pre>
     * Must correspond to user_id in LoginNotificationRequest, if set.
     * </pre>
     *
     * <code>optional string email = 3;</code>
     * @return Whether the email field is set.
     */
    @java.lang.Override
    public boolean hasEmail() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Must correspond to user_id in LoginNotificationRequest, if set.
     * </pre>
     *
     * <code>optional string email = 3;</code>
     * @return The email.
     */
    @java.lang.Override
    public java.lang.String getEmail() {
      java.lang.Object ref = email_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          email_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Must correspond to user_id in LoginNotificationRequest, if set.
     * </pre>
     *
     * <code>optional string email = 3;</code>
     * @return The bytes for email.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getEmailBytes() {
      java.lang.Object ref = email_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        email_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int HOST_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object host_ = "";
    /**
     * <pre>
     * Host where the user's credentials were used to login, if meaningful.
     * </pre>
     *
     * <code>optional string host = 4;</code>
     * @return Whether the host field is set.
     */
    @java.lang.Override
    public boolean hasHost() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Host where the user's credentials were used to login, if meaningful.
     * </pre>
     *
     * <code>optional string host = 4;</code>
     * @return The host.
     */
    @java.lang.Override
    public java.lang.String getHost() {
      java.lang.Object ref = host_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          host_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Host where the user's credentials were used to login, if meaningful.
     * </pre>
     *
     * <code>optional string host = 4;</code>
     * @return The bytes for host.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getHostBytes() {
      java.lang.Object ref = host_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        host_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SOURCE_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private volatile java.lang.Object source_ = "";
    /**
     * <pre>
     * Location from where the user's credentials were used, if meaningful.
     * </pre>
     *
     * <code>optional string source = 5;</code>
     * @return Whether the source field is set.
     */
    @java.lang.Override
    public boolean hasSource() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Location from where the user's credentials were used, if meaningful.
     * </pre>
     *
     * <code>optional string source = 5;</code>
     * @return The source.
     */
    @java.lang.Override
    public java.lang.String getSource() {
      java.lang.Object ref = source_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          source_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Location from where the user's credentials were used, if meaningful.
     * </pre>
     *
     * <code>optional string source = 5;</code>
     * @return The bytes for source.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getSourceBytes() {
      java.lang.Object ref = source_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        source_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int EVENT_TYPE_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private volatile java.lang.Object eventType_ = "";
    /**
     * <pre>
     * Type of login, e.g. ssh, gnome-screensaver, or web.
     * </pre>
     *
     * <code>optional string event_type = 6;</code>
     * @return Whether the eventType field is set.
     */
    @java.lang.Override
    public boolean hasEventType() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Type of login, e.g. ssh, gnome-screensaver, or web.
     * </pre>
     *
     * <code>optional string event_type = 6;</code>
     * @return The eventType.
     */
    @java.lang.Override
    public java.lang.String getEventType() {
      java.lang.Object ref = eventType_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          eventType_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Type of login, e.g. ssh, gnome-screensaver, or web.
     * </pre>
     *
     * <code>optional string event_type = 6;</code>
     * @return The bytes for eventType.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getEventTypeBytes() {
      java.lang.Object ref = eventType_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        eventType_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeFixed64(2, creationTime_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, email_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 4, host_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 5, source_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 6, eventType_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFixed64Size(2, creationTime_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, email_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(4, host_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(5, source_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(6, eventType_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo)) {
        return super.equals(obj);
      }
      com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo other = (com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo) obj;

      if (hasCreationTime() != other.hasCreationTime()) return false;
      if (hasCreationTime()) {
        if (getCreationTime()
            != other.getCreationTime()) return false;
      }
      if (hasEmail() != other.hasEmail()) return false;
      if (hasEmail()) {
        if (!getEmail()
            .equals(other.getEmail())) return false;
      }
      if (hasHost() != other.hasHost()) return false;
      if (hasHost()) {
        if (!getHost()
            .equals(other.getHost())) return false;
      }
      if (hasSource() != other.hasSource()) return false;
      if (hasSource()) {
        if (!getSource()
            .equals(other.getSource())) return false;
      }
      if (hasEventType() != other.hasEventType()) return false;
      if (hasEventType()) {
        if (!getEventType()
            .equals(other.getEventType())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasCreationTime()) {
        hash = (37 * hash) + CREATION_TIME_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getCreationTime());
      }
      if (hasEmail()) {
        hash = (37 * hash) + EMAIL_FIELD_NUMBER;
        hash = (53 * hash) + getEmail().hashCode();
      }
      if (hasHost()) {
        hash = (37 * hash) + HOST_FIELD_NUMBER;
        hash = (53 * hash) + getHost().hashCode();
      }
      if (hasSource()) {
        hash = (37 * hash) + SOURCE_FIELD_NUMBER;
        hash = (53 * hash) + getSource().hashCode();
      }
      if (hasEventType()) {
        hash = (37 * hash) + EVENT_TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getEventType().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code securegcm.LoginNotificationInfo}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:securegcm.LoginNotificationInfo)
        com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.internal_static_securegcm_LoginNotificationInfo_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.internal_static_securegcm_LoginNotificationInfo_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo.class, com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo.Builder.class);
      }

      // Construct using com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        creationTime_ = 0L;
        email_ = "";
        host_ = "";
        source_ = "";
        eventType_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.internal_static_securegcm_LoginNotificationInfo_descriptor;
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo getDefaultInstanceForType() {
        return com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo build() {
        com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo buildPartial() {
        com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo result = new com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.creationTime_ = creationTime_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.email_ = email_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.host_ = host_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.source_ = source_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.eventType_ = eventType_;
          to_bitField0_ |= 0x00000010;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo) {
          return mergeFrom((com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo other) {
        if (other == com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo.getDefaultInstance()) return this;
        if (other.hasCreationTime()) {
          setCreationTime(other.getCreationTime());
        }
        if (other.hasEmail()) {
          email_ = other.email_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasHost()) {
          host_ = other.host_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        if (other.hasSource()) {
          source_ = other.source_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (other.hasEventType()) {
          eventType_ = other.eventType_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 17: {
                creationTime_ = input.readFixed64();
                bitField0_ |= 0x00000001;
                break;
              } // case 17
              case 26: {
                email_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 26
              case 34: {
                host_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 34
              case 42: {
                source_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 42
              case 50: {
                eventType_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 50
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long creationTime_ ;
      /**
       * <pre>
       * Time at which the server received the login notification request.
       * </pre>
       *
       * <code>optional fixed64 creation_time = 2;</code>
       * @return Whether the creationTime field is set.
       */
      @java.lang.Override
      public boolean hasCreationTime() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Time at which the server received the login notification request.
       * </pre>
       *
       * <code>optional fixed64 creation_time = 2;</code>
       * @return The creationTime.
       */
      @java.lang.Override
      public long getCreationTime() {
        return creationTime_;
      }
      /**
       * <pre>
       * Time at which the server received the login notification request.
       * </pre>
       *
       * <code>optional fixed64 creation_time = 2;</code>
       * @param value The creationTime to set.
       * @return This builder for chaining.
       */
      public Builder setCreationTime(long value) {

        creationTime_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Time at which the server received the login notification request.
       * </pre>
       *
       * <code>optional fixed64 creation_time = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearCreationTime() {
        bitField0_ = (bitField0_ & ~0x00000001);
        creationTime_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object email_ = "";
      /**
       * <pre>
       * Must correspond to user_id in LoginNotificationRequest, if set.
       * </pre>
       *
       * <code>optional string email = 3;</code>
       * @return Whether the email field is set.
       */
      public boolean hasEmail() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Must correspond to user_id in LoginNotificationRequest, if set.
       * </pre>
       *
       * <code>optional string email = 3;</code>
       * @return The email.
       */
      public java.lang.String getEmail() {
        java.lang.Object ref = email_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            email_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Must correspond to user_id in LoginNotificationRequest, if set.
       * </pre>
       *
       * <code>optional string email = 3;</code>
       * @return The bytes for email.
       */
      public com.google.protobuf.ByteString
          getEmailBytes() {
        java.lang.Object ref = email_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          email_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Must correspond to user_id in LoginNotificationRequest, if set.
       * </pre>
       *
       * <code>optional string email = 3;</code>
       * @param value The email to set.
       * @return This builder for chaining.
       */
      public Builder setEmail(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        email_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Must correspond to user_id in LoginNotificationRequest, if set.
       * </pre>
       *
       * <code>optional string email = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearEmail() {
        email_ = getDefaultInstance().getEmail();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Must correspond to user_id in LoginNotificationRequest, if set.
       * </pre>
       *
       * <code>optional string email = 3;</code>
       * @param value The bytes for email to set.
       * @return This builder for chaining.
       */
      public Builder setEmailBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        email_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private java.lang.Object host_ = "";
      /**
       * <pre>
       * Host where the user's credentials were used to login, if meaningful.
       * </pre>
       *
       * <code>optional string host = 4;</code>
       * @return Whether the host field is set.
       */
      public boolean hasHost() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Host where the user's credentials were used to login, if meaningful.
       * </pre>
       *
       * <code>optional string host = 4;</code>
       * @return The host.
       */
      public java.lang.String getHost() {
        java.lang.Object ref = host_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            host_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Host where the user's credentials were used to login, if meaningful.
       * </pre>
       *
       * <code>optional string host = 4;</code>
       * @return The bytes for host.
       */
      public com.google.protobuf.ByteString
          getHostBytes() {
        java.lang.Object ref = host_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          host_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Host where the user's credentials were used to login, if meaningful.
       * </pre>
       *
       * <code>optional string host = 4;</code>
       * @param value The host to set.
       * @return This builder for chaining.
       */
      public Builder setHost(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        host_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Host where the user's credentials were used to login, if meaningful.
       * </pre>
       *
       * <code>optional string host = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearHost() {
        host_ = getDefaultInstance().getHost();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Host where the user's credentials were used to login, if meaningful.
       * </pre>
       *
       * <code>optional string host = 4;</code>
       * @param value The bytes for host to set.
       * @return This builder for chaining.
       */
      public Builder setHostBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        host_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private java.lang.Object source_ = "";
      /**
       * <pre>
       * Location from where the user's credentials were used, if meaningful.
       * </pre>
       *
       * <code>optional string source = 5;</code>
       * @return Whether the source field is set.
       */
      public boolean hasSource() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Location from where the user's credentials were used, if meaningful.
       * </pre>
       *
       * <code>optional string source = 5;</code>
       * @return The source.
       */
      public java.lang.String getSource() {
        java.lang.Object ref = source_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            source_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Location from where the user's credentials were used, if meaningful.
       * </pre>
       *
       * <code>optional string source = 5;</code>
       * @return The bytes for source.
       */
      public com.google.protobuf.ByteString
          getSourceBytes() {
        java.lang.Object ref = source_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          source_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Location from where the user's credentials were used, if meaningful.
       * </pre>
       *
       * <code>optional string source = 5;</code>
       * @param value The source to set.
       * @return This builder for chaining.
       */
      public Builder setSource(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        source_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Location from where the user's credentials were used, if meaningful.
       * </pre>
       *
       * <code>optional string source = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearSource() {
        source_ = getDefaultInstance().getSource();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Location from where the user's credentials were used, if meaningful.
       * </pre>
       *
       * <code>optional string source = 5;</code>
       * @param value The bytes for source to set.
       * @return This builder for chaining.
       */
      public Builder setSourceBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        source_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private java.lang.Object eventType_ = "";
      /**
       * <pre>
       * Type of login, e.g. ssh, gnome-screensaver, or web.
       * </pre>
       *
       * <code>optional string event_type = 6;</code>
       * @return Whether the eventType field is set.
       */
      public boolean hasEventType() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Type of login, e.g. ssh, gnome-screensaver, or web.
       * </pre>
       *
       * <code>optional string event_type = 6;</code>
       * @return The eventType.
       */
      public java.lang.String getEventType() {
        java.lang.Object ref = eventType_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            eventType_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Type of login, e.g. ssh, gnome-screensaver, or web.
       * </pre>
       *
       * <code>optional string event_type = 6;</code>
       * @return The bytes for eventType.
       */
      public com.google.protobuf.ByteString
          getEventTypeBytes() {
        java.lang.Object ref = eventType_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          eventType_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Type of login, e.g. ssh, gnome-screensaver, or web.
       * </pre>
       *
       * <code>optional string event_type = 6;</code>
       * @param value The eventType to set.
       * @return This builder for chaining.
       */
      public Builder setEventType(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        eventType_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of login, e.g. ssh, gnome-screensaver, or web.
       * </pre>
       *
       * <code>optional string event_type = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearEventType() {
        eventType_ = getDefaultInstance().getEventType();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of login, e.g. ssh, gnome-screensaver, or web.
       * </pre>
       *
       * <code>optional string event_type = 6;</code>
       * @param value The bytes for eventType to set.
       * @return This builder for chaining.
       */
      public Builder setEventTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        eventType_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:securegcm.LoginNotificationInfo)
    }

    // @@protoc_insertion_point(class_scope:securegcm.LoginNotificationInfo)
    private static final com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo();
    }

    public static com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<LoginNotificationInfo>
        PARSER = new com.google.protobuf.AbstractParser<LoginNotificationInfo>() {
      @java.lang.Override
      public LoginNotificationInfo parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<LoginNotificationInfo> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<LoginNotificationInfo> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.security.cryptauth.lib.securegcm.SecureGcmProto.LoginNotificationInfo getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_securegcm_GcmDeviceInfo_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_securegcm_GcmDeviceInfo_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_securegcm_GcmMetadata_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_securegcm_GcmMetadata_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_securegcm_Tickle_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_securegcm_Tickle_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_securegcm_LoginNotificationInfo_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_securegcm_LoginNotificationInfo_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\017securegcm.proto\022\tsecuregcm\"\257\n\n\rGcmDevi" +
      "ceInfo\022\031\n\021android_device_id\030\001 \001(\006\022\033\n\023gcm" +
      "_registration_id\030f \001(\014\022\034\n\023apn_registrati" +
      "on_id\030\312\001 \001(\014\022#\n\024notification_enabled\030\313\001 " +
      "\001(\010:\004true\022\036\n\025bluetooth_mac_address\030\256\002 \001(" +
      "\t\022\036\n\026device_master_key_hash\030g \001(\014\022\027\n\017use" +
      "r_public_key\030\004 \002(\014\022\024\n\014device_model\030\007 \001(\t" +
      "\022\016\n\006locale\030\010 \001(\t\022\022\n\nkey_handle\030\t \001(\014\022\022\n\007" +
      "counter\030\014 \001(\003:\0010\022\031\n\021device_os_version\030\r " +
      "\001(\t\022\036\n\026device_os_version_code\030\016 \001(\003\022\031\n\021d" +
      "evice_os_release\030\017 \001(\t\022\032\n\022device_os_code" +
      "name\030\020 \001(\t\022\037\n\027device_software_version\030\021 " +
      "\001(\t\022$\n\034device_software_version_code\030\022 \001(" +
      "\003\022\037\n\027device_software_package\030\023 \001(\t\022$\n\034de" +
      "vice_display_diagonal_mils\030\026 \001(\005\022\036\n\026devi" +
      "ce_authzen_version\030\030 \001(\005\022\026\n\016long_device_" +
      "id\030\035 \001(\014\022\033\n\023device_manufacturer\030\037 \001(\t\0223\n" +
      "\013device_type\030  \001(\0162\025.securegcm.DeviceTyp" +
      "e:\007ANDROID\022\'\n\027using_secure_screenlock\030\220\003" +
      " \001(\010:\005false\0220\n auto_unlock_screenlock_su" +
      "pported\030\221\003 \001(\010:\005false\022.\n\036auto_unlock_scr" +
      "eenlock_enabled\030\222\003 \001(\010:\005false\022)\n\031bluetoo" +
      "th_radio_supported\030\223\003 \001(\010:\005false\022\'\n\027blue" +
      "tooth_radio_enabled\030\224\003 \001(\010:\005false\022%\n\025mob" +
      "ile_data_supported\030\225\003 \001(\010:\005false\022#\n\023teth" +
      "ering_supported\030\226\003 \001(\010:\005false\022#\n\023ble_rad" +
      "io_supported\030\227\003 \001(\010:\005false\022 \n\020pixel_expe" +
      "rience\030\230\003 \001(\010:\005false\022\035\n\rarc_plus_plus\030\231\003" +
      " \001(\010:\005false\022)\n\031is_screenlock_state_flaky" +
      "\030\232\003 \001(\010:\005false\022@\n\033supported_software_fea" +
      "tures\030\233\003 \003(\0162\032.securegcm.SoftwareFeature" +
      "\022>\n\031enabled_software_features\030\234\003 \003(\0162\032.s" +
      "ecuregcm.SoftwareFeature\022\036\n\025enrollment_s" +
      "ession_id\030\350\007 \001(\014\022\024\n\013oauth_token\030\351\007 \001(\t\"@" +
      "\n\013GcmMetadata\022\035\n\004type\030\001 \002(\0162\017.securegcm." +
      "Type\022\022\n\007version\030\002 \001(\005:\0010\"\035\n\006Tickle\022\023\n\013ex" +
      "piry_time\030\001 \001(\006\"o\n\025LoginNotificationInfo" +
      "\022\025\n\rcreation_time\030\002 \001(\006\022\r\n\005email\030\003 \001(\t\022\014" +
      "\n\004host\030\004 \001(\t\022\016\n\006source\030\005 \001(\t\022\022\n\nevent_ty" +
      "pe\030\006 \001(\t*;\n\027AppleDeviceDiagonalMils\022\020\n\013A" +
      "PPLE_PHONE\020\240\037\022\016\n\tAPPLE_PAD\020\334=*Q\n\nDeviceT" +
      "ype\022\013\n\007UNKNOWN\020\000\022\013\n\007ANDROID\020\001\022\n\n\006CHROME\020" +
      "\002\022\007\n\003IOS\020\003\022\013\n\007BROWSER\020\004\022\007\n\003OSX\020\005*\350\001\n\017Sof" +
      "twareFeature\022\023\n\017UNKNOWN_FEATURE\020\000\022\030\n\024BET" +
      "TER_TOGETHER_HOST\020\001\022\032\n\026BETTER_TOGETHER_C" +
      "LIENT\020\002\022\024\n\020EASY_UNLOCK_HOST\020\003\022\026\n\022EASY_UN" +
      "LOCK_CLIENT\020\004\022\025\n\021MAGIC_TETHER_HOST\020\005\022\027\n\023" +
      "MAGIC_TETHER_CLIENT\020\006\022\024\n\020SMS_CONNECT_HOS" +
      "T\020\007\022\026\n\022SMS_CONNECT_CLIENT\020\010*\270\003\n\020Invocati" +
      "onReason\022\022\n\016REASON_UNKNOWN\020\000\022\031\n\025REASON_I" +
      "NITIALIZATION\020\001\022\023\n\017REASON_PERIODIC\020\002\022\030\n\024" +
      "REASON_SLOW_PERIODIC\020\003\022\030\n\024REASON_FAST_PE" +
      "RIODIC\020\004\022\025\n\021REASON_EXPIRATION\020\005\022\033\n\027REASO" +
      "N_FAILURE_RECOVERY\020\006\022\026\n\022REASON_NEW_ACCOU" +
      "NT\020\007\022\032\n\026REASON_CHANGED_ACCOUNT\020\010\022\032\n\026REAS" +
      "ON_FEATURE_TOGGLED\020\t\022\033\n\027REASON_SERVER_IN" +
      "ITIATED\020\n\022\031\n\025REASON_ADDRESS_CHANGE\020\013\022\032\n\026" +
      "REASON_SOFTWARE_UPDATE\020\014\022\021\n\rREASON_MANUA" +
      "L\020\r\022\"\n\036REASON_CUSTOM_KEY_INVALIDATION\020\016\022" +
      "\035\n\031REASON_PROXIMITY_PERIODIC\020\017*\204\003\n\004Type\022" +
      "\016\n\nENROLLMENT\020\000\022\n\n\006TICKLE\020\001\022\016\n\nTX_REQUES" +
      "T\020\002\022\014\n\010TX_REPLY\020\003\022\023\n\017TX_SYNC_REQUEST\020\004\022\024" +
      "\n\020TX_SYNC_RESPONSE\020\005\022\013\n\007TX_PING\020\006\022\026\n\022DEV" +
      "ICE_INFO_UPDATE\020\007\022\025\n\021TX_CANCEL_REQUEST\020\010" +
      "\022\031\n\025PROXIMITYAUTH_PAIRING\020\n\022\034\n\030GCMV1_IDE" +
      "NTITY_ASSERTION\020\013\022,\n(DEVICE_TO_DEVICE_RE" +
      "SPONDER_HELLO_PAYLOAD\020\014\022\034\n\030DEVICE_TO_DEV" +
      "ICE_MESSAGE\020\r\022\035\n\031DEVICE_PROXIMITY_CALLBA" +
      "CK\020\016\022\037\n\033UNLOCK_KEY_SIGNED_CHALLENGE\020\017\022\026\n" +
      "\022LOGIN_NOTIFICATION\020eBF\n+com.google.secu" +
      "rity.cryptauth.lib.securegcmB\016SecureGcmP" +
      "rotoH\003\242\002\004SGCM"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        });
    internal_static_securegcm_GcmDeviceInfo_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_securegcm_GcmDeviceInfo_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_securegcm_GcmDeviceInfo_descriptor,
        new java.lang.String[] { "AndroidDeviceId", "GcmRegistrationId", "ApnRegistrationId", "NotificationEnabled", "BluetoothMacAddress", "DeviceMasterKeyHash", "UserPublicKey", "DeviceModel", "Locale", "KeyHandle", "Counter", "DeviceOsVersion", "DeviceOsVersionCode", "DeviceOsRelease", "DeviceOsCodename", "DeviceSoftwareVersion", "DeviceSoftwareVersionCode", "DeviceSoftwarePackage", "DeviceDisplayDiagonalMils", "DeviceAuthzenVersion", "LongDeviceId", "DeviceManufacturer", "DeviceType", "UsingSecureScreenlock", "AutoUnlockScreenlockSupported", "AutoUnlockScreenlockEnabled", "BluetoothRadioSupported", "BluetoothRadioEnabled", "MobileDataSupported", "TetheringSupported", "BleRadioSupported", "PixelExperience", "ArcPlusPlus", "IsScreenlockStateFlaky", "SupportedSoftwareFeatures", "EnabledSoftwareFeatures", "EnrollmentSessionId", "OauthToken", });
    internal_static_securegcm_GcmMetadata_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_securegcm_GcmMetadata_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_securegcm_GcmMetadata_descriptor,
        new java.lang.String[] { "Type", "Version", });
    internal_static_securegcm_Tickle_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_securegcm_Tickle_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_securegcm_Tickle_descriptor,
        new java.lang.String[] { "ExpiryTime", });
    internal_static_securegcm_LoginNotificationInfo_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_securegcm_LoginNotificationInfo_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_securegcm_LoginNotificationInfo_descriptor,
        new java.lang.String[] { "CreationTime", "Email", "Host", "Source", "EventType", });
    descriptor.resolveAllFeaturesImmutable();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
